Linux命令：
--------------------------------------------------------------------------
文章收入自：
https://dongshao.blog.csdn.net/article/details/86822769?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-86822769-blog-120997798.pc_relevant_layerdownloadsortv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-86822769-blog-120997798.pc_relevant_layerdownloadsortv1&utm_relevant_index=1

https://blog.csdn.net/carefree2005/article/details/120997798?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166479242916782390563433%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166479242916782390563433&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-120997798-null-null.142^v51^new_blog_pos_by_title,201^v3^control_1&utm_term=mkfs&spm=1018.2226.3001.4187

https://blog.csdn.net/k346k346/category_9267835.html(已收入至第142篇)

https://dablelv.blog.csdn.net/?type=blog

https://blog.csdn.net/General_zy/article/details/124506399

https://blog.csdn.net/whatday/article/details/78467023?ops_request_misc=&request_id=&biz_id=102&utm_term=dpkg&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-78467023.142^v59^js_top,201^v3^control_2&spm=1018.2226.3001.4187

--------------------------------------------------------------------------
●man 命令：
1.命令简介
man（manual） 命令用于查看命令帮助、配置文件帮助和编程帮助等信息。
Linux 提供了丰富的命令以及帮助手册，当需要了解某个命令的作用及用法时，可以使用 man 查看一下其帮助手册，同时也可以使用 man man 查看 man 命令的使用方法。当需要了解与编程相关的系统调用以及库函数的用法时，也可以通过 man 查看接口的帮助手册。此外，系统相关的配置文件的介绍也可以通过 man 来查看。
man 可以查询不同类型的帮助手册，当目标存在多个不同类型的帮助手册时，我们可以指定要查找的手册类型，也可以不指定，此时 man 会搜索所有类型的帮助手册，但是只会按照预定义的顺序展示第一个。预定义的顺序可以使用环境变量 $MANSECT 或配置文件 /usr/local/etc/man_db.conf 中的 SECTION 指令指定，默认为：

1 8 3 2 5 4 9 6 7

帮助手册分为多种类型，即不同的 section，主要有：

1	可执行程序或 Shell 命令
1p	可执行程序或 Shell 命令（POSIX 版）
2	系统调用（内核提供的函数）
3	库调用（程序库中的函数）
4	特殊文件（通常在/dev中找到）
5	文件格式和约定，如 /etc/passwd
6	游戏
7	杂项（包括宏包和约定），例如 man（7）、groff（7）
8	系统管理命令（通常只针对 root 用户）
9	内核相关文件[非标准]

帮助手册约定内容包括：

NAME			名称
SYNOPSIS		简介
CONFIGURATION	配置
DESCRIPTION		描述
OPTIONS			选项
EXIT STATUS		退出码
RETURN VALUE	返回值
ERRORS			错误
ENVIRONMENT		环境变量
FILES			相关文件
VERSIONS		版本
CONFORMING TO	遵循的规则
NOTES			注意事项
BUGS			缺陷
EXAMPLE			示例
AUTHORS			作者
COPYRIGHT 		版权
SEE ALSO		拓展阅读
HISTORY			维护历史

在表现形式上，手册遵循如下规则：

粗体内容：重点关键词
斜体内容：待替换内容。因为终端渲染问题，一般使用下划线或彩色文本替代斜体
[-abc]：中括号内的选项或内容是可选的
-a|-b：被 | 分隔的选项是多选一，不能一起使用
...：三个点号表示重复

2.命令格式

man [OPTION]... [[SECTION] PAGE]...

man 可以不跟任何选项与参数，会输出如下提示信息：

What manual page do you want?

3.选项说明

阅读下面的选项说明，需要注意以下几点：
（1）没有参数的选项可以重复出现，有参数的选项如果重复出现，后面选项的参数将会覆盖前面的参数；
（2）长选项的必填参数对于短选项也是必须的。

一般选项:
-C, --config-file=FILE
	使用指定的用户配置文件而不是默认的 ~/.manpath
-d, --debug
	打印 debug 信息
-D, --default
	此选项通常作为第一个选项，将 man 的行为重置为默认行为。它的用途是重置那些可能已经在 $MANOPT 中设置的选项。在 -D 后面的选项会正常生效
--warnings[=WARNINGS]
	启动来自 groff 的告警。groff 是 GNU 版 troff，是文字排版工具

主要操作模式:
-f, --whatis
	等同于 whatis 命令，显示手册页中的简短说明（如果可用），详见 whatis(1)
-k, --apropos
	等同于 apropos 命令，按照关键字搜索手册页中的简短描述并显示任何匹配，详见 apropos(1)
-K, --global-apropos
	在所有手册页中搜索文本。这是蛮力搜索，可能需要一些时间，如果可以，应该指定一个 section 来减少需要搜索的手册页数量
-l, --local-file
	激活本地模式。格式化和显示本地手册文件，而不是通过搜索系统的手册集
-w, --where, --path, --location
	不显示手册页内容，输出手册的位置
-W, --where-cat, --location-cat
	不显示手册页内容，输出 cat 文件的位置
-c, --catman
	此选项不用于一般用途，只能由管理员命令 catman 使用
-R encoding, --recode=encoding
	以指定编码输出手册内容

寻找手册页：
-L, --locale=LOCALE
	man 通常通过调用 C 函数setlocale（3）来确定当前的语言环境，该函数询问各种环境变量，可能包括 $LC_MESSAGES 和 $LANG。该选项可以临时改变 man 的语言环境
-m, --systems=SYSTEM[,...]
	访问其他系统的手册页集，可指定多个不同的系统
-M, --manpath=path
	指定手册页的路径。该选项将会覆盖环境变量 $MANPATH 且使 man 忽略选项 -m 选项
-S, -s, --sections=LIST
	指定 man 搜索的手册页类型列表，使用冒号或逗号分隔，man 将按照给定的顺序进行搜索。该选项将覆盖环境变量 $MANSECT
-e , --extension=SUB-EXTENSION
	将搜索限制在扩展类型为 SUB-EXTENSION 的手册页之内
-i, --ignore-case
	搜索手册页时忽略大小写（默认）
-I, --match-case
	搜索手册页时大小写敏感
--regex
	以正则表达式搜索手册页并显示所有匹配的手册页
--wildcard
	以通配符搜索手册页并显示所有匹配的手册页
--names-only
	当使用选项 --regex 或 --wildcard 时，只搜索手册页的 NAME 部分，不搜索 DESCRIPTION 部分
-a, --all
	显示所有匹配的手册页而不是仅显示第一个匹配的手册页
-u, --update
	该选项导致 man 对其数据库缓存执行 inode 级别的一致性检查，以确保它们是文件系统的准确表示。只有安装了设置了 setuid 位的 man 才会产生有用的效果
--no-subpages
	出线成对的手册页名时，第二个手册页名作为单独的手册页名，而是不第一个手册页的子手册页。比如有些命令存在子命令，例如 git

控制格式化输出：
-P, --pager=PAGER
	指定浏览手册页的工具，man 默认使用 less -s。该选项覆盖 $MANPAGER 环境变量，后者又覆盖 $PAGER 环境变量。它不与 -f 或 -k 连用
-r, --prompt=PROMPT
	如果使用 less 作为手册页的浏览工具，man 将尝试设置其提示和一些合理的选项。默认提示为 Manual page name(sec) line x
-7, --ascii
	使用 ASCII 字符浏览手册页
-E, --encoding=ENCODING
	使用指定编码输出手册也内容
--no-hyphenation, --nh
	换行处不使用连字符
--no-justification, --nj
	不调整字距离以铺满整行
-p, --preprocessor=STRING
	指定在 nroff 或 troff/groff 之前运行的预处理程序的顺序
-t, --troff
	使用 groff -mandoc 将手册页格式化为标准输出。给定 -H、-T 或 -Z 不需要此选项
-T, --troff-device[=DEVICE]
	此选项用于更改 groff(或 troff)的输出设备，使其适合于默认设备之外的设备
-H, --html[=BROWSER]
	此选项将导致 groff 生成 HTML 输出，并将在 web 浏览器中显示该输出
-X, --gxditview[=DPI]
	使用 gxditview 程序在图形窗口中显示 groff 的输出。DPI(点/英寸)可能是 75、75-12、100 或 100-12，默认为 75
-Z, --ditroff
	groff 将运行 troff，然后使用适当的后处理器生成适合所选设备的输出。如果 groff 表示 groff -mandoc，那么 该选项将抑制 groff 使用后处理器

获取帮助：
-?, --help
	输出帮助并推出
--usage
	打印一个简短的用法并退出
-V, --version
	输出版本并退出

实际上，日常使用 man 时很少会用到 man 的选项，最常用的是指定手册类型和手册名：

man SECTION PAGE

4.交互式命令
由于 man 默认使用 less 作为手册的浏览工具，这里给出 less 常用的浏览导航交互式命令。如果忘记命令，可以键入 h 或 H 查看命令的帮助信息。

ENTER 向前滚动一行
y 向后滚动一行

d 向前滚动半屏
u 向后滚动半屏

f 向前滚动一屏
b 向后滚动一屏

g 跳转到文件首行
G 跳转到文件末行

/PATTERN 向前搜索指定内容
n 跳转到下一个匹配项
N 跳转到前一个匹配项

h 显示帮助信息
q 退出

5.常用示例
（1）查看用户命令 man 的帮助手册。

man man

# 或
man 1 man

如果想查看 POSIX 版本的命令帮助手册，指定 SECTION 为 1p 即可。

man 1p man

（2）查看系统调用 read 的帮助手册。

man 2 read

（3）查看库函数 printf 的帮助手册。

man 3 printf

（4）查看特殊的设备文件 tty 的帮助手册。

man 4 tty

（5）查看用户信息文件 /etc/passwd 格式说明。

man 5 passwd

（6）查看用于格式化手册的宏。

man 7 man

（7）查看系统管理命令 mount。

man 8 mount

（8）查看手册的地址而不是手册内容，以 man 命令为例。

man -w man
/usr/share/man/man1/man.1.gz

●xargs 命令：

1.命令简介

xargs 可以将 stdin 中以空格或换行符进行分隔的数据，形成以空格分隔的参数（arguments），传递给其他命令。因为以空格作为分隔符，所以有一些文件名或者其他意义的字符串内含有空格的时候，xargs 可能会误判。简单来说，xargs 的作用是给其他命令传递参数，是构建单行命令的重要组件之一。

之所以要用到 xargs，是因为很多命令不支持使用管道 | 来传递参数，例如：

find /sbin -perm +700 | ls -l         # 这个命令是错误,因为标准输入不能作为ls的参数
find /sbin -perm +700 | xargs ls -l   # 这样才是正确的

2.命令格式

xargs [OPTIONS] [COMMAND]

3.选项说明

注意，长选项的强制性参数对于短选项也是强制的。

-0, --null
	如果输入的 stdin 含有特殊字符，例如反引号 `、反斜杠 \、空格等字符时，xargs 将它还原成一般字符。为默认选项
-a, --arg-file=FILE
	从指定的文件 FILE 中读取输入内容而不是从标准输入
-d, --delimiter=DEL
	指定 xargs 处理输入内容时的分隔符。xargs 处理输入内容默认是按空格和换行符作为分隔符，输出 arguments 时按空格分隔
-E EOF_STR
	EOF_STR 是 end of file string，表示输入的结束
-e, --eof[=EOF_STR]
	作用等同于 -E 选项，与 -E 选项不同时，该选项不符合 POSIX 标准且 EOF_STR 不是强制的。如果没有 EOF_STR 则表示输入没有结束符
-I REPLACE_STR
	将 xargs 输出的每一项参数单独赋值给后面的命令，参数需要用指定的替代字符串 REPLACE_STR 代替。REPLACE_STR 可以使用 {} $ @ 等符号，其主要作用是当 xargs command 后有多个参数时，调整参数位置。例如备份以 txt 为后缀的文件：find . -name "*.txt" | xargs -I {}  cp {} /tmp/{}.bak
-i, --replace[=REPLACE_STR]
	作用同 -I 选项，参数 REPLACE_STR 是可选的，缺省为 {}。建议使用 -I 选项，因为其符合 POSIX
-L MAX_LINES
	限定最大输入行数。隐含了 -x 选项
-l, --max-lines[=MAX_LINES]
	作用同 -L 选项，参数 MAX_LINES 是可选的，缺省为 1。建议使用 -L 选项，因为其符合 POSIX 标准
-n, --max-args=MAX_ARGS
	表示命令在执行的时候一次使用参数的最大个数
-o, --open-tty
	在执行命令之前，在子进程中重新打开stdin作为/dev/TTY。如果您希望xargs运行交互式应用程序，这是非常有用的
-P, --max-procs=MAX_PROCS
	每次运行最大进程；缺省值为 1。如果 MAX_PROCS 为 0，xargs 将一次运行尽可能多的进程。一般和 -n 或 -L 选项一起使用
-p, --interactive
	当每次执行一个 argument 的时候询问一次用户
--process-slot-var=NAME
	将指定的环境变量设置为每个正在运行的子进程中的唯一值。一旦子进程退出，将重用该值。例如，这可以用于初始负荷分配方案
-r, --no-run-if-empty
	当 xargs 的输入为空的时候则停止 xargs，不用再去执行后面的命令了。为默认选项
-s, --max-chars=MAX_CHARS
	命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数，包括命令、空格和换行符。每个参数单独传入 xargs 后面的命令
--show-limits
	显示操作系统对命令行长度的限制
-t， --verbose
	先打印命令到标准错误输出，然后再执行
-x, --exit
	配合 -s 使用，当命令行字符数大于 -s 指定的数值时，退出 xargs
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）将 Shell 的特殊字符反引号还原为一般字符。

echo '`0123`4 56789' | xargs -t echo
echo `0123`4 56789 
`0123`4 56789

如果直接进行如下操作，会报无法找到命令 01234 的错误，因为反引号在 Shell 中会将 01234 作为一个命令来执行，但是 01234 不是一个命令。-t 表示先打印命令，然后再执行。

echo `01234` 56789
-bash: 01234: command not found
56789

（2）设置 xargs 读入参数时的结束标识，以逗号结束。这里要注意结束标志必须要是单独的字段，即以空格或者换行符分隔的字段。

echo 01234 , 56789 | xargs -E ","
01234

（3）使用 rm、mv 等命令同时操作多个文件时，有时会报 “argument list too long” 参数列表过长的错误，此时可以使用 xargs 来解决。xargs 将标准输入的字符串分隔后，作为参数传递给后面的命令。例如，给当前目录的所有文件添加后缀名。

ls | xargs -t -i mv {} {}.bak

# 选择符合条件的文件
ls | grep -E "201701|201702|201703" | xargs -I {} mv {} {}.bak

（4）设置命令行的最大字符数。参数默认一个一个单独传入命令中执行。

echo "01234 56789" | xargs -t -s 11
echo 01234 
01234
echo 56789 
56789

（5）设置标准输入中每次多少行作为命令的参数，默认是将标准输入中所有行的归并到一行一次性传给命令执行。

echo -e "01234\n56789\n01234" | xargs -t -L 2 echo
echo 01234 56789 
01234 56789
echo 01234 
01234

（6）将文件内容以空格分隔合并为一行输出。

# 列出文件内容
cat test.txt
a b c d e
f g h i j 
k l m n o

# 多行输入合并为一行输出
cat test.txt | xargs
a b c d e f g h i j k l m n o

（7）与 ps、grep、awk 和 kill 结合，强制终止指定进程。

ps -ef | grep spp | awk '{printf "%s ",$2}' | xargs kill -9

ps -ef|grep spp用于查找包含 spp 的进程，awk '{printf "%s ",$2,FNR}将目标进程 ID 打印输出，xargs kill -9则将目标进程 ID 作为参数传递给kill -9用于杀死进程。

●od 命令：
1.功能简介
od（Octal Dump）命令用于将指定文件内容以八进制、十进制、十六进制、浮点格式或 ASCII 编码字符方式显示，通常用于显示或查看文件中不能直接显示在终端的字符。od 命令系统默认的显示方式是八进制。
常见的文件为文本文件和二进制文件。od 命令主要用来查看保存在二进制文件中的值，按照指定格式解释文件中的数据并输出，不管是 IEEE754 格式的浮点数还是 ASCII 码，od 命令都能按照需求输出它们的值。
大家也可以了解一下 hexdump 命令，以十六进制输出，但感觉 hexdump 命令没有 od 命令强大。
2.命令格式

od [OPTION]... [FILE]...

3.选项说明

-A RADIX
--address-radix=RADIX
	选择以何种基数表示地址偏移
-j BYTES
--skip-bytes=BYTES
	跳过指定数目的字节
-N BYTES
--read-bytes=BYTES
	输出指定字节数
-S [BYTES]
--strings[=BYTES]
	输出长度不小于指定字节数的字符串，BYTES 缺省为 3
-v
--output-duplicates
	输出时不省略重复的数据
-w [BYTES]
--width[=BYTES]
	设置每行显示的字节数，BYTES 缺省为 32 字节
-t TYPE
--format=TYPE
	指定输出格式，格式包括 a、c、d、f、o、u 和 x，各含义如下：
  	a：具名字符；比如换行符显示为 nl
  	c：可打印字符或反斜杠表示的转义字符；比如换行符显示为 \n
 	d[SIZE]：SIZE 字节组成一个有符号十进制整数。SIZE 缺省为 sizeof(int)
 	f[SIZE]：SIZE 字节组成一个浮点数。SIZE 缺省为 sizeof(double)
  	o[SIZE]：SIZE 字节组成一个八进制整数。SIZE 缺省为 sizeof(int)
  	u[SIZE]：SIZE 字节组成一个无符号十进制整数。SIZE 缺省为 sizeof(int)
  	x[SIZE]：SIZE 字节组成一个十六进制整数。SIZE 缺省为 sizeof(int)
  	SIZE 可以为数字，也可以为大写字母。如果 TYPE 是 [doux] 中的一个，那么 SIZE 可以为 C  = sizeof(char)，S = sizeof(short)，I = sizeof(int)，L = sizeof(long)。如果 TYPE 是 f，那么 SIZE 可以为 F = sizeof(float)，D = sizeof(double) ，L = sizeof(long double)
--help
	在线帮助
--version
	显示版本信息

4.常用示例
（1）设置第一列偏移地址以十进制显示。

od -Ad testfile

偏移地址显示基数有：d for decimal, o for octal, x for hexadecimal or n for none。
（2）od 不显示第一列偏移地址。

od -An testfile

（3）以十六进制输出，默认以四字节为一组（一列）显示。

od -tx testfile

（4）以十六进制输出，每列输出一字节。

od -tx1 testfile

（5）显示ASCII字符和ASCII字符名称，注意换行符显示方式的区别。

#显示ASCII字符
[b3335@localhost]$ echo lvlv|od -a
0000000   l   v   l   v  nl
0000005

#显示ASCII字符名称
[b3335@localhost]$ echo lvlv|od -tc
0000000   l   v   l   v  \n
0000005

（6）以十六进制显示的同时显示原字符。

[b3335@localhost]$ echo lvlv|od -tcx1
0000000   l   v   l   v  \n
         6c  76  6c  76  0a
0000005

（7）指定每行显示512字节。

od -w512 -tx1 testfile

（8）od 命令输出时去除列与列之间的空格符。
当我们需要将文件内容显示为十六进制，需要输出连续的单个字节，每个字节以十六进制显示。这时我们可以通过od命令将文件以单个字节为一组，十六进制输出在同一行，并去除每个字节之间的空格。目前还不知道怎么通过指定od命令的相关选项去除列与列之间的空格，也许od命令本身并不支持。我的做法是：
（a）使用-An不输出偏移地址；
（b）使用-v输出时不省略重复的数据；
（c）使用-tx1以单个字节为一组按照十六进制输出，-w1每列输出一个字节；
（d）最后通过管道传递给 awk 的标准输入，通过awk不换行输出所有行，拼接为一行输出。
具体命令如下：

od -An -w1 -tx1 testfile|awk '{for(i=1;i<=NF;++i){printf "%s",$i}}'

●shutdown 命令：
1.功能
shutdown 指令可以关闭所有程序，并依用户的需要，进行重启或关机操作。
使用 shutdown 命令时，在系统关机前，可以通知所有登录者系统将要关闭。此时 login 指令会被冻结，新用户将不能再登录，这是推荐使用的安全关机方式。关机之前，所有进程都会受到 shutdown 指令所发送的关闭进程信号，然后向 init 程序发送信号，要求它改变运行等级（runlevel）。
Linux 系统有 7 个运行级别：
运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动；
运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆；
运行级别2：多用户状态(没有NFS)；
运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式；
运行级别4：系统未使用，保留；
运行级别5：X11控制台，登陆后进入图形GUI模式；
运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。
2.命令格式

shutdown [选项] [参数]

3.选项说明

-c
	cancel，其他用户可以取消目前正在执行的关机程序，或者Control-C终止shutdown程序
-k
	仅仅向每个登录用户发出警告信息，并不真正关机
-f
	重新启动时不执行fsck文件系统检查命令；
-F
	重新启动时执行fsck文件系统检查命令；
-h
	关机（halt）或关闭电源（power off），至于选择哪一种取决于系统的关机脚本（有時候可以在 BIOS 中更改）
-H
	关机（halt）；
-P
	关机，等价于 poweroff 命令
-n
	不调用 init 程序进行关机，而由 shutdown 自己进行
-r
	重启。等价于 reboot 命令
-t <秒数>
	送出警告信息和删除信息之间要延迟多少秒
--help
	显示帮助信息
--version
	显示版本

4.常用示例

（1）立刻关机，其中 now 相当于时间为 0 的状态。

shutdown -H now
//或
halt

（2）系统在今天的 20：25 分关机。

shutdown -H 20:25

（3）系统立刻重新启动。

shutdown -r now
//或
reboot

（4）发送后面的警告信息，再过 30 分钟系统会自动重启。

shutdown -r +30 'The system will reboot' 

（5）仅发出警告，系统并不会关机。

shutdown -k now 'This is just a warning message'

（6）立即关机并切断电源。

shutdown -P now
//或
poweroff

（7）恶作剧，仅发出警告，什么都不会发生。

shutdown +10 -k '10分钟后关机'

5.常见问题
（1）shutdown -h、shutdown -H和shutdown -P的区别?
shutdown -H是关机操作，停止系统运行，但并未关闭电源，shutdown -P是关闭电源操作。shutdown -h则根据系统的默认设置来选择是否关闭电源 。关闭电源会送出 ACPI 指令通知PSU（Power Supply Unit）电源。
（2）shutdown默认操作进入单用户维护模式。

//十分钟后进入单用户维护模式
shutdown +10

●declare/typeset 命令（builtin）：
1.功能简介
declare（别名 typeset）属 Shell 内建命令，用于申明 Shell 变量并设置变量属性，或查看已定义的 Shell 变量和函数。若不加上任何参数，只执行 declare/typeset 则会显示全部的 Shell 变量与函数（与执行 set 指令的效果相同）。
2.命令格式

declare [-aAfFgilrtux] [-p] [name[=value] ...]
typeset [-aAfFgilrtux] [-p] [name[=value] ...]

3.选项说明

-a
	申明数组变量
-A
	申明关联数组，可以使用字符串作为数组索引
-f
	仅显示已定义的函数
-F
	不显示函数定义
-g
	指定变量为全局变量，即使在函数内定义变量
-i
	声明整型变量
-l
	将变量值的大写字母变为小写
-r
	设置只读属性
-t
	设置变量跟踪属性，用于跟踪函数进行调试，对于变量没有特殊意义
-u
	变量值的小写字母变为大写
-x
	将指定的Shell变量换成环境变量
-p
	显示变量定义的方式和值
+
	取消变量属性，但是 +a 和 +r 无效，无法删除数组和只读属性，可以使用unset删除数组，但是 unset 不能删除只读变量

4.示例

（1）定义关联数组并访问。

declare -A assArray=([lucy]=beijing [yoona]=shanghai)

#读取关联数组全部内容
echo ${assArray[*]}
#或
echo ${assArray[@]}
#输出
beijing shanghai

#读取指定索引的数组值
echo ${assArray[lucy]}
#输出：
beijing

#列出数组索引列表
echo ${!assArray[*]}
#或
echo ${!assArray[@]}
#输出
yoona lucy

（2）定义只读变量。

declare -r name1="lvlv1"
#或
typeset -r name2="lvlv2"
#或
readonly name3="lvlv3"

Shell 规定，只读变量生命周期与当前 Shell 脚本进程相同，且不能消除只读属性和删除只读变量，除非 kill 当前 Shell 脚本进程。

（3）使用-p选项显示变量 name1 和 name2 的定义方式和当前值。

declare -p name1 name2
#输出
declare -r name1="lvlv1"
declare -r name2="lvlv2"

（4）使用-x选项将shell变量转换为临时环境变量，供当前Shell会话的其他shell进程使用，退出当前Shell会话则失效。

declare -x name1;

（5）显示所有 Shell 环境变量。

declare -x

（6）使用+x选项取消变量为环境变量。

delcare +x name1

（7）申明整型变量，赋值浮点型数值将报错。

declare -i integer=666

●sort 命令：
1.命令简介
以行为单位对文本文件的内容进行排序，将结果显示在标准输出，比较原则是从行首字符向后，依次按 ASCII 码值进行比较，最后按升序输出。如果 file 参数指定多个文件，那么 sort 命令将这些文件纵向连接起来，当作一个文件进行排序。
不加任何选项时，将对整行从第一个字符开始依次向后直到行尾按照 ASCII 码值做升序排序。
2.命令格式

sort [OPTION]... [FILE]...
sort [OPTION]... --files0-from=F

3.选项说明

注意，长选项的强制性参数对于短选项也是强制的。

-b, --ignore-leading-blanks
	忽略每行前面的空格字符
-c, --check, --check=diagnose-first
	只检查文件是否已排序，不进行排序
-C, --check=quiet, --check=silent
	类似于 -c，但不报告第一个乱序的行
-d, --dictionary-order
	按照字典序，只考虑字母、数字及空格字符，忽略其他字符
--files0-from=F
	从文件 F 中以 NUL 字符结尾的字符串作为输入文件名；如果 F 是 -，则从标准输入中读取文件名
-f, --ignore-case
	排序时，将小写字母视为大写字母
-i, --ignore-nonprinting
	排序时，只考虑可打印字符，忽略不可打印字符
-m, --merge
	合并多个已排序的文件
-n, --numeric-sort
	按数值大小排序
-o, --output=FILE
	将排序结果输出到指定文件
-r,--reverse
	逆向输出排序结果（降序排序）
-t, --field-separator=SEP
	指定排序时使用的分隔字符，sort命令默认字段分隔符为空格和Tab
-u, --unique
	相同的数据中，仅输出一行
-k,--key=POS1[,POS2]
	以第 POS1 栏到 POS2 栏排序，默认到最后一栏
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

    28
    29
    30
    31
    32

4.常用示例

（1）对 /etc/passwd 进行排序。

cat /etc/passwd | sort
adm:x:3:4:adm:/var/adm:/sbin/nologin
apache:x:48:48:Apache:/var/www:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

（2）/etc/passwd 内容以冒号:来分隔，以第三栏至行末尾栏来排序。

cat /etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin

（3）如果对 /etc/passwd，以第六个域的第 2 个字符到第 4 个字符进行升序排序，再基于第一个域进行反向排序。

cat /etc/passwd | sort -t ':' -k 6.2,6.4 -k 1,1r
sync:x:4:65534:sync:/bin:/bin/sync
proxy:x:13:13:proxy:/bin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
bin:x:3:3:sys:/dev:/bin/sh

可以看出，六个域的第 2 个字符到第 4 个字符是升序排序。六个域的第 2 个字符到第 4 个字符如果相同则分为一组，组内再按照第一个域进行降序排序。注意，-r 需要与第二个 -k 的 <POS1,POS2> 连写，否则对前面两个 -k 均有效。

●uniq 命令：
1.命令简介
用于去除有序文件中的重复行并将结果输出到标准输出。为了使uniq 起作用，所有的重复行必须是相邻的，所以 uniq 经常和 sort 合用。
2.命令格式

uniq [OPTION]... [INPUT [OUTPUT]]

3.选项说明

-c, --count
	显示行出现的次数
-d, --repeated
	仅显示重复出现的行，即出现次数 >=2 的行，且只打印一次
-D, --all-repeated[=delimit-method]
	仅显示重复的行，即出现次数 >=2 的行，且打印重复行的所有行。其中 delimit-method 表示对重复行集合的分隔方式，有三种取值，分别为none、prepend和separate。其中none表示不进行分隔，为默认选项，uniq -D等同于uniq --all-repeated=none；prepend表示在每一个重复行集合前面插入一个空行；separate表示在每个重复行集合间插入一个空行。
-f, --skip-fields=N
	忽略前N个字段。字段由空白字符（空格符、Tab）分隔。如果您的文档的行被编号，并且您希望比较行中除行号之外的所有内容。如果指定了选项 -f 1，那么下面相邻的两行：
	1 这是一条线
	2 这是一条线
	将被认为是相同的。如果没有指定 -f 1 选项，它们将被认为是不同的
-i, --ignore-case
	忽略大小写字符的不同
-s, --skip-chars=N
	跳过前面N个字符不比较
-u, --unique
	只显示唯一的行，即出现次数等于1的行
-w, --check-chars=N
	指定每行要比较的前N个字符数
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

先构造一个示例文件 testfile，其内容如下：

hello
world
friend
hello
world
hello

（1）对无序文件去重无效。直接删除未经排序的文件，将会发现没有任何行被删除：

uniq testfile  
hello
world
friend
hello
world
hello

（2）uniq 结合 sort 命令，对排序文件去重。

cat testfile | sort | uniq
friend
hello
world

（3）排序之后删除了重复行，同时在行首位置输出该行重复的次数。

#sort testfile | uniq -c
1 friend
3 hello
2 world

（4）仅显示存在重复的行，并在行首显示该行重复的次数:

#sort testfile | uniq -dc
3 hello
2 world

（5）仅显示不重复的行。

sort testfile | uniq -u
friend

（6）仅显示重复的行，且显示重复行的所有行。

sort testfile | uniq -D
hello
hello
hello
world
world

（7）uniq 默认是比较相邻行的所有内容来判断是否重复，我们可以通过选项-w或--check-chars=N指定比较前 N 个字符。比如我们有如下内容的文件 test.txt：

apple
application
api

打印前三个字符相同的行：

uniq -w3 -D test.txt
apple
application

●rz 命令与 sz 命令：
1.rz 命令
1.1 命令简介

rz 命令（Receive ZMODEM），使用 ZMODEM 协议，将本地文件批量上传到远程 Linux/Unix 服务器，注意不能上传文件夹。
当我们使用虚拟终端软件，如 XShell、SecureCRT 或 PuTTY 来连接远程服务器后，使用 rz 命令可以上传本地文件到远程服务器。输入 rz 回车后，会出现文件选择对话框，选择需要上传文件，一次可以指定多个文件，上传到服务器的路径为当前执行 rz 命令的目录。
此外，可以在虚拟终端软件设置上传时默认加载的本地路径和下载的路径。如SecureCRT软件 -> Options -> session options -> X/Y/Zmodem 下可以设置上传和下载的目录。
1.2 命令格式

rz [OPTIONS]

1.3 选项说明

-+, --append
	将文件内容追加到已存在的同名文件
-a, --ascii
	以文本方式传输
-b, --binary
	以二进制方式传输，推荐使用
--delay-startup N
	等待 N 秒
-e, --escape
	对所有控制字符转义，建议使用
-E, --rename
	已存在同名文件则重命名新上传的文件，以点和数字作为后缀
-p, --protect
	对 ZMODEM 协议有效，如果目标文件已存在则跳过
-q, --quiet
	安静执行，不输出提示信息
-v, --verbose
	输出传输过程中的提示信息
-y, --overwrite
	存在同名文件则替换
-X, --xmodem
	使用 XMODEM 协议
--ymodem
	使用 YMODEM 协议
-Z, --zmodem
	使用 ZMODEM 协议
--version
	显示版本信息
--h, --help
	显示帮助信息

以上为常见的命令选项，更多的选项说明，请参见rz的帮助手册。
1.4 常用示例

（1）以二进制，并对控制字符进行转义，替换已存在的同名文件。

rz -bye

2.sz 命令
2.1 命令简介
sz 命令（Send ZMODEM）通过 ZMODEM 协议，可将多个文件从远程服务器下载到本地。注意不能下载文件夹，如果下载文件夹，请先打包再下载。
2.2 命令格式

rz [OPTIONS] FILES

2.3 选项说明
命令选项基本与 rz 相同，请参考上文 rz 的命令选项或者 sz 的manual，或者运行命令sz -h查看。
2.4 常用示例
（1）下载多个文件

sz  file1 file2 file3

实测 sz 不用选项-bye，使用 XShell，也可以正确传输文本文件与二进制文件。
3.FAQ
（1）rz 命令和 sz 命令如何上传、下载文件夹？
很遗憾，据我所知，rz 命令和 sz 命令不能直接上传、下载文件夹，可先将文件夹打包，当作文件上传和下载。
（2）经常把 rz 和 sz 弄混淆，该如何正确记忆？
之所以将 rz 称之为上传工具，是因为我们以本地机器为中心。从远程服务器的角度，很容易理解rz为什么叫作 Receive ZMODEM，因为服务器需要从本地机器接收文件。sz命令则表示从服务器发送文件到本地，也叫下载文件。

●tcpdump 命令：
1.命令简介
tcpdump 是一款类 Unix/Linux 环境下的抓包工具，允许用户截获和显示发送或收到的网络数据包。tcpdump 是一个在 BSD 许可证下发布的自由软件。
2.命令格式

tcpdump [ -AbdDefhlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ]
        [ -C file_size ] [ -F file ] [ -G rotate_seconds ]
        [ -i interface ] [ -m module ] [ -M secret ]
        [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]
        [ -W filecount ]
        [ -E spi@ipaddr algo:secret,...  ]
        [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ]
        [ expression ]

3.选项说明

-A
	以 ASCII 码方式显示每一个数据包(不会显示数据包中链路层头部信息)。在抓取包含网页数据的数据包时，可方便查看数据
-b
	用 ASDOT 符号而不是 ASPLAIN 符号在 BGP 数据包中打印 AS 号
-B, --buffer-size=BUFFER_SIZE
	设置操作系统捕捉缓冲大小，单位 KB
-c [数据包数目]
	收到指定的数据包数目后，就停止进行捕获操作
-C FILE_SIZE
	与 -w FILE 选项配合使用。该选项使得 tcpdump 在把原始数据包直接保存到文件中之前，检查此文件大小是否超过 file-size。如果超过了，将关闭此文件，另创一个文件继续保存原始数据包。新创建的文件名与 -w 选项指定的文件名一致, 但文件名后多了一个数字，该数字会从1开始随着新创建文件的增多而增加。 file-size的单位是百万字节(nt: 这里指1,000,000个字节,并非1,048,576个字节, 后者是以1024字节为1k, 1024k字节为1M计算所得, 即1M=1024*1024 ＝1,048,576)
-d
	把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出
-dd
	把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出
-ddd
	把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出
-D, --list-interfaces
	打印系统中所有 tcpdump 可以在其上进行抓包的网络接口。每一个接口会打印出数字编号, 相应的接口名字, 以及一个可能的网络接口描述。其中网络接口名字和数字编号可以用在tcpdump的-i [flag]选项(nt:把名字或数字代替flag), 来指定要在其上抓包的网络接口。此选项在不支持接口列表命令的系统上很有用(nt: 比如, Windows 系统, 或缺乏 ifconfig -a 的UNIX系统); 接口的数字编号在windows 2000 或其后的系统中很有用, 因为这些系统上的接口名字比较复杂, 而不易使用。如果tcpdump编译时所依赖的libpcap库太老,-D 选项不会被支持, 因为其中缺乏 pcap_findalldevs()函数
-e
	每行打印输出中将包括数据包的数据链路层头部信息 
-f
	显示外部的IPv4地址时(nt:foreign IPv4 addresses, 可理解为非本机ip地址), 采用数字方式而不是名字。此选项是用来对付Sun公司的NIS服务器的缺陷(nt: NIS, 网络信息服务, tcpdump 显示外部地址的名字时会用到它提供的名称服务): 此NIS服务器在查询非本地地址名字时，常常会陷入无尽的查询循环)。由于对外部(foreign)IPv4地址的测试需要用到本地网络接口(nt: tcpdump 抓包时用到的接口)及其IPv4 地址和网络掩码. 如果此地址或网络掩码不可用, 或者此接口根本就没有设置相应网络地址和网络掩码(nt: linux 下的 'any' 网络接口就不需要设置地址和掩码, 不过此'any'接口可以收到系统中所有接口的数据包), 该选项不能正常工作。
-F FILE
	使用file文件作为过滤条件表达式的输入, 此时命令行上的输入将被忽略
-G [rotate_seconds]
	类似于-C [file_size]命令选项，-C按文件大小来新建文件存储数据包，-G则根据指定的时间周期，将监听到的数据包写入新的文件，新建的文件名由-w选项指定，并且文件名后接有时间串，时间串的格式由strftime(3)指定。如果没有指定时间串的格式，新的文件将覆盖旧的文件。如果与 -C 选项同时使用的话，文件名称格式将是 file<count>。
-h，--help
	打印tcpdump的帮助信息和libpcap的版本信息。（nt：libpcap是unix/linux平台下的网络数据包捕获函数包）
--version
	打印 tcpdump 和 libpcap 的 version
-i [interface],--interface=interface
	指定 tcpdump 需要监听的接口。如果没有指定，tcpdump 会从系统接口列表中搜寻编号最小的已配置好的接口(不包括 loopback 接口)。一但找到第一个符合条件的接口，搜寻马上结束。
	在采用2.2版本或之后版本内核的Linux操作系统上, 'any'这个虚拟网络接口可被用来接收所有网络接口上的数据包(nt: 这会包括目的是该网络接口的,也包括目的不是该网络接口的)。需要注意的是如果真实网络接口不能工作在'混杂模式'(promiscuous)下，则无法在'any'这个虚拟网络接口上抓取其数据包。
	如果 -D 标志被指定，tcpdump会打印系统中的接口编号，而该编号就可用于此处的 interface 参数
-l
	对标准输出进行行缓冲(nt: 使标准输出设备遇到一个换行符就马上把这行的内容打印出来)
-L
	列出指定网络接口所支持的数据链路层的类型后退出.(nt: 指定接口通过-i 来指定)
-n
	不把主机的网络地址转换成名字
-m MODULE
	通过 module 指定的 file 装载 SMI 和 MIB 模块(nt: SMI，Structure of Management Information, 管理信息结构；MIB, Management Information Base, 管理信息库。可理解为,这两者用于SNMP(Simple Network Management Protoco)协议数据包的抓取。具体SNMP 的工作原理未知, 另需补充)。
	此选项可多次使用，从而为tcpdump装载不同的MIB模块
-M SECRET
	如果 TCP 数据包(TCP segments)有TCP-MD5选项(在RFC 2385有相关描述), 则为其摘要的验证指定一个公共的密钥 secret
-n
	不将地址(比如主机地址、端口号等)转换到对应的名字
-N
	不要打印主机名的域名资格，比如打印 nic 而不是 nic.ddn.mil
-O，--no-optimize
	不启用进行包匹配时所用的优化代码. 当怀疑某些bug是由优化代码引起的, 此选项将很有用
-p，--no-promiscuous-mode
	把网络接口设置为非'混杂'模式。但必须注意，在特殊情况下此网络接口还是会以'混杂'模式来工作；从而 -p 的设与不设，不能当做以下选项的代名词：'ether host {local-hw-add}'或'ether broadcast'(nt: 前者表示只匹配以太网地址为host的包, 后者表示匹配以太网地址为广播地址的数据包
-q
	快速打印输出，即打印很少的协议相关信息，从而输出行都比较简短
-r [file]
	从指定的文件读取数据包，如果 file 为 - 符号, 则tcpdump会从标准输入中读取包数据
-R
	设定tcpdump对ESP/AH数据包的解析按照RFC1825而不是RFC1829(nt:AH：认证头，ESP：安全负载封装，这两者会用在IP包的安全传输机制中)。如果此选项被设置,tcpdump将不会打印出'禁止中继'域(nt: relay prevention field)。另外，由于ESP/AH规范中没有规定ESP/AH数据包必须拥有协议版本号域，所以tcpdump不能从收到的ESP/AH数据包中推导出协议版本号
-s, --snapshot-length=SNAPLEN
	设置 tcpdump 的数据包抓取长度为 SNAPLEN，而不是默认的 262144 字节。如果产生包截短这种情况, tcpdump的相应打印输出行中会出现''[|proto]''的标志（proto 实际会显示为被截短的数据包的相关协议层次). 需要注意的是, 采用长的抓取长度(nt: snaplen比较大), 会增加包的处理时间, 并且会减少tcpdump 可缓存的数据包的数量， 从而会导致数据包的丢失. 所以, 在能抓取我们想要的包的前提下, 抓取长度越小越好。把snaplen 设置为0意味着让tcpdump自动选择合适的长度来抓取数据包
-S，--absolute-tcp-sequence-numbers
	打印 TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号.(nt: 相对顺序号可理解为, 相对第一个TCP 包顺序号的差距,比如, 接受方收到第一个数据包的绝对顺序号为232323, 对于后来接收到的第2个,第3个数据包, tcpdump会打印其序列号为1, 2分别表示与第一个数据包的差距为1 和 2. 而如果此时-S 选项被设置, 对于后来接收到的第2个, 第3个数据包会打印出其绝对顺序号:232324, 232325)
-t
	在每行输出中不打印时间戳
-tt
	不对每行输出的时间进行格式处理(nt: 这种格式一眼可能看不出其含义, 如时间戳打印成1261798315)
-ttt
	tcpdump 输出时, 每两行打印之间会延迟一个段时间，单位毫秒
-tttt
	在每行打印的时间戳之前添加日期的打印
-ttttt
	设置每一行输出时相对于第一行的时间间隔，单位毫秒
-T TYPE
	强制 tcpdump 按 type 指定的协议所描述的包结构来分析收到的数据包。目前已知的type可取的协议为：
	（1）aodv(Ad-hoc On-demand Distance Vector protocol, 按需距离向量路由协议, 在Ad hoc(点对点模式)网络中使用)；
	（2）cnfp(Cisco  NetFlow  protocol)；
	（3）rpc(Remote Procedure Call)；
	（4）rtp(Real-Time Applications protocol)；
	（5）rtcp(Real-Time Applications con-trol protocol)；
	（6）snmp(Simple Network Management Protocol)；
	（7）tftp(Trivial File Transfer Protocol, 碎文件协议)；
	（8）vat(Visual Audio Tool，可用于在internet上进行电视电话会议的应用层协议), 以及wb(distributed White Board，可用于网络会议的应用层协议)
-u
	打印出未加密的 NFS 句柄（nt：handle可理解为NFS中使用的文件句柄, 这将包括文件夹和文件夹中的文件)
-U
	使得当 tcpdump 在使用 -w 选项时，其文件写入与包的保存同步。(nt：即当每个数据包被保存时, 它将及时被写入文件中,而不是等文件的输出缓冲已满时才真正写入此文件)。-U标志在老版本的libpcap库(nt：tcpdump所依赖的报文捕获库)上不起作用, 因为其中缺乏pcap_cump_flush()函数
-v
	产生详细的输出。比如包的生存时间、标识、总长度以及IP包的一些选项。这也会打开一些附加的包完整性检测， 比如对IP或ICMP包头部的校验和
-vv
	产生比-v更详细的输出。比如NFS（Network File System）回应包中的附加域将会被打印，SMB（Server Message Block）数据包也会被完全解码
-vvv
	更详细的输出。例如，telent时所使用的SB,SE选项将会被打印, 如果telnet同时使用-X图形界面选项，其相应的图形选项将会以16进制的方式打印出。
-w FILE
	把包数据直接写入文件而不进行分析和打印输出，这些包数据可在随后通过-r选项来重新读入并进行分析和打印
-W FILECOUNT
	此选项与 -C 选项配合使用，这将限制可打开的文件数目, 并且当文件数据超过这里设置的限制时, 依次循环替代之前的文件, 这相当于一个拥有filecount 个文件的文件缓冲池。同时,该选项会使得每个文件名的开头会出现足够多并用来占位的0，可以方便这些文件被正确的排序

-x：打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部)，总共打印的数据大小不会超过整个数据包的大小与snaplen 中的最小值。必须要注意的是, 如果高层协议数据没有snaplen这么长，并且数据链路层(比如,Ethernet层)有填充数据, 则这些填充数据也会被打印

-xx：打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部

-X：当分析和打印时, tcpdump会打印每个包的头部数据，同时会以16进制和ASCII码形式打印出每个包的数据(但不包括链路层的头部)。这对于分析一些新协议的数据包很方便

-XX：当分析和打印时,tcpdump会打印每个包的头部数据，同时会以16进制和ASCII码形式打印出每个包的数据, 其中包括数据链路层的头部.这对于分析一些新协议的数据包很方便

-y [datalinktype]，--linktype=datalinktype：设置tcpdump只捕获数据链路层协议类型是datalinktype的数据包

-z [postrotate-command]：与-C或-G联用，当每一个文件被关闭时执行命令postrotate-command。比如，-z gzip或-z bzip2将对每一个保存的文件进行压缩
-Z , --relinquish-privileges=USER
	使 tcpdump 放弃自己的超级权限（如果以 root 用户启动 tcpdump，tcpdump 将会有超级用户权限)，并把当前 tcpdump 的用户 ID 设置为 USER，组 ID 设置为 USER 属组的 ID
expression
	条件表达式用于选择捕获符合条件的数据包，无 expression，网络上任何两台主机间的所有数据包都将被截获

4.常用示例
4.1 监视指定主机的数据包
（1）打印所有到达或从主机 sunrise 发出的数据包，host 可以是 IP 地址或主机名。

tcpdump host sunrise

（2）打印主机 A 与 B 或 C 之间来往的所有数据包。

tcpdump host A and \( B or C \)

（3）打印 ace 与任何其他主机之间通信的 IP 数据包，但不包括与 helios 之间的数据包.

tcpdump ip host ace and not helios

4.2 监视指定网络的数据包

（1）打印本地主机与 Berkeley 网络上的主机之间的所有通信数据包。

tcpdump net ucb-ether

（2）打印所有通过网关 snup 的 ftp 数据包。注意，表达式被单引号括起来了，这可以防止 Shell 对其中的括号进行错误解析。

tcpdump 'gateway snup and (port ftp or ftp-data)'

（3）打印不是本地网络的数据包。

tcpdump ip and not net localnet

4.3 监视指定协议的数据包

（1）打印 TCP 会话中的的开始和结束数据包，并且数据包的源或目的不是本地网络上的主机。（nt：localnet，实际使用时要真正替换成本地网络的名字）

tcpdump 'tcp[tcpflags] & (tcp-syn|tcp-fin) != 0 and not src and dst net localnet'

（2）打印长度超过 576 字节，并且网关地址是 snup 的 IP 数据包。

tcpdump 'gateway snup and ip[2:2] > 576'

ip[2:2] 表示整个 IP 数据包的长度。

（3）打印除’echo request’或者’echo reply’类型以外的 ICMP 数据包（比如，需要打印所有非 ping 程序产生的数据包时可用到此表达式 。（nt: ‘echo reuqest’ 与 ‘echo reply’ 这两种类型的 ICMP 数据包通常由 ping 程序产生）

tcpdump 'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply'

4.4 监视指定主机和端口的数据包

（1）抓取主机 100.94.138.110 所有经由接口 eth1 接收的数据包，且端口号是20700。

tcpdump -i eth1 -lnXps0 dst 100.94.138.110 and dst port 20700 -c 10

命令选项说明：lnXps0 请参照上文的命令选项详解，-c 10 表示只捕捉 10 个数据包。

●split 命令：
1.命令简介
split 命令用于将一个大文件分割成较小的文件，默认每 1000 行分割成一个小文件。有时需要将文件分割成更小的片段，比如为提高可读性、生成日志等。
2.命令格式

split [OPTION]... [FILE [PREFIX]]

将文件 FILE 切分输出到 PREFIXaa、PREFIXab，以此类推。默认按 1000 行为单位进行切分，前缀 PREFIX 默认为 x。
如果没有文件，或者当文件是 -，从标准输入读取。
3.选项说明

注意，长选项的强制性参数对于短选项也是强制的。

-a, --suffix-length=N
	指定分割后文件名的后缀字符数目（后缀长度），默认是 2
-b, --bytes=SIZE
	指定每一子输出文件的大小，单位 byte
-C, --line-bytes=SIZE
	子文件中，单行的最大字节数
-d
	使用数字作为后缀，从 0 开始
--numeric-suffixes[=FROM]
	作用同-d，但可以设置起始数字
-x
	使用从 0 开始的十六进制后缀，而不是字母
-, -l, --lines=NUMBER
	指定多少行分割成一个小文件
-t, --separator=SEP
	使用 SEP 替代换行符作为记录分隔符
--verbose
	分割文件时输出冗余信息
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）将 /etc/passwd 每十行分割成一个小文件，小文件名的前缀是 lvlv。

split -10 /etc/passwd lvlv

// 使用 ls 查看分割出来的小文件
ls
lvlvaa  lvlvab  lvlvac  lvlvad  lvlvae

（2）按 10 行分割文件，每个文件的后缀从 000 开始。

split -a3 -d -10 /etc/passwd lvlv

●col 命令：
1.命令简介
col（control）命令是一个标准输入文本过滤器，它从标准输入读取内容，过滤掉控制字符反向换行符（RLF-Reverse Line Feed）和半反向换行符（HRLF-Halt RLF）后输出到标准输出。还可以将空白符用等价制表符（Tab）或空格（Space）来替换。
在许多 Linux 说明文件里，包含控制字符。当我们运用 Shell 特殊字符 > 和 >> 把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col 命令则能有效滤除这些控制字符。
2.命令格式

col [OPTIONS]

3.选项说明

-b, --no-backspaces
	不输出任何退格符，只打印写入每个列位置的最后一个字符
-f, --fine
	允许正向半换行符（half-forward line feeds）。通常，处于半行分界线上的字符打印在下一行
-h, --tabs
	将多个空格转换为Tab，一般 4 个 空格转为 1 个 Tab
-l, --lines NUMBER
	设置缓冲行为 NUMBER，默认为 128
-p, --pass
	不转换未识别的控制符
-x, --spaces
	将 Tab 转为多个空格，一般 1 一个 Tab 转为 4 个空格
-H, --help
	显示帮助信息并退出
-V, --version
	显示版本信息并退出

4.常用示例

（1）将 Tab 替换为空格，一般 1 个 Tab 转为 4 个空格。

echo -e "123\t456" | col -x

（2）将空格替换为 Tab，一般 4 个 空格转为 1 个 Tab。

echo -e "123    456" | col -h

（3）将帮助文档内的控制符删除。以 col 命令的 manual 为例。

man col | col -b > newFile

5.相关疑问

RLF 字符(reverse line feed)是反向换行符，HRLF字符（half-reverse line feed）是半反向换行符。百度知道中有网友的回答，但是我还是不太清楚这两个字符的作用和应用场景，请知道的大牛评论告知，万分感谢。

●wc 命令：
1.命令简介
wc（word count）命令用于统计文件字节、字符、单词与行的数量。
2.命令格式

wc [OPTION]... [FILE]...
wc [OPTION]... --files0-from=F

3.选项说明

-c, --bytes
	仅显示字节数
-m, --chars
	仅显示字符数
-l, --lines
	仅显示行数
--files0-from=F
	从文件 F 中获取以 NULL 字符结尾的文件名作为输入，如果 F 等于连字符 -，则从标准输入读取
-L, --max-line-length
	显示文件中最长行的字符数
-w, --words
	显示单词数，单词以空格分隔
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.示例
（1）使用 wc 统计 /etc/passwd 行数、单词数和字节数。

wc /etc/passwd
40   45 1719 /etc/passwd

40 是行数，45 是单词数，1719 是字节数。
（2）wc 的命令比较简单，每个参数使用如下：

# 统计行数，在统计记录数时，很常用
wc -l /etc/passwd
40 /etc/passwd       # 表示系统有40个账户

# 统计单词出现次数
wc -w /etc/passwd
45 /etc/passwd

# 统计文件的字节数
wc -c /etc/passwd
1719

# 统计文件的字符数，如果是 ASCII、Latin-1 等单字节编码的字符，字符数等于字节数
wc -m /etc/passwd
1719

（3）从文件读取输入文件名。如果有多个文件名，并且希望 wc 从一个文件中读取它们，那么使用 -files0-from 选项。这里将文件名称必须以 NULL 字符结束写在文件fileNames.txt 中。

wc --files0-from=fileNames.txt

在 vim 中输入 NULL 字符，可以通过 digraph 输入，具体操作步骤是：在输入模式按一下Ctrl+k，然后输入NU。关于 digraph 和其它输入方式具体参见 Vim 中读写特殊字符。

●cut 命令：
1.命令简介
cut 是一个选取命令，以行为单位，选择性输出符合条件的内容到标准输出。
cut 命令主要用途有两个，其一是用来显示文件的内容，它依次读取所指明的文件列表，将它们的内容输出到标准输出上；其二是连接两个或多个文件，如 cut f1 f2 > f3 将把文件 f1 和 f2 的内容合并起来，然后通过输出重定向符 > 的作用，将它们放入文件 f3 中。
2.命令格式

cut OPTION... [FILE]...

在没有提供文件或文件是 - 的情况下，cut 从标准输入读取内容。
3.选项说明

注意，长选项的强制性参数对于短选项也是强制的。

-b, --bytes=LIST
	设置输出的字节数或范围
-c, --characters=LIST
	设置输出的字符数或范围
-d, --delimiter=DELIM
	指定列（或字段）的分隔字符。默认分隔符是制表符 Tab。只能和 -f 选项一起使用
-f, --fields=LIST
	设置输出字段，默认字段分隔符是空格。-f 会打印不包含分隔符的行，除非指定了 -s 选项
-n
	与 -b 选项连用，不分割多字节字符
--complement
	反向选择字节、字符或字段
-s, --only-delimited
	若行没有分隔符，则不显示该行。此选项只能和 -f 选项一起使用
--output-delimiter=STRING
	使用字符串作为输出分隔符，默认是输入分隔符
-z, --zero-terminated
	行分隔符是 NUL，而不是 LF
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

当使用 -b、-c 或 -f 选项时，LIST 由一个范围（range）或逗号隔开的多个范围组成。范围的表示形式有：

N
    第 N 个字节、字符或字段。N 从 1 开始计数 
N-
    从第 N 个字节、字符或字段直至行尾 
N-M
	从第 N 到第 M（包括 M）个字节、字符或字段 
-M
	从第 1 到第 M（并包 M）个字节、字符或字段

4.常用示例

首先给出用于测试的本文件 testfile，其内容如下：

hello world
i am lvlv
i like linux

（1）以字符为单位输出指定范围的字符。使用 cut 命令选择第 3 到第 5 个字符输出：

cut -c 3-5 testfile
llo
am 
lik

如果没有指定结束字符的位置，即cut -c 3- testfile，则输出第三个字符到最后一个字符。同样我们可以使用字节为单位来进行，如果文本文件是单字节编码的字符，那么cut -b 3-5 testfile等同于cut -c 3-5 testfile。

（2）以字段为单位输出指定字段。输出第二列和第三列的内容：

cut -d " " -f 1  testfile
world
am lvlv
like linux

注意，因为第一行没有第三列，所以输出为空。

（3）选项提取指定字段之外的列。输出第一列之外的内容：

cut -d " " -f 1 --complement testfile
world
am lvlv
like linux

●df 命令：
1.命令简介
df（Disk Free）命令用于查看 Linux 文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，以及剩余空间等信息，默认显示单位为 KB。
本文描述的是 GNU 版的 df，其它版本（如 POSIX 版）的实现会有所不同。
2.命令格式

df [OPTION]... [FILE]...

参数 FILE 表示文件系统上的文件。如果给定参数 FILE，则 df 分别展示各个文件所在文件系统的信息，如果没有给定 FILE，则默认输出所有已挂载的文件系统的载信息。
3.选项说明

-a, --all
	显示所有的文件系统，包括虚拟文件系统
-B, --block-size=SIZE
	使用指定的块大小
-h, --human-readable
	以易读的方式显示磁盘空间已用与未用的大小
--direct
	显示文件的统计信息，而不是挂载点
--total
	显示所有文件系统总的使用情况
-H, --si
	使用 1000 而非 1024 作为换算单位
-i, --inodes
	显示索引节点 inode 信息，而非磁盘块的使用情况
-k, --local
	同 --block-size=1K，即将块大小设置为 1KB
-l, --local
	只输出本地文件系统信息
-P
	输出格式为 POSIX
-t , --type=TYPE
	显示指定的文件系统
-T, --print-type
	显示文件系统类型
-x, --exclude-type=TYPE
	显示指定的文件系统之外的文件系统
--no-sync
	不进行磁盘同步，默认选项
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

5.常用示例
（1）以易读方式显示文件系统空间使用情况，并输出文件系统类型。

df -hT
Filesystem    Type    Size  Used Avail Use% Mounted on
/dev/mapper/vg_mic-lv_root
              ext4     50G   16G   32G  33% /
tmpfs        tmpfs     16G     0   16G   0% /dev/shm
/dev/sda1     ext4    485M   38M  422M   9% /boot
/dev/mapper/vg_mic-lv_home
              ext4    210G  197G  2.7G  99% /home

上面的示例输出信息表示的意思分别是：
第一列：filesystem代表文件系统在哪个分区，所以列出设备名称。其中/dev/mapper/vg_mic-lv_root这行的意思是，你有一个VG (volume group，卷组)叫作vg_mic, vg_mic里面有一个LV(logical volume，逻辑卷)叫作lv_root。其实这个/dev/mapper/vg_mic-lv_root是一个连接文件，连接到/dev/dm-0的，可以用ll /dev/mapper/vg_mic-lv_root查看。实际上，可以将vg_mic-lv_root看作一个分区来对待就可以了。如果想查看实际的物理分区，可以使用命令pvdisplay [ 1 , 2 ] ^{[1,2]} [1,2]。

第二列：Type代表文件系统类型。比如第三行的tmpfs是一种基于内存的文件系统，类似于ramdisk。tmpfs可以使用RAM，也可以使用swap分区来存储文件，提高文件的读写读写速度。再如第三行的/dev/sda1分区的文件系统是ext4。

第三列：Size 代表分区的大小。

第四列：Used表示已经使用的大小。

第五列：Avail表示可用的大小。

第六列：Use%表示以百分比显示已经使用的比例。

第七列：Mounted on表示磁盘分区挂载的目录，即挂载点。

这里列一下Linux系统中磁盘与其它外设的命名规则，以及磁盘分区的命名规则。常见的设备与其在Linux中的文件名如下表：
设备	文件名
IDE硬盘	/dev/hd[a-d]
SCSI/SATA/USB硬盘与U盘	/dev/sd[a-p]
软驱	/dev/fd[0-1]
打印机	25针：/dev/lp[]0-2
USB:/dev/usb/lp[0-15]
鼠标	USB：/dev/usb/mouse[0-15]
ps2:/dev/psaux
当前CD ROM/DVD ROM	cdrom
当前鼠标	/dev/mouse
磁带机	IDE：/dev/ht0
SCSI:/dev/st0

需要注意的是，每个磁盘驱动器的磁盘分区（partition）不同时，磁盘文件名还会改变。此外，磁带机的文件名，在某些不同的 Linux 发行版本中可能不一样。

IDE磁盘，一般可以接4个，磁盘名称分别是hda，hdb，hdc和hdd。以hda为例，如果分为四个分区，则四个分区的名称分别为hda1，hda2，hda3和hda4，其他三个磁盘的分区名称以此类推。

一个 IDE 磁盘、SATA磁盘和SCSI 磁盘主分区与扩展分区加在一起最多4个，扩展分区最多只有一个，扩展分区中再开辟逻辑分区。

IDE 磁盘最多可以分63个分区，59个逻辑分区。
SATA硬盘最多15个分区，11个逻辑分区。
SCSI硬盘最多16个分区，12个逻辑分区。

SATA 硬盘的分区名称与IDE磁盘的分区名称类似，以第一块 SATA 磁盘 sda 为例，那么各个分区的名称分别是 sda1，sda2，sda3…，以此类推。可见，IDE 磁盘与 SATA 磁盘的分区号均是从 1 开始的 [ 3 ] ^{[3]} [3]。

SCSI 硬盘的分区名称与 SATA 硬盘分区名称相同。

（2） 查看全部文件系统。

df -a
Filesystem     1K-blocks      Used Available Use% Mounted on
rootfs                 -         -         -    - /
/dev/vda1       30830592   9330332  19911116  32% /
devtmpfs         7569484         0   7569484   0% /dev
sysfs                  0         0         0    - /sys
proc                   0         0         0    - /proc
securityfs             0         0         0    - /sys/kernel/security
tmpfs            7570224   1232632   6337592  17% /dev/shm
...

系统里面存在很多特殊的文件系统，这些比较特殊的文件系统几乎都是在内存当中（如 /proc 挂载点），所以，这些特殊文件系统都不会占据硬盘空间。

●umask 命令（builtin）：
1.命令简介
umask 为 Shell 内建命令，用于设置创建文件时的权限掩码。
权限掩码由 3 个八进制数字组成，将 777（八进制）减掉权限掩码后，即可得到新建文件的默认权限。它与 chmod 的效果刚好相反。
2.命令格式

umask [-p] [-S] [MODE]

后不跟任何选项与参数单独执行 umask，则以八进制格式显示当前权限掩码。
3.选项说明

-p [MODE]
	以八进制数字形式显示或设置权限掩码。当 MODE 没有提供时，显示当前权限掩码。为默认选项
-S [MODE]
	以字符形式显示或设置新建文件的默认权限。当 MODE 没有提供时，显示新建文件的默认权限

注意：出于安全的考虑，文件的执行权限不能通过权限掩码来设置，必须手工修改。
4.常用示例

（1）显示当前权限掩码。

umask
0022

（2）以字符形式显示新建文件的默认权限。

umask -S
u=rwx,g=rx,o=rx

等于八进制权限位 0777 减去掩码 0022，即 0755，以字符形式显示为 u=rwx,g=rx,o=rx。

（3）设置权限掩码并查看。

#设置权限掩码
umask 044

#查看权限掩码
umask
044

●chattr 与 lsattr 命令：
1.简介
chattr 与 lsattr 分别用于改变和显示文件属性，与 chmod 命令相比，chmod 只改变文件的读写、执行权限，更底层的属性控制是由 chattr 来改变。
2.chattr 命令
2.1 命令格式

chattr [ -RVf ] [ -v version ] [ mode ] files...

2.2 参数说明

-R
	递归地改变指定目录下文件的属性。此选项忽略符号链接；
-V
	显示命令执行的详细信息；
-f
	大部分错误信息不输出；
-v
	设置文件版本号；
+
	在原有参数设定基础上，追加参数；
-
	在原有参数设定基础上，移除参数；
=
	更新指定参数设定

最关键的是 [mode] 部分，[mode] 部分由 + - = 和字符 [acdeijstuADST] 组合而成，这部分是用来控制文件的属性。

chattr 可以改变的文件系统属性有：
属性	含义
a	append only，只允许向文件追加数据，不允许删除和修改文件内容。如果目录有具有这个属性，系统将只允许在目录下简历和修改文件，不允许删除任何文件。只有root才能设置该属性
c	compress，自动将文件压缩，在读取时自动解压缩
d	No dump，在进行文件系统备份时，dump指令忽略此文件
e	extent format,在ext文件系统中，表示该文件使用区段(extents)映射磁盘上的块
i	immutable，不允许对文件进行任何的修改。对于目录而言，只能修改目录之下的文件，不允许建立和删除文件。只有root能设置此属性
j	journal，设定此参数使得当通过mount参数：data=ordered 或者 data=writeback 挂 载的文件系统，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效
s	secure deletion，系统在删除文件时，使用0填充文件所在的区域
t	no tail-merging,文件拥有t属性时，与其它文件合并时末端不会存在局部块碎片
u	undeletable，与s相反，删除文件时，文件内容其实还存在磁盘中，以便以后能够恢复删除的文件
A	Atime，不能修改文件的最后访问时间
D	如果一个目录设置了D属性，任何改变将同步到磁盘；这等价于mount命令中的dirsync选项，同步目录
S	Sync，一旦应用程序对文件执行了写操作，则立刻将改动同步到磁盘
T	目录设置T属性，Orlov块分配器将该目录视为目录层次结构的顶部，提示块分配器该目录下的子目录是无关的，将被分散的分配

注意：
chattr 指令所修改的文件属性和 chmod 指令修改的文件属性是两个不同层次的属性，前者是底层文件系统来设定的，而 chmod 指令则是站在用户使用的角度来设定的。
2.3 常见示例

（1）用 chattr 命令防止系统中某个关键文件被修改：

chattr +i /etc/resolv.conf

然后用mv /etc/resolv.conf等命令作用于该文件，都会得到 Operation not permitted 的结果。vim 编辑该文件时会提示W10: Warning: Changing a readonly file错误。要想修改此文件需要把 i 属性去掉：

chattr -i /etc/resolv.conf

（2）让某个文件只能追加内容，不能删除或修改，一些日志文件适用于这种操作。

chattr +a /data1/user_act.log

3.lsattr 命令
3.1 命令格式

lsattr [ -RVadv ] [ files... ]

3.2 命令选项

-R
	递归列出子目录及其文件的属性
-V
	显示lsattr版本信息
-a
	显示所有隐藏的文件属性
-d
	如果是目录，则只显示目录本身的属性，而非目录内的文件名
-v
	显示文件版本号

3.3 使用示例

[root@add_friend_protect ~/dablelv]# lsattr -vV
lsattr 1.41.12 (17-May-2010)
18446744072009275534 --------------- ./demo
18446744072009481631 --------------- ./inputFile.txt
18446744072009374382 -----a--------- ./input_file.txt

第一行为 lsattr 版本信息，第一列为文件版本号，最后一个文件 input_file.txt 属性 a，表示只追加属性。

●su 与 sudo 命令：
1.su 命令
1.1 命令简介
su 用于临时切换身份到另一个指定的用户，未指定用户名默认为 root。使用 su 切换用户身份后，默认情况下不改变当前工作目录，但会改变 HOME、SHELL、USER、LOGNAME 等 Shell 的环境变量。
1.2 命令格式

su [OPTIONS] [-] [USER [ARG...]]

1.3 选项说明

-c, --command=CMD
	执行完指定命令后，立即恢复原来的用户身份
--session-command=CMD
	等同于选项 -c，但不创建新会话
-, -l, --login
	切换用户身份时启动一个新的 Shell。此选项可同时改变工作目录和 HOME、SHELL、USER、LOGNAME 等环境变量，也包括环境变量 PATH
-f, --fast
	不必读启动文件（如 csh.cshrc 等），仅用于 csh 或 tcsh 两种 Shell
-m, --preserve-environment
	保留原用户的 Shell 环境变量
-p
	同 -m
-s, --shell=SHELL
	指定使用的 Shell
-h, --help
	显示帮助信息并退出
-v, --version
	显示版本信息并退出

2.sudo 命令
2.1 命令简介

sudo 可以用指定的用户身份执行指定的指令，而无需输入指定用户的密码，只需要输入当前用户的密码。未指定用户名默认为 root。
2.2 命令格式

sudo [OPTIONS] [CMD]

没有选项与命令单独执行 sudo，将列出 sudo 简要使用方法。
2.3 选项说明

-A
	使用辅助程序（可能是图形化界面的程序）读取用户的密码并将密码输出到标准输出。如果设置了环境变量 SUDO_ASKPASS，它会指定辅助程序的路径，否则，由配置文件 /etc/sudo.conf 的 askpass 选项来指定辅助程序的路径。如果没有可用的辅助程序，sudo 将错误退出
-b
	选项 -b（background）把 sudo 所要运行的命令放到后台运行
-E
	选项 -E（preserve Environment）向安全策略指示用户希望保存他们现有的环境变量。如果指定了 -E 选项，且用户没有保留环境变量的权限，则安全策略可能返回错误
-H
	选项 -H（Home）将 HOME 环境变量设置为目标用户的家目录，目标用户默认为 root
-h
	选项 -h（help）显示帮助信息并退出
-i [CMD]
	选项 -i（simulate initial login）将模拟初始登录，即启动目标用户在 /etc/passwd 中配置的 Shell，相关的资源文件将被读取并执行，比如 ~/.profile 和 ~/.login。如果后跟命令 CMD，则 CMD 将被传递给 Shell 并被执行
-K
	选项 -K（sure Kill）类似于 -k，它只用于删除了用户的缓存凭据，不能与命令或其他选项一起使用
-k [CMD]
	单独使用 -k（kill）选项时，使密码缓存失效，也就是下次执行 sudo 时便需要输入密码。如果后跟命令，表示忽略缓存密码，需要用户重新输入密码 ，新输入的密码不会更新密码缓存
-l[l] [CMD]
	如果选项 -l（list）后不跟命令，则列出 sudo 允许当前用户（或使用 -U 指定的其他用户）执行的指令和无法执行的指令。如果指定了命令并被安全策略所允许，则将显示该命令绝对路径以及命令参数。如果指定了命令不被允许，sudo 以状态码 1 退出。如果使用 -ll 或多次指定 -l 选项，则使用长格式输出
-n
	选项 -n（non-interactive）表示以非交互模式执行 sudo，阻止 sudo 向用户询问密码。如果执行命令时需要密码，则 sudo 将报错误信息并退出
-p PROMPT
	改变询问密码的提示符号
-s [CMD]
	选项 -s（shell）执行环境变量 SHELL 表示的 Shell，如果 SHELL 没有值，则执行目标用户在配置文件 /etc/passwd 中配置的 Shell。如果选项后跟命令，则传递给 Shell 执行，如果没有指定命令，则执行交互式 Shell
-U USER
	选项 -U（other user）与 -l 选项一起使用，以指定应列出其权限的用户。sudoers 策略仅允许 root 用户或当前主机上具有 ALL 权限的用户使用此选项
-u USER
	选项 -u（user）指定执行命令时使用的用户身份，默认为 root。如果使用 uid 则使用 #uid 表示用户
-V
	选项 -V（version）显示版本信息并退出
-v
	选项 -v（validate）使密码有效期延长 5 分钟

注意：
sudo 运行时要参照配置文件 /etc/sudousers ，配置文件配置了用户能够执行的命令。
2.4 常用示例

（1）以指定用户身份执行命令。

sudo –u USERNAME CMD

3.su 和 sudo 命令的区别

（1）功能不同
su 用来长时间切换用户，常见用法是su USERNAME，未指定 USERNAME 默认切换至 root。
sudo 允许被授权的用户以其他用户或者管理员身份来执行命令，可以使用 -u 选项来指明需要使用的用户身份，默认是 root。sudo 使一般用户不需要知道超级用户的密码即可获得权限。首先超级用户将普通用户的名字、可以执行的特定命令、按照哪种用户或用户组的身份执行等信息，登记在特殊的文件中（通常是 /etc/sudoers），即完成对该用户的授权（此时该用户称为 sudoer）。若其未经授权的用户企图使用 sudo，则会发出警告的邮件给管理员。用户使用 sudo 时，必须先输入当前用户密码，如果当前用户是 root 或者当前用户与目标用户一致，无需输入密码，之后的一段时间内（默认为 5 分钟，可在 /etc/sudoers 配置），使用 sudo 不需要再次输入密码。

●screen 命令：
1.命令简介
screen 是 GNU 开发的终端会话管理工具，可以新建和管理多个终端会话，并提供切换、分离、挂载等相应的功能。
每个终端会话可以创建 1~10 个窗口，其重要的特点就是终端断开连接后，screen 创建的终端会话中的任务是保存在后台运行的，不会因为终端窗口关闭或者断开连接而终止执行。
详细说明参见GNU Screen官方站点。
2.命令格式

screen [OPTIONS] [ CMD [ ARGS ] ]
screen -r [[PID.]TTY[.HOST]]
screen -r SESSIONOWNER/[[PID.]TTY[.HOST]]

3.选项说明

-A
	将所有窗口都调整为目前终端机的大小
-d, -D [PID.TTY.HOST]
	分离指定的 screen 会话
-h NUM
	将历史记录回滚缓冲区指定为 NUM 行
-m
	即使目前处于 screen 会话，仍强制建立新的 screen 会话
-r [PID.TTY.HOST]
-r SESSIONOWNER/[PID.TTY.HOST]
	恢复离线的 screen 会话
-R
	先试图恢复离线的会话，若找不到离线的会话，再建立新的 screen 会话
-s PROGRAM
	指定建立新窗口时所要执行的 Shell，用以取代环境变量 SHELL 表示的 Shell
-S SESSIONNAME
	创建一个指定名称的新 session
-v
	显示版本信息
-x
	恢复之前离线的 screen 会话
-ls, --list
	显示目前所有的 screen 会话
-wipe [MATCH]
	检查目前所有的 screen 会话，并删除已经无法使用的 screen 会话

    1

4.常用示例

screen -S yourname: 新建一个叫 yourname 的 session
screen -ls: 列出当前所有的screen session，注意显示的screen会话的命名格式是pid.name，其中pid指的是screen的进程号，name就是screen会话的名称
screen -r yourname: 回到yourname这个session；
screen -d yourname: detach某个session；
screen -d: detach当前session；
screen -d -r yourname: 分离已经连接的 session，重新回到 yourname
exit：关闭当前窗口，并且切换到下一个窗口（当退出最后一个窗口时，该screen会话自动终止，并且退回到原始 Shell 状态）

进入一个 screen 会话中，才可以切换窗口，在每个 screen session 下，所有快捷键都以 Ctrl+a 开始。常用快捷键如下：

Ctrl+a+?：显示所有键绑定信息
Ctrl+a+c：创建一个新的运行shell窗口并切换到该窗口
Ctrl+a+n：切换到下一个window
Ctrl+a+p：切换到前一个window
Ctrl+a+0..9：切换到第 0..9 个window
Ctrl+a [Space]：由视窗0循序切换到视窗9 
Ctrl+a+d：分离当前screen会话，即退出当前screen会话。将目前的screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 Ctrl+a+z -> 把当前session放到后台执行，用 shell 的 fg 命令则可回去。
Ctrl+a Ctrl+a：在两个最近使用的window间切换。
Ctrl+a+x：锁住当前的window，需用用户密码解锁。
Ctrl+a+w：显示所有窗口列表。
Ctrl+a+t：time，显示当前时间和系统的平均负载（Load Average，是一段时间内系统的平均负载，这个一段时间一般取1分钟、5分钟、15分钟）。
Ctrl+a+k：kill window，强行关闭当前的window
Ctrl+a+[：进入copy mode，在copy mode下可以回滚、搜索、复制就像使用vi一样，常用快捷键有： 
	Ctrl+b：Backward，PageUp
	Ctrl+f：Forward，PageDown 
	H：High，将光标移至左上角
	L：Low，将光标移至左下角
	0：移到行首
	$：行末
	w：forward one word，以字为单位往前移
	b：backward one word，以字为单位往后移
	Space：第一次按为标记区起点，第二次按为终点
	Esc 结束copy mode
Ctrl+a+]：paste，把刚刚在 copy mode 选定的内容贴上。

●tar 命令：
1.命令简介
tar 命令用于将 Linux 的文件和目录创建为档案或将档案还原为文件和目录。此外，tar 也可以在档案中改变文件，或者向档案中加入新的文件。本程序最初的设计目的是将文件备份到磁带上（Tape ARchive），因而得名 tar。
tar 的工作过程主要分为两个步骤，正向是打包与压缩，反向是解压缩与还原。打包指的是将一大堆文件或目录变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。反向的解压缩与还原刚好是相反的过程。tar 的压缩与解压缩，用到的主要是 gzip 与 bzip2 命令。
2.命令格式

tar [OPTIONS] [FILE]...

3.选项说明

-A, --catenate, --concatenate
	新增文件到已存在的存档
-c，--create
	建立新的存档
-C, --directory=DIR
	将 tar 的工作目录从当前目录改为指定目录。该选项对顺序敏感，即影响其后的所有选项
-d, --diff, --compare
	对比档案与文件系统的差异
--delete
	从档案中删除制定的文件
-f, --file=ARCHIVE
	指定存档文件
-j, --bzip2
	通过 bzip2 命令压缩或解压缩档案
-k, --keep-old-files
	还原档案时，保留当前目录下的原有文件不被覆盖 
-l, --check-links
	如果不是所有链接都被转储，则打印一条消息
-m, --touch
	还原文件时，不变更文件的更改时间
-N, --newer, --after-date=DATE
	只将较指定日期更新的文件保存到档案中
-O, --to-stdout
	将提取的文件名和目录名打印到标准输出
-p, --preserve-permissions, --same-permissions
	提取文件时保留文件原来的权限
-P, --absolute-names
	创建存档时不移除文件名称前的 / 号
-r, --append
	追加文件到档案的末尾
-t, --list
	列出档案的内容
-u, --update
	添加比档案中文件更新的文件到档案中
-v, --verbose
	显示指令执行过程
-W, --verify
	向档案写入文件后尝试验证
-x, --extract, --get
	从档案提取文件  
-z, --gzip, --gunzip, --ungzip
	通过 gzip 命令压缩或解压档案
-Z, --compress, --uncompress
	通过 compress 指令处理备份文件
--exclude=PATTERN
	排除符合指定模式的文件
-?, --help
	显示短选项的概要信息并退出
--usage
	显示可用选项列表并退出
--version
	显示版本和版权信息并退出

4.常用示例

    打包

（1）将目录 /home/stud/wang 打包成 lvlv.tgz，同时使用 gzip 进行压缩。

tar –czvf lvlv.tgz /home/stud/wang

（2）将目录 /home/stud/wang 打包成 lvlv.tbz2，同时使用 bzip2 进行压缩。

tar –cjvf lvlv.tgz2 /home/stud/wang

（3）将指定目录下的目录或文件进行打包。

tar –czvf wang.tar.gz -C /home/stud/ wang

    解包

（1）将档案 lvlv.tgz 还原为原目录，同时使用 gzip 进行解压缩。

tar -xzvf lvlv.tgz

（2）将档案 lvlv.tbz2 还原为原目录，同时使用 bzip2 进行解压缩。

tar -xjvf lvlv.tbz2

（3）将 lvlv.tgz 解包到指定目录，同时使用 gzip 进行解压缩。

tar -xzvf lvlv.tgz -C DIR

    查看

（1）只查看档案的文件列表，不进行解包。

tar -tzvf wang.tar.gz

●cat 命令：
1.简介
cat 命令用于连接文件的内容并打印到标准输出。
2.命令格式

cat [OPTION]... [FILE]...

在没有文件或文件是 - 时，读取标准输入。
3.选项说明

-
	从标准输入获取内容
-A, --show-all
	等价于选项 -vET，显示文件内所有不可打印的字符
-b, --number-nonblank
	和 -n 相似，只不过对于空白行不编号
-e
	 等价于 -vE
-E, --show-ends
	在每行结束处显示 $
-n, --number
	由 1 开始对所有输出的行数编号
-s, --squeeze-blank
	当遇到有连续两行以上的空白行，就代换为一行的空白行
-t
	等价于 -vT 选项
-T, --show-tabs
	将 TAB 字符显示为 ^I
-v, --show-nonprinting
	使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）查看文件内容。

cat  filename

（2）将几个文件合并为一个文件。

cat file1 file2 > file

（3）从标准输入读取内容并重定向到文件。键入 Ctrl + d 结束输入。

cat > filename

（4）把 file1 的文档内容加上行号后重定向到 file2。

cat -n file1 > file2

（5）将文件 file1 和标准输入内容，纵向连接后重定向至文件 file2。

cat file1 - > file2

（6）清空文件内容。

cat /dev/null > file

●cd 命令（builtin）：
1.命令简介

cd（Change Directory）命令是 Shell 的内建命令（bash builtin），用来切换工作目录至指定的目录dirname。 其中 dirname 可以是绝对路径或相对路径。若目录名称省略，则变换至使用者的home directory（也就是刚login时所在的目录）。另外，~ 也表示为 home directory 的意思，. 则是表示目前所在的目录，… 则表示目前目录位置的上一层目录。
2.命令格式

cd [-L|-P] [DIR]

3.选项说明

-p
	如果要切换到的目标目录是一个符号连接，直接切换到符号连接指向的目标目录
-L
	如果要切换的目标目录是一个符号的连接，直接切换到字符连接名代表的目录，而非符号连接所指向的目标目录。
-
	当仅使用一个横杠 - 时，当前工作目录将被切换到环境变量 OLDPWD 所表示的目录
--
	两个横杠，当前工作目录将被切换到用户家目录

4.常用示例

（1）回到上一层目录。

cd ..

（2）回到根目录。

cd /

（3）回到上次使用的目录。

cd –

（4）回到用户家目录。

cd ~
# 或
cd -- 

注意：
（1）登录 Linux 主机后，命令行最左侧[lvlv@echidna ~/code]$中，~ 表示在当前用户的家目录，$ 表示是普通用户权限，# 则表示超级用户权限。echidna 表示当前主机的名称，lvlv 则表示当前登录的用户名称。查看当前主机名称用 hostname 命令。

●touch 命令：
1.命令简介
touch 命令用于修改文件或者目录的访问时间、内容修改时间和状态更改时间。默认情况，若文件不存在则新建。
2.命令格式

touch [OPTION]... FILE...

3.选项说明

-a
	改变档案的访问时间
-c, --no-create
	不创建任何文件
-d, --date=STRING
	使用指定的时间修改文件时间属性，而非当前时间
-f
	不使用，是为了与其他 Unix 系统的相容性而保留
-h, --no-dereference
	只改变符号链接的时间属性，而不是链接的文件
-m
	改变档案的修改时间
-r, --reference=FILE
	使用参考文件的创建时间，而不是当前时间
-t STAMP
	指定文件的创建时间而不是当前时间，时间 STAMP 格式与 date 命令相同
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）改变文件的时间（最近访问，最近修改和最近改动）为当前系统时间。

touch filename

（2）如果目标文件不存在，则新建一个文件

touch filename

●rm 命令：
1.命令简介
rm（remove）命令用于删除文件或者目录。
使用 rm 命令要格外小心，因为一旦删除了一个文件就无法再恢复它，所以在删除文件之前，最好再看一下文件的内容，确定是否要真要删除。
2.命令格式

rm [OPTION]... FILE...

3.选项说明

-d, --dir
	删除空目录
-f, --force
	忽略不存在的文件和参数，永不提示
-i
	在每一次删除文件或目录之前先询问用户是否确定删除，如果不删除则跳过当前文件或者目录
-I
	删除超过三个文件或在递归删除时，提示一次。比 -i 提醒程度较松，同时也能防止大多数错误。如果选择不删除，则终止整个操作
--interactive[=WHEN]
	提醒的方式根据 WHEN 的取值：never 表示不进行提示，once 等同于 -I 选项，always 等同于 -i 选项。不指定 WHEN 默认为 always
--one-file-system
	在递归删除层次结构时，跳过与相应命令行参数不同的文件系统上的任何目录
--no-preserve-root
	对根目录不做特殊对待
--preserve-root
	不删除根目录，为默认选项
-r, -R, --recursive
	递归处理，将指定目录下的所有文件与子目录一并删除
-v, --verbose
	显示指令的详细执行过程
--help
	显示帮助信息
--version
	显示版本信息

4.常用示例

（1）删除目录 dir。

rm –r dir

（2）删除当前目录下所有文件及目录，不包含点号 . 开头的隐藏文件和目录。

rm  -r  *

（3）删除当前目录下所有隐藏的文件及目录。

rm -rf .* 

因为当前目录（.）和上一层目录（…）无法删除，会产生如下错误信息。

rm: refusing to remove ‘.’ or ‘..’ directory: skipping ‘.’
rm: refusing to remove ‘.’ or ‘..’ directory: skipping ‘..’

如果想丢弃上面的错误信息可以使用如下命令：

rm -rf .* 2>/dev/null

该命令表示丢弃标准错误输出。数字 2 是标准错误输出的描述符，/dev/null 是一个特殊的设备文件，即空设备，类似于 Windows 的回收站，主要用于丢弃不需要的输出。注意重定向操作符 > 与两边操作数不能有空格。

●mv 命令：
1.命令简介
mv (move) 用来移动或改名文件和目录。
移动文件时如果目标文件已经存，则目标文件的内容将被覆盖。
mv 命令可以用来将源文件移至一个目标文件中，或将一组文件移至一个目标目录中。源文件被移至目标文件有两种不同的结果：
（1）如果目标文件是目录，源文件会被移到此目录下，且文件名不变。当目标文件是目录时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标目录中。所有移到该目录下的文件都将保留以前的文件名。
（2） 如果目标文件不是目录文件，则源文件名（只能有一个）会变为此目标文件名，并覆盖己存在的同名文件。如果源文件和目标文件在同一个目录下，mv 的作用就是改文件名。
注意：
(1) mv 与 cp 的结果不同，mv 像是文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。
(2) 尽管其手册没有说明，使用 mv 移动目录时如果目标目录非空将失败。确定安全的情况下，可以使用cp -rf yourdir dst && rm -r yourdir。
2.命令格式

mv [OPTION]... [-T] SOURCE DEST
mv [OPTION]... SOURCE... DIRECTORY
mv [OPTION]... -t DIRECTORY SOURCE...

3.选项说明

--backup=[=CONTROL]
	若需覆盖文件，则覆盖前先行备份
-b
	当文件存在时，覆盖前，为其创建一个备份。功能类似于--backup，但是不需要接收参数
-f, --force
	若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录，不进行提示
-i, --interactive
	交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖
-n, --no-clobber
	不覆盖现有的同名文件或目录；如果同时指定多个以下选项，-i, -f, -n，则只有最后一个生效
--strip-trailing-slashes
	删除参数 SOURCE 中所有目录末端的斜杠
-S, --suffix=SUFFIX
	为备份文件指定后缀，而不使用默认的后缀
-t, --target-directory=DIRECTORY
	指定源文件要移动到的目标目录
-u, --update
	当源文件比目标文件新或者目标文件不存在时，才执行移动操作
-v, --verbose
	冗余模式执行 mv，解释 mv 命令的执行过程
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例
（1）将文件 old 改名为 new。

mv old new

（2）将目录 /usr/men 中的所有文件移到当前目录（用.表示）中。

mv /usr/men/* .

●cp 命令：
1.简介
cp 命令主要用于复制文件或目录，可以将一个或多个源文件或者目录复制到指定目的文件或目录。当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。
2.命令格式

cp [OPTION]... [-T] SOURCE DEST
cp [OPTION]... SOURCE... DIRECTORY
cp [OPTION]... -t DIRECTORY SOURCE...

3.选项说明

-a, --archive
	此参数的效果和同时指定"-dR --preserve=all"参数相同；
--backup[=CONTROL]
	备份即将被覆盖的目的文件；
-b
	等同于 --backup，但不接受参数；
--copy-contents
	递归拷贝时，拷贝特殊文件的内容；
-d
	当复制符号连接时，保留符号连接； 
-f, --force
	强行复制文件或目录，不论目标文件或目录是否已存在； 
-i, --interactive
	覆盖既有文件之前先询问用户； 
-H
	遵循源文件中的命令行符号链接；
-l, --link
	对源文件建立硬连接，而非复制文件；
-L, --dereference
	总是遵循源文件中的命令行符号链接；
-n, --no-clobber
	不覆盖既有文件；
-P, --no-dereference
	不遵循源文件的符号连接；
-p
	等同于 --preserve=mode,ownership,timestamps；
--preserve[=ATTR_LIST]
	保留指定的文件属性，而非默认的 mode,ownership,timestamps。其它的属性也可以指定，如 context, links, xattr, all；
-c
	等同于 --preserve=context；
--no-preserve=ATTR_LIST
	不保留指定的文件属性；
--parents
	在目录下使用完整的源文件名；
-R, -r, --recursive
	递归处理，将指定目录下的所有文件与子目录一并处理；
--reflink[=WHEN]
	控制克隆/CoW 副本。请查看下面的内容；
--remove-destination
	移动每一个已经存在的目标文件；
--sparse=WHEN
	控制创建稀疏文件；
--strip-trailing-slashes
	删除参数SOURCE中所有目录末端的斜杠；
-s, --symbolic-link
	对源文件建立符号连接，而非复制文件；
-S, --suffix=SUFFIX
	在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；
-t, --target-directory=DIRECTORY
	拷贝所有 SOURCE 指定的文件到目标目录 DIRECTORY；
-T, --no-target-directory
	没有目标目录，将目标文件DEST视为正常文件；
-u, --update
	使用这项参数后只会在源文件的更改时间较目标文件新时或是名称相互对应的目标文件并不存在时，才复制文件；
-v, --verbose
	冗余模式执行cp命令，解释cp的执行过程。
-x, --one-file-system
	保留在当前的文件系统上。
-Z, --context=CONTEXT
	将指定的文本内容变为安全的内容，该选项仅限于 SELinux 内核使用。
--help
	显示帮助信息。
--version
	显示版本信息。

选项补充说明。
（1）默认情况下，源文件的稀疏性仅仅通过简单的方法判断，对应的目标文件目标文件也被为稀疏。这是因为默认情况下使用了--sparse=auto 参数。如果明确使用
--sparse=always 参数则不论源文件是否包含足够长的0 序列也将目标文件创文
建为稀疏件。使用--sparse=never 参数禁止创建稀疏文件。
（2）当指定了--reflink[=always]参数时，执行轻量化的复制，即只在数据块被修改的情况下才复制。如果复制失败或者同时指定了--reflink=auto，则返回标准复制模式。
（3）备份文件的后缀为"~"，除非以--suffix选项或是SIMPLE_BACKUP_SUFFIX环境变量指定。版本控制的方式可通过--backup选项或VERSION_CONTROL环境变量来选择。以下是可用的变量值：
none, off：不进行备份（即使使用了–backup 选项）；
numbered, t：备份文件加上数字进行排序；
existing, nil：若有数字的备份文件已经存在则使用数字，否则使用普通方式备份；
simple, never：永远使用普通方式备份。

（4）有一个特别情况，如果同时指定--force和--backup选项，而源文件和目标文件是同一个已存在的一般文件的话，cp会将源文件备份。
4.常用示例

（1）复制 dir 目录到 dir2。

cp -r dir dir2

（2）复制文件 a、b、c、d 到 dir2。

cp a b c d dir2

（3）交互式地将目录 /usr/men 中的以 m 打头的所有 .c 文件复制到目录 /usr/zh 中。

cp -i /usr/men m*.c /usr/zh

我们在 Linux 下使用 cp 命令复制文件时候，有时候会需要覆盖一些同名文件，覆盖文件的时候都会有提示：需要不停的按 Y 来确定执行覆盖。

●rename 命令：
1.命令简介
功能类似于 mv，可实现文件或者目录的重命名。mv 不能批量处理，而 rename 可以。
2.命令格式

rename [OPTIONS] EXPRESSION REPLACEMENT FILE...

EXPRESSION：原字符串，即文件名需要替换的字符串；
REPLACEMENT ：目标字符串，将文件名中含有的原字符替换成目标字符串；
FILE…：指定要改变文件名的文件列表。

rename 支持的通配符：

?    可替代单个字符
*    可替代多个字符
[charset] 可替代charset集中的任意单个字符

3.选项说明

-s, --symlink
	不要重命名符号链接，而是重命名它的目标
-v, --verbose
	以冗余模式运行，显示哪些文件已被重命名
-o, --no-overwrite
	不要覆盖现有文件
-i, --interactive
	更名前询问是否确定
-h, --help
	显示帮助信息并退出
-V, --version
	显示版本信息

4.常用示例

（1）重命名文件 lvlv 为 lala。

rename v a lv??

（2）将当前目录下的所有文件的后缀名由 .html 改为 .php。

rename .html .php *

●echo 命令：
1.简介
echo 命令用于在 Shell 中打印 Shell 变量的值，或者直接输出指定的字符串。
2.命令格式

echo [选项] [参数]

3.选项说明

-n
	输出时，不在行尾添加换行符
-e
	使反斜杠的转义功能生效
-E
	禁用反斜杠的转义功能，为默认选项
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

使用 -e 选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：

\\：反斜杠；
\a：发出警告声；
\b：删除前一个字符；
\c：截断不输出\c后面的内容；
\f：换行，但光标仍旧停留在原来的位置；
\n：换行且光标移至行首；
\r：光标移至行首，但不换行；
\t：插入tab；
\v:与\f相同；
\nnn：插入nnn（八进制）所代表的ASCII字符；
\xHH：插入HH（十六进制）所代表的ASCII字符；

4.常用示例

（1）不换行输出。
echo默认换行输出，使echo不换行输出有两种方法。
方法一：使用命令选项-n禁止输出换行符。

echo -n what you want to output

**方法二：**使用命令选项 -e 让echo识别转义字符\c，echo默认是不识别转义字符的。转义字符\c使用man echo查看echo的使用手册，其意思是produce no further output，表示截断不输出\c后面的内容。

echo -e lalalala\cend #输出：lalalala

（2）使用echo打印带有颜色的字体。
Linux终端下输出带颜色的文字只需在文字前面添加如下格式：

\033[显示方式;前景色;背景色m

其中\033是ESC健的八进制，\033[即告诉终端后面是设置颜色的参数，显示方式，前景色，背景色均是数字。数字含义如下：
显示方式	意义
0	终端默认设置
1	高亮显示
4	使用下划线
5	闪烁
7	反白显示
8	不可见

颜色数字代号如下：
前景色	背景色	颜色
30	40	黑色
31	41	红色
32	42	绿色
33	43	黃色
34	44	蓝色
35	45	紫红色
36	46	青蓝色
37	47	白色

（a）显示红色字体： ``` echo -e "\e[1;31mThis is red text\e[0m" ``` 输出： This is red text

其中，\e[0m表示恢复终端默认设置。

（b）显示绿色背景字体：

echo -e "\e[1;42mGreed Background\e[0m" Greed Background

输出：
这里写图片描述

（c）文字闪动。使用前景色31（红色），背景色42（绿色）闪动：

echo -e "\033[5;31;42mMySQL Server Stop...\033[0m"

●tee 命令：
1.命令简介
tee 命令从标准输入读取数据后，将数据重定向到给定的文件和标准输出。给定的文件可以有多个。
因为 tee 意为字母 T，数据从左边（标准输入）流入，从右边（标准输出）和下面（文件）分流输出，字母 T 的形状很形象地说明了数据的流向，故将该命令命名为 tee。数据流向过程如下图所示。

ls -l        |tee file.txt|       less
stdout      ----------------->    stdout
                    |
                    v
                  file.txt

2.命令格式

tee [OPTION]... [FILE]...

3.选项说明

-a, --append
	向文件中重定向时使用追加模式
-i, --ignore-interrupts
	忽略中断（interrupt）信号
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）标准错误输出和标准输出同时输出到屏幕和指定文件 file1 与 file2。

make 2>&1 | tee file1 file2

2>&1 表示将标准错误输出重定向到标准输出；tee 表示将命令结果同时输出到屏幕和文件。

●ls 命令:
1.简介
ls（list）命令用来显示目录内容或文件信息，使用率较高。ls 命令的输出信息可以进行彩色加亮显示，以区分不同类型的文件。
2.命令格式

ls [OPTION]... [FILE]...

3.选项说明

-a, --all
	显示所有档案及目录（ls内定将档案名或目录名称以“.”开头的文件视为影藏文件，默认不会列出）； 
-A, --almost-all
	显示除影藏文件“.”和“..”以外的所有文件列表
--author
	与 -l 选项结合使用，打印出每一个文件的作者
-b, --escape
	将文件中的不可输出的字符以反斜线“\”加字符编码的方式输出；
--block-size=SIZE
	指定文件大小的统计单位。SIZE 可以取如下字符串，或对应的数值: KB 1000, K 1024, MB 1000*1000, M 1024*1024,以及G, T, P, E, Z, Y等
-B, --ignore-backups
	不要列出以~结尾的隐含条目，默认列出；
-c
	与“-l”选项连用时，展示 ctime；与“-lt”选项连用时，输出按照文件状态改变时间排序，排序的依据是文件的索引节点中的ctime字段
-C
	多列显示输出结果。这是默认选项 
--color[=WHEN]
	使用不同的颜色高亮显示不同类型文件，WHEN的默认取值为'always'，也可以是'never'或'auto'；
-d, --directory
	仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录或文件； 
-D, --dired
	以Emacs的dired模式输出
-f
	此参数的效果和同时指定“aU”参数相同，并关闭“-ls --color”参数效果 
-F, --classify
	在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符
--file-type
	与 -F 选项功能相同，但是不显示 * 
--format=WORD
	WORD 可取值为 across，等价于 -x 选项。取值为 commas，等价于 -m。取值为horizontal，等价于-x。取值为long，等价于-l。取值为single-column，等价于-1。取值为verbose，等价于-l。取值为vertical，等价于-C
--full-time
	列出完整的日期与时间
-g
	类似于 -l，但不列出所属者
--group-directories-first
	目录排在文件之前列出
-G, --no-group
	在长格式(-l)输出时，不输出组名
-h, --human-readable
	以可读方式显示文件大小
--si
	以 1000 代替 1024 计算文件大小
-H, --dereference-command-line
	使用命令列中的符号链接指示的真正目的地
--dereference-command-line-symlink-to-dir
	遵循命令行中列出的符号链接
--hide=PATTERN
	不列出符合 PATTERN 模型的隐藏文件
--indicator-style=WORD
	追加指示符 WORD 到每一个文件或目录名称后，none默认 slash (-p), file-type (--file-type), classify (-F)；
-i, --inode
	显示文件索引节点号（inode）。一个索引节点代表一个文件 
-I, --ignore=PATTERN
	不列出匹配 PATTERN 的文件或目录名
-k
	以 KB 为单位显示文件大小，类似于 --block-size=1K
-1
	数字 1，与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；
-l
	以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件类型、权限模式、硬链接数、所有者、组、文件大小、文件的最后修改时间和文件/目录名； 
-L, --dereference
	如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录； 
-m
	用逗号区隔每个文件和目录的名称 
-n
	以用户识别码和群组识别码替代其名称
-N, --literal
	直接列出文件和目录名称，包括控制字符
-o
	此参数的效果类似于 -l，但不列出用户组信息
-p, --indicator-style=SLASH
	追加指定指示符到文件或目录后，SLASH 可取值 none、slash、file-type 或 classify
-q, --hide-control-chars
	用 ? 号取代控制字符，列出文件和目录名称
--show-control-chars
	显示文件和目录名称中的控制字符
-Q, --quote-name
	把文件和目录名称以双引号“”标示起来；
--quoting-style=WORD
	使用指定的引号模式来标识档案名称，WORD的取值有：literal, locale, shell, shell-always, c, escape；
-r, --reverse
	反序排列
-R, --recursive
	递归处理，将指定目录下的所有文件及子目录一并处理 
-s, --size
	显示文件和目录的大小，以区块为单位 
-S
	以文件大小进行排序，最大的第一个
--sort=WORD
	以指定的内容进行排序，而非默认的档案名称，WORD可取值：none（不排序，等于-U）；extension（以条目名的最后一个扩展名排序，等于-X）；size(以用条目大小排序，等于-S）;time(以条目内容最后被修改时间排序，等于-t);version(以条目版本进行排序，等于-v);
--time=WORD
	当使用-t或--sort=time来按照时间排序时，WORD可取值为atime、access、use(表示使用访问时间排序)；或者ctime、status（状态改变时间排序），来取代默认以内容修改时间排序；
--time-style=STYLE：使用-l选项时，显示时间使用指定的样式风格STYLE，可取值为full-iso,long-iso,iso,locale，还有+FORMAT,FORMAT，这两项设置格式可以参考date命令的设置方法；
-t
	用文件和目录的内容修改时间排序； 
-T, --tabsize=COLS
	设置每一列之间的Tab间隔符代表的宽度为COLS，默认为8个空格；
-u
	与 -lt 同用，表示使用访问时间排序，与-l同用，显示访问时间而非内容修改时间；
-U
	列出文件和目录名称时不予排序；
-v
	文件和目录的名称列表以版本进行排序
-w, --width=COLS
	设置每列的最大字符数为 COLS
-x
	以从左到右，由上至下的横列方式显示文件和目录名称
-X
	以文件和目录的最后一个扩展名排序
--help
	显示帮助信息
--version
	显示版本信息

4.常用示例

（1）以长格式显示隐藏文件，包括当前目录和父级目录。

[dablelv@TENCENT64 ~]$ ll -a
total 148
drwxr-x---  8 dablelv dablelv  4096 Nov 23 23:56 .
drwxr-xr-x 22 root    root     4096 Jun  7 15:15 ..
-rw-------  1 dablelv dablelv 71812 Nov 24 00:38 .bash_history
-rw-r--r--  1 dablelv dablelv  2153 May  2  2017 .bash_profile
-rw-------  1 dablelv dablelv   595 Nov 24 16:57 .lesshst
drwx------  2 dablelv dablelv  4096 Jul 23 20:42 .ssh

第一列：文件类型与权限；
第二列：硬链接数；
第三列：属主；
第四列：文件属组，注意不是属主所在的用户组；
第五列：大小，单位为字节；
第六列：创建或最后的内容修改时间；
第七列：文件名或目录名。

输出结构示意图如下：

             有多少文件名连接到此    容量默认单位 bytes(字节)
                索引节点(i-node)        ^
                    ^                   |
                    |                   |
      d rwxr-xr-x   1   root   root   4096   Jul 18 08:56      /home
文件类型    权限         属主   属组          创建或修改文档     文档路径名
                                               内容的时间

实际上 ll 是ls -l的别称，使用 alias 命令可以查看相关命令的别称。

[dablelv@TENCENT64 ~]$ alias
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'

（2）以指定的文件大小类型展示。

[dablelv@TENCENT64 ~]$ ll --block-size=K
total 24K
drwxrwxr-x 10 dablelv dablelv 4K Nov 21 15:08 code_root
-rwxrwxr-x  1 dablelv dablelv 1K Nov 21 00:18 dable.php
-rw-rw-r--  1 dablelv dablelv 1K Nov 21 00:18 dablelala.php
-rw-rw-r--  1 dablelv dablelv 0K Nov 23 23:56 dablelv~
-rw-rw-r--  1 dablelv dablelv 1K Nov 21 00:40 dablenewnew
drwxrwxrwx  2 dablelv dablelv 4K Nov 21 00:29 new
drwxrwxr-x  6 dablelv dablelv 4K Nov 21 00:24 test

（3）ls 命令按照修改日期递减排序

ls -t

    1

如果想按照修改日期递增的话使用ls -rt 就行了。

（4）ls 命令按照文件大小递减排序。

# 递减排序
ls -Sh

# 递增排序
ls -Shr

●scp 命令：
1.命令简介
scp（secure copy）命令是一个基于 SSH 安全的进行远程文件拷贝命令，用于在 Linux 下远程拷贝文件，和它类似的命令有 cp，不过 cp 只是在本机进行拷贝不能跨服务器，而且 scp 支持对传输的数据进行加密。
2.命令格式

scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file] [-l limit] [-o ssh_option] [-P port] [-S program] 
	[[user@]host1:]file1 ... [[user@]host2:]file2

3.选项说明

-1
	使用 SSH 协议版本 1
-2
	使用 SSH 协议版本 2
-4
	使用 ipv4
-6
	使用 ipv6
-B
	以批处理模式运行，阻止 scp 询问口令
-C
	使用压缩，将 -C 标志传递给 SSH，从而打开压缩功能
-c CIPHER
	使用指定的秘钥对传输的文件进行加密
-F SSH_CONFIG
	指定 SSH 配置文件
-i IDENTITY_FILE
	从指定文件中读取传输时使用的密钥，此参数直接传递给 ssh
-l LIMIT
	指定宽带限制
-o SSH_OPTION
	指定使用的 ssh 选项，可以使用 SSH_CONFIG 中使用的 ssh 选项
-P PORT
	指定远程主机的端口号
-p
	保留文件的最后修改时间，最后访问时间和权限模式
-q
	静默模式，不显示复制进度以及来自 ssh 的警告和诊断消息
-r
	以递归方式复制整个目录
-S PROGRAM
	指定加密传输时所使用的程序。此程序必须能够理解 ssh 的选项
-v
	使用冗余模式，使 scp 和 ssh 打印调试信息以及进度

注意事项：
（1）scp 返回 0 成功，>0 失败；
（2）使用 scp 在不同主机之间进行文件传输，需要确保两台设备都开启了ssh远程登录服务，且两台设备能互相通信；
（3）使用 scp 命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp 命令无法起作用。
4.常用示例

（1）远程主机之间，使用 scp 拷贝多个文件。
方法一：将多个文件放在同一个目录中，使用scp -r来拷贝，参考如下代码：

scp -r uername@sourceHostName:sourcedir username@destinationHostName:destinationdir

方法二：将多个文件或者目录使用tar打包后作为单个文件传输。

方法三：scp支持同时拷贝多个文件的功能。

scp file1  file2 remote_username@remote_ip:remote_folder 

（2）从本地复制文件到远程。
命令格式：

scp local_file  remote_username@remote_ip:remote_folder 
# 或
scp local_file remote_username@remote_ip:remote_file 
# 或
scp local_file remote_ip:remote_folder 
# 或
scp local_file remote_ip:remote_file 

第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；
第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名。
应用实例：

scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music 
scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music/001.mp3 
scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music 
scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music/001.mp3 

（3）使用 scp 复制目录。
命令格式：

scp -r local_folder remote_username@remote_ip:remote_folder 
# 或
scp -r local_folder remote_ip:remote_folder

第 1 个指定了用户名，命令执行后需要再输入密码；
第 2 个没有指定用户名，命令执行后需要输入用户名和密码。
应用实例：

scp -r /home/space/music/ root@www.runoob.com:/home/root/others/ 
scp -r /home/space/music/ www.runoob.com:/home/root/others/ 

上面命令将本地 music 目录复制到远程 others 目录下。

（4）从远程复制到本地。
从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例
应用实例：

scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 
scp -r www.runoob.com:/home/root/others/ /home/space/music/

**说明：**如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：

#scp 命令使用端口号 4588
scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator

（5）使用 expect 和 scp 实现不同主机之间文件的自动传输。
脚本如下：

#!/usr/bin/expect
set timeout 5
spawn scp dablelv@172.25.44.22:/yourpath/yourfile root@10.130.89.104:/destinationpath
expect "dablelv@172.25.44.22's password:"
send "123456\n"
expect "root@10.130.89.104's password:"
send "123456\n"
interact eof

脚本解释：
第一行：#!/usr/bin/expect 指明该脚本由expect来解析。这里的expect其实和linux下的bash、Windows下的cmd.exe是一类东西，都是可执行程序，也可用于脚本的解析器。expect的主要作用是解析自动交互的脚本，比如实现ssh的自动登录，无需手动输入密码等。
第二行：set timeout 5 用于设置expect的expect命令的等待时间为5秒，如果expect等待的值在5秒内没有出现在标准输出，那么expect脚本继续执行。expect的默认timeout为10s。
第三行：spawn scp dablelv@172.25.44.22:/yourpath/yourfile 。spawn是expect的内置命令，不是Linux可执行程序，使用which spawn 是查不到spawn所在路径的。这个就好比cd是shell的内建命令，离开shell，就无法执行cd一样。 它主要的功能是给ssh运行进程加个壳，用来传递交互指令。 它主要的功能是给后面需要执行的命令加个壳，用来传递交互指令。
第四行：expect "dablelv@172.25.44.22's password:" expect命令也是expect的内建命令，其作用就是等待标准输出出现指定的值，如果有则立即返回，向下执行；否则就一直等待，等待的最长时间由上面的set timeout来指定。
第五行：send "123456\n"就是在expect等待到指定的值之后向标准输出发送的值，这里就是执行交互动作，与手工输入密码的动作等效。效果上跟用户手动在终端上输入123456之后敲一个回车一样。
第六、七行实现的功能同第五六行，因为scp需要登录到两个主机实现文件的网络传输，所以这里是登录第二台主机需要输入的密码。
第八行：interact eof 表示expect脚本执行结束。执行完成上述命令后，此时Expect会把控制权交给控制台，这个时候就变回手工操作。如果是使用ssh登录其它主机的话，需要保持在交互状态，那么此时需要interact，如果没有这一句登录完成后会立刻退出，而不是留在远程终端上。如果你只是登录过去执行一段命令就退出，可将其改为expect eof。
如果出现 ": no such file or directory 这样的错误，很可能是因为在本地Windows环境编辑，上传到Linux下执行因文件格式不同导致的，可使用vi或者vim在末行模式使用:set ff来查看文件格式，如果是dos格式的话，那么需要使用:set ff=unix 来改变文件格式。

●find 命令：
1.命令简介
find 命令用于在指定目录查找文件，可以指定一些匹配条件，如按文件名、文件类型、文件属主甚至是时间戳来查找文件，默认递归查找。
2.命令格式

find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]

（1）基本命令选项-H、-L、和-P控制着对符号链接的处理方式；
（2）如果没有给定搜索路径 [path…]，则默认为当前目录；
（3）如果没有给定表达式 [expression]，则默认为-print，将匹配的文件输出到标准输出。

其实[-H] [-L] [-P] [-D debugopts] [-Olevel]这几个选项并不常用，expression 可以拆解为"-options -test -action"，将在第四节详细介绍。
3.选项说明

-P
	永远不跟随符号链接。这是默认行为。当发现待查询的文件是一个符号链接，使用的信息应采取的符号链接本身的性质
-L
	跟随符号链接，当发现检验或打印信息的文件是一个符号链接，使用的信息应采取的符号链接对应的文件。使用此选项意味着-noleaf，当后面使用-P时，-noleaf仍然有效；
-H
	不跟随符号链接，除了在处理命令行参数。当发现检验或打印文件有关的信息，这些信息必须是符号链接本身的性质，唯一例外是指定的命令行参数是一个文件符号链接，则使用链接的文件。当-H生效时，命令行的参数有一个指向目录的符号链接，该目录内容将被检查，当然选项`-maxdepth 0`将会阻止这个操作；
-D DEBUGOPTIONS
	使 find 打印诊断信息，使用时debug选项使用逗号分隔，可以使用"find -D help"查看完整有效的debug选项，有效的有：
	help：解释debug选项；
	tree：以原始优化的方式显示表达式树；
	stat：打印文件使用stat和lstat命令显示的信息；
	opt：打印与表达式树优化有关的诊断信息；
	rates：打印动作执行成功和失败次数的总体信息；
-OLEVEL
	启动查询优化，对执行动作重新排序来加速整体效果，优化等级有 0、1、2、3 四个级别

注意：如果 -P、-L、-H 同时指定，以最后一个为准。
4.命令表达式（expression）

find 命令表达式可以分为三类：
一是普通选项（options），总是真，在其它表达式前指定，设置搜索路径的深度、查看帮助、版本信息等；
二是比较测试（tests），给定find查找满足特定条件的文件；
三是动作（actions），对查找到的文件，执行指定的操作。

对于多个表达式，find 从左向右处理，所以表达式的前后顺序不同会有不同的搜索性能。

find 首先对整个命令行进行语法解析，并应用给定的options，然后定位到搜索路径path下开始对路径下的文件或子目录进行表达式评估或测试（test），评估或测试的过程是按照表达式的顺序从左向右进行（此处不考虑操作符的影响），如果最终表达式评估结果为true，则输出该文件全路径名。

对于 find 来说，一个非常重要的概念：find的搜索机制是根据表达式返回的 true/false 决定的，每搜索一次都判断一次是否能确定最终评估结果为true，只有评估的最终结果为 true 才算找到，并切入到下一个搜索点。
4.1 表达式操作符（operators）

操作符控制表达式运算方式。确切地说，是控制 expression 中的 options/tests/actions 的运算方式，无论是options、tests还是actions，它们都可以给定多个，例如：

find /tmp -maxdepth 3 -mindepth 1  -type f -name "*.log" -exec ls '{}' \; -print

该find中给定了两个option（-maxdepth 3 -mindepth 1），两个test（-type f -name "*.log"），两个action（-exec ls '{}' \; -print），它们之间从前向后按顺序进行评估，所以如果想要改变运算逻辑，需要使用操作符来控制。

注意，理解and和or的评估方式非常重要，写在and或or后面的表达式很可能不起作用，而导致跟预期结果不一样。

下面的操作符优先级从高到低。

( expr )         ：优先级最高。为防止括号被shell解释(进入子shell)，所以需要转义，即\(...\)。
! expr           ：对expr的true和false结果取反。同样需要使用引号包围。
-not expr        ：等价于"! expr"。
expr1 expr2      ：等同于and操作符。
expr1 -a expr2   ：等同于and操作符。
expr1 -and expr2 ：首先要求expr1为true，然后expr2以expr1搜索的结果为基础继续检测，然后再返回检测值为true的文件。因为expr2是以expr1结果为基础的，所以如果expr1返回false，则expr2直接被忽略而不会进行任何操作。
expr1 -o expr2   ：等同于or操作符。
expr1 -or expr2  ：expr1返回true或false都不影响expr2的检测，它们是独立的。如果expr1返回true，则独立输出该结果，然后开始评测expr2。所以既返回expr1为ture的，也返回expr2为true的文件，但两者同名的文件只返回一次。
expr1 , expr2    ：逗号操作符表示列表的意思，expr1和expr2都会被评估，但expr1的true或false是被无视的，只有expr2的结果才是最终状态值。

关于and和or操作符，一定要知道and后表达式操作的对象是前表达式的结果，而or操作符则不是。例如：

find /tmp -type f -name "*.log"

它是一个and操作符，-name表达式是在-type筛选的结果基础上再匹配文件名的。但如果是：

find /tmp -type f -o -name "*.log"

则-name操作的对象是/tmp，所以返回结果中即有任意普通文件，也有任意log文件，但两者同名的文件只返回一次。

总之，要明确的是or操作符不以前面结果为基础，且or前面表达式为true的结果也会输出。
4.2 表达式说明

（1）普通选项。

-d：等同于-depth，为了与FreeBSD, NetBSD, MacOS X and OpenBSD进行兼容；
--daystart:从本日开始计算时间,在使用（-amin、-atime、-cmin、-mmin和-mtime）选项时，时间从当前开始，而非24小时前；
-depth：查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找；
-follow：该选项已经废弃，请使用-L;
-help, --help：显示find基本用法；
-ignore_readdir_race：默认情况下，find无法获取文件状态时，将发出错误信息。使用该选项后，将不会报错；
-maxdepth [levels]：设置最大搜索目录层级；
-mindepth [levels]：设置最小搜索目录层级；
-mount：查找文件时不跨越文件系统mount位置，同-xdev;
-noignore_readdir_race：与-ignore_readdir_race作用相反，为默认选项；
-noleaf：不去考虑目录至少需拥有两个硬连接存在；
-regextype [type]：指明正则表达式语法规则；
-version, --version：打印版本信息；
-warn：打开警告；
-nowarn：关闭警告；
-xautofs：查找文件时不在autofs文件系统查询；
-xdev：作用同-mount；

（2）比较测试。

+n：大于指定的n；
-n：小于指定的n；
n：等于指定的n；
-amin [n]：文件最后访问时间为n分钟之前；
-anewer [file]：待查找的目标文件最后访问时间要比指定文件file的最后修改时间要新；
-ctime [n]：文件状态改变时间在n*24小时之前；
-empty：寻找文件大小为0 Byte的文件或目录下没有任何子目录或文件的空目录；
-executable：寻找可执行文件与可搜索的目录；
-false：将find指令的返回值皆设为false；
-fstype [type]：只寻找指定文件系统类型下的文件或目录；
-gid [n]：文件所属用户组ID为n；
-group [gname]:文件所属用户组名为gname；
-ilname [pattern]：与-lname作用相似，但匹配时忽略大小写；
-iname [pattern]：与-name作用相似，但匹配是忽略大小写。比如匹配模式是"fo*"
-inum [n]：查找文件inode节点号为n；
-ipath [pattern]：作用同-iwholename，该命令选项已被废弃，所以请不要使用它；
-iregex [pattern]：与-regex作用相同，但忽略大小写；
-iwholename [pattern]：作用与-iwholename相似，但忽略大小写；
-links [n]：文件有n个硬连接；
-lname [pattern]:查找符号链接，所指文件内容符合指定模式pattern；
-mmin n:查找在指定时间前被更改过的文件或目录，单位以分钟计算；
-mtime n:查找指定时间前被更改过的文件或目录，单位以天（24h）计算；
-name [pattern]:指定名称的文件或目录，
-newer [file]:查找最后修改时间比指定文件file还要新的文件；
-newerXY [reference]:比指定的文件或者时间[reference]要新的文件，X和Y是占位符，可取值如下：
	a：reference的访问时间；
	B：reference的创建时间；
	c：reference的inode状态改变时间；
	m：reference的修改时间；
	t：reference为直接指定的时间。
-nogroup:查无有效属组的文件文件或目录，即文件的属组在/etc/groups中不存在；
-nouser:查无有效属主的文件，即文件的属主在/etc/passwd中不存；
-path [pattern]:查找指定目录格式的文件或目录，如此可以避免对整个目录进行查找，比如 find . -path "./src/*sc"可以避免对目录./inc/的查找；
-perm [mode]:查找指定的权限的文件或目录，需要完全匹配；
-perm -[mode]:查找指定权限的文件或目录，不需要完全匹配，注意与不加横杠mode的区别；
-perm /[mode]:查找指定权限的文件或目录，不需要完全匹配，不需要每个类型的用户都满足，注意与mode、-[mode]的区别；
-readable:查找拥有可读权限的文件或目录；
-regex [pattern]:文件名称匹配正则表达式pattern;
-samefile [name]:查找inode名称为[name]的文件；
-size n[cwbkMG]:查找指定大小的文件；
-true:将find指令的返回值皆设为false；
-type [c]:查找指定类型的文件，类型c可取值：
	b - 块设备文件。
	c - 字符设备文件。
	d - 目录。
	f - 普通文件
	l - 符号链接文件。
	p - 管道文件。
	s - socket。
-uid [n]:查找用户ID为n的文件；
-used [n]:查找文件或目录状态改变过之后，在n天内被访问过的文件或目录；
-user [uname]:查找符和指定所有者名称的文件或目录；
-wholename [pattern]:等同于-path；
-writable:具有可写权限的文件。它会考虑访问控制列表（access control lists）等的特殊权限，只要是可写就满足。它会忽略掉-perm的测试(不是writeable)；
-xtype [c]:等同于-type选项，除非文件是符号链接；当制定选项-P或-H时，连接文件所指文件类型是[c]则满足条件，如果指定选项-L，[c]为l才有效，表名查找符号链接；
-context [pattern]:

（3）动作选项。
actions部分一般是执行某些命令，或实现某些功能。这部分是 find 的 command line 部分。

-delete:删除文件，如果删除成功则返回true，如果删除失败，将给出错误信息。"-delete"动作隐含了"-depth"这个option。
-exec [command] ;:注意有个分号";"结尾，该action是用于执行给定的命令。如果命令的返回状态码为0则该action返回true，command后面的所有内容都被当作command的参数，直到分号";"为止，其中参数部分使用字符串"{}"时，它表示find找到的文件名，即在执行命令时，"{}"会被逐一替换为find到的文件名，"{}"可以出现在参数中的任何位置，只要出现，它都会被文件名替换。注意，分号";"需要转义，即"\;"，如有需要，可以将"{}"用引号包围起来。
-exec command {} +:这种-exec动作变种，只允许使用find查找到的文件一次；
-execdir command ;:与-exec相似，区别在于执行command时的working path是从匹配到的文件的所在目录；
-execdir command {} +:与-exec command {} +相似，区别也是在于命令的工作路径；
-fls [file]:总是返回true，将打印的结果输出到指定的文件file中；
-fprint [file]:总是返回true，将找到的文件的全路径输出到指定的文件file中；
-fprint0 [file]:类似于-print0，将结果写入文件file；
-fprintf [file] [format]:类似于-printf,将结果写入指定的文件file；
-ls:总是返回true。将找到的文件以"ls -dils"的格式打印出来，其中文件的size部分以KB为单位；
-ok [command] ;:类似于-exec，但在执行命令前会交互式进行询问；
-okdir [command] ;:类似于-execdir，但在执行命令前会交互式进行询问；
-print:总是返回true。这是默认的action，输出搜索到文件的全路径名，并尾随换行符"\n"。由于在使用"-print"时所有的结果都有换行符，如果直接将结果通过管道传递给管道右边的程序，应该要考虑到这一点：文件名中有空白字符(换行符、制表符、空格)将会被右边程序误分解，如文件"ab c.txt"将被认为是ab和c.txt两个文件，如不想被此分解影响，可考虑使用"-print0"替代"-print"将所有换行符替换为"\0"；
-print0:总是返回true。输出搜索到文件的全路径名，并尾随空字符"\0"。由于尾随的是空字符，所以管道传递给右边的程序，然后只需对这个空字符进行识别分隔就能保证文件名不会因为其中的空白字符被误分解；
-printf [format]:以指定的格式输出匹配的文件名；
-prune:使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。比如：find /apps -path "/apps/bin" -prune -o –print在/apps目录下查找文件，但不希望在/apps/bin目录下查找；

-quit:立即退出，没有子进程会继续运作，但没有更多的路径，在命令行中指定将被处理；

5.常用示例

（1）在/logs目录中查找更改时间在5日以前的文件并删除它们。

find /logs -type f -mtime +5 -exec rm {} ;

（2）列出当前目录及子目录下所有文件和文件夹。

find .

（3）在/home目录下查找以.txt结尾的文件名。

find /home -name "*.txt" 

#同上，但忽略大小写 
find /home -iname "*.txt"

（4）当前目录及子目录下查找所有以.txt和.pdf结尾的文件。

find . \( -name "*.txt" -o -name "*.pdf" \) 
#或
find . -name "*.txt" -o -name "*.pdf"

（5）匹配文件路径或者文件。

find /usr/ -path "*local*"

（6）基于正则表达式匹配文件路径。

find . -regex ".*\(\.txt\|\.pdf\)$" 

#同上，但忽略大小写
find . -iregex ".*\(\.txt\|\.pdf\)$" 

（7）使用否定参数!，找出/home下不是以.txt结尾的文件。

find /home ! -name "*.txt"

（8）根据文件类型进行搜索。

find . -type [类型参数] 
类型参数列表： 
	c - 字符设备文件。
	d - 目录。
	f - 普通文件
	l - 符号链接文件。
	p - 管道文件。
	s - socket。

（9）向下搜索的最大深度限制为3。

find . -maxdepth 3 -type f 

（10）搜索出深度距离当前目录至少2个子目录的所有文件。

find . -mindepth 2 -type f

（11）根据文件时间戳进行搜索,搜索恰好在七天前被访问过的所有文件。

find . -type f -atime 7

（12）搜索超过七天内被访问过的所有文件。

find . -type f -atime +7

（13）搜索访问时间超过10分钟的所有文件。

find . -type f -amin +10

（14）找出比file.log修改时间更长的所有文件。find

find . -type f -newer file.log

（15）根据文件大小进行匹配。

find . -type f -size 文件大小

单元文件大小单元： 
	b —— 块（512字节）
	c —— 字节
	w —— 字（2字节）
	k —— 千字节 
	M —— 兆字节
	G —— 吉字节
	
#搜索大于10KB的文件
find . -type f -size +10k 
	
#搜索小于10KB的文件
find . -type f -size -10k

#搜索等于10KB的文件
find . -type f -size 10k

（16）删除匹配文件,#删除当前目录下所有.txt文件。


find . -type f -name "*.txt" -delete

（17）根据文件权限/所有权进行匹配。

#当前目录下搜索出权限为777的文件
find . -type f -perm 777

#找出当前目录下权限不是644的php文件 
find . -type f -name "*.php" ! -perm 644

#找出当前目录用户tom拥有的所有文件
find . -type f -user tom

#找出当前目录用户组sunk拥有的所有文件
#find . -type f -group sunk

（18）借助-exec选项与其他命令结合使用。

找出当前目录下所有root的文件，并把所有权更改为用户tom
find .-type f -user root -exec chown tom {} \; 
上例中，{} 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名。 

#找出自己家目录下所有的.txt文件并删除
find $HOME/. -name "*.txt" -ok rm {} \; 
上例中，-ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。

#查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中
find . -type f -name "*.txt" -exec cat {} \;> all.txt

#将30天前的.log文件移动到old目录中
find . -type f -mtime +30 -name "*.log" -exec cp {} old \;

#找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来
find . -type f -name "*.txt" -exec printf "File: %s\n" {} \; 

#因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令
-exec ./text.sh {} \; 

（19）搜索但跳出指定的目录,查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk。

find . -path "./sk" -prune -o -name "*.txt" -print

（20）要列出所有大小为零的文件。

find . -empty

（21）find 命令 -perm 的权限的加减号的区别。
首先创建了 4 个具有 suid 和 sgid 属性的文件，因为是大写的 S，所以实际上无效，但不影响我们来说明 -perm 选项指定权限时加减号的区别。

ls -l ./testdir
------S--- 1 root root 0 2016-11-06 10:39 2000
---S------ 1 root root 0 2016-11-06 10:39 4000
---S--S--- 1 root root 0 2016-11-06 10:39 6000
-rwS--S--- 1 root root 0 2016-11-06 10:39 6600

假定我执行

find . -type f -perm 6000

那么我们显然可以得到下面的结果

./60000

这属于完全匹配。如果执行find . -type f -perm -6000呢，其结果是：

./6000
./6600

这里的横杠-表示权限位有1的位置一定要正确匹配，其他权限位无所谓。这里要转成二进制来说，首先6000转成三位的二进制是下面这个样子：

110 000 000 000

这表示前面两个 1 一定要匹配，其他无所谓。那能匹配的就是 6000、6600 这两个文件，其权限二进制转换过来分别是：

110 000 000 000
110 110 000 000

而如果是执行find . -type f -perm +6000呢？我们看看结果：

./6000
./2000
./4000
./6600

+号的意思是，每一组的权限，只要有一个组拥有给定的权限，就满足条件，也就是说前2位中，只要有一个1就行，所以上面的都符合要求，因为翻译成二进制变成：

110 000 000 000
010 000 000 000
100 000 000 000
110 110 000 000

所以，从上面的结果可以看出，命令find . -type f -perm +6000就是指定目录下所有具有suid或者sgid属性的文件。

注意：find的 +mode已经废弃，建议使用/mode来代替+mode。

（22）删除文件大小为零的文件。

find ./ -size 0 -exec rm {} \;

#或
find ./ -size 0 -ok rm {} \;

#或
rm -i find ./ -size 0

#或
find ./ -size 0 | xargs rm -f

-ok和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。例如find . -name "*.conf" -mtime +5 -ok rm {} \;，在当前目录中查找所有文件名以.LOG结尾、最近更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。

●grep 命令：
1.命令简介
grep（Globally search a Regular Expression and Print）是 GNU 开发的一款免费开源的文本搜索工具。
grep 家族包括 grep、egrep 和 fgrep，其功能是在给定的文件中查找一个指定格式或者内容的字符串，并将匹配的字符串所在行打印出来。如果不指定任何文件名称或给定的文件名为连字符 -，则从标准输入设备读取文本，然后在这些文本中进行查找。grep 支持正则表达式表示待搜索的文本，完成文本匹配。
2.命令格式

grep [OPTION...] PATTERNS [FILE...]
grep [OPTION...] -e PATTERNS ... [FILE...]
grep [OPTION...] -f PATTERN_FILE ... [FILE...]

3.选项说明

注意，长选项的参数对于短选项也是必须的。

匹配器选择：
-E,--extended-regexp
	使用扩展正则表达式解释匹配模式
-F, --fixed-strings
	将匹配模式看作固定字符串而不是正则表达式
-G, --basic-regexp
	使用基本正则表达式解释匹配模式
	
匹配控制：
-e, --regexp=PATTERNS
	匹配模式。如果使用此选项多次或与 -f（--file）选项组合使用，搜索给定的所有模式。此选项可用于保护以 “-” 开头的模式
-f, --file=FILE
	将匹配模式写在文件中，文件中一行内容对应一个匹配模式
-i, --ignore-case
	忽略字符大小写
-v, --invert-match
	反向选择，显示不包含匹配文本的所有行
-w, --word-regexp
	整个单词匹配才算匹配
-x, --line-regexp
	整行匹配才算匹配
-y
	过时的 -i 同义词

一般输出控制：
-c, --count
	只输出匹配的行数，不是匹配字符串的个数
--color, --colour[=WHEN]
	将找到的关键词加上颜色显示。WHEN 可取值 never、always 或 auto
-L, --files-without-match
	不输出包含匹配模式文件的文件名
-l, --files-with-matches
	只输出包含匹配模式文件的文件名
-o, --only-matching
	只显示匹配的字符串，并以单独行输出
-q, --quiet, --silent
	静默模式，不显示任何信息到标准输出
-s, --no-messages
	不显示不存在或无匹配文本的错误信息

输出行前缀控制：
-b, --byte-offset
	在匹配的行之前，标示出该行第一个字符的位编号，即字符在文本中的字节偏移下标，包括换行符
-H, --with-filename
	查询多文件时显示文件名（默认选项）
-h, --no-filename
	查询多文件时不显示文件名
-n, --line-number
	显示匹配行及行号
-T, --initial-tab
	使用 Tab 使匹配行对齐
-u, --unix-byte-offsets
	以 Unix 样式进行字节偏移。使用该选项，使 grep 产生的结果与在 Unix 机器上相同，此选项必须与 -b 同时使用，否则没有效果，也必须要在 MS-DOS 和 MS-Windows 平台上使用
-Z, --null
	文件名与匹配行之间使用空字符。grep 默认会在每个输出前打印文件名，文件名与匹配行之间会有一个冒号隔开，-Z选项告诉grep不要使用冒号了，使用一个NUL字符

上下行控制：
-A, --after-context=NUM
	后紧跟数字，为 after 之意。除了列出匹配字符串所在行之外，后续的 NUM 行也列出来
-B, --before-context=NUM
	后紧跟数字，为 before 之意，显示匹配行以及该行之前指定行数的内容
-, -C, --context=NUM
	显示匹配行以及该行上下指定行数的内容

文件与目录选择：
-a, --text
	将 binary 文件以 text 文件的方式处理，等同于 --binary-files=text 选项
-D, --devices=ACTION
	如果输入文件是设备，命名管道（FIFO）或套接字，则使用指定动作处理它。默认情况下，为读取操作（read），这意味着读取设备就像它们是普通文件。如果操作是跳过（skip），设备将被悄悄跳过
-d, --directories=ACTION
	当指定要查找的是目录而非文件时，使用指定的操作处理。动作有：read（默认）像普通文件一样读取目录；skip：忽略指定目录；recurse：递归读取指定目录下的所有文件，此操作等同于-r选项。
-I
	忽略二进制文件。等同于 --binary-files=without-match
-R, -r, --recursive
	递归搜索给定目录下的所有文件。等价于 -d recurse

通用程序信息：
--help
	显示帮助信息并退出
-V, --version
	显示版本信息并退出

4.常用示例

（1）统计字段出现次数。

grep -o [pattern] [finename...]|wc -l

命令解释：
grep -o 中的选项 -o 是 only-matching 缩写。Print only the matched(non-empty) parts of a matching line, with each such part on a separate output line。以单独的行输出匹配的每一个模式字符串。

wc -l 统计输入的行数。就可以知道这个要统计的字段出现的次数了。

（c）搜索指定范围的数字。比如查询包含540-600的行。

grep '5[4-9][0-9]\|600' [filename...] 

之所以竖杠 | 需要加上反斜杠进行转义，是因为竖杠 | 在 Shell 中是特殊字符，表示管道命令。可以使用 -E 选项显示指明为正则表达式，那么就不需要对竖杠 | 进行转义。

（2）递归搜索当前目录下的所有文件。

grep -r "lvlv" .

（3）显示所有以d开头的文件中包含test的行。

grep 'test' d*

（4）打印在aa，bb，cc文件中匹配test的行，并显式行号。

grep -n 'test' aa bb cc

（5）打印aa中包含有至少5个连续小写字符的字符串的所有行

grep '[a-z]\{5\}' aa

注意，这里必须使用双引号或者单引号将查找pattern包围。单引号与双引号的区别主要有：
（1）单引号’‘是全引用，被单引号括起的内容不管是常量还是变量都不会发生替换；
（2）双引号""是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量的内容。一般常量用单引号’'括起，如果含有变量则用双引号""括起来。但是也有意外，比如说查找特殊字符反斜杠\使用：grep '\' ./*则会报grep: Trailing backslash错误，需要使用grep '\\' ./*才可以。

（6）统计文件file中含有指定字符串aaa的的行数。

grep aaa file | wc -l

注意： grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。

（6）grep使用多个条件的或查询。

#方法一：使用符号\|
grep "pattern1\|pattern2" filename

#方法二：使用-E选项，用扩展正则表达式解释匹配模式
grep -E "pattern1|pattern2" filename

#方法三：使用-e选项指定多个匹配模式
grep -e "pattern1" -e "pattern2" filename

（7）grep 使用多个条件的与查询。

# 使用管道命令
grep "pattern1"  filename | grep "pattern2"

●uname 命令：
1.命令简介

uname 命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。
2.命令格式

uname [OPTION]...

uname 未指定任何选项时，默认选项为 -s，即显示操作系统内核名称。
3.选项说明

-a, --all
	显示主机全部信息，以下面的顺序展示
-s, --kernel-name
	显示内核名称
-n, -nodename
	显示在网络上的主机名称
-r, --kernel-release
	显示操作系统内核发行版本号
-v, --kernel-version
	显示内核版本号
-m, --machine
	显示机器硬件架构
-p, --processor
	显示处理器类型或者 unknown
-i, --hardware-platform
	显示硬件平台或 unknown
-o, --operating-system
	显示操作系统名称
--help
	显示帮助
--version
	显示版本信息

4.常用示例

（1）显示主机名称。

uname -n
TENCENT64.site

（2）显示操作系统名称。

uname -o
GNU/Linux

（3）显示操作系统内核名称。

uname -s
Linux

（4）显示操作系统内核版本。

uname -r
3.10.104-1-tlinux2_kvm_guest-0022.tl2

#或
cat /proc/version
Linux version 3.10.104-1-tlinux2_kvm_guest-0022.tl2 (root@TENCENT64.site) (gcc version 4.8.2 20140120 (Red Hat 4.8.2-16) (GCC) ) #1 SMP Wed Dec 14 10:21:52 CST 2016

（5）显示主机全部信息。

uname -a
Linux TENCENT64.site 3.10.104-1-tlinux2_kvm_guest-0022.tl2 #1 SMP Wed Dec 14 10:21:52 CST 2016 x86_64 x86_64 x86_64 GNU/Linux

●vim 命令:
1.简介

vim 是 Linux 操作系统中最通用的全屏幕文本编辑器，是 vi 的增强版（vi iMproved），与 vi 完全兼容，且扩充了很多功能。

vim 编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用 vim 编辑器就必须熟练掌握这两种模式的切换。默认情况下，打开 vim 后自动进入命令模式。从编辑模式切换到命令模式使用 ESC 键，从命令模式切换到编辑模式使用 A、a、O、o、I、i 键。
2.命令格式

vim [OPTIONS] [FILE...]
vim [OPTIONS] -
vim [OPTIONS] -t TAG
vim [OPTIONS] -q [ERRORFILE]

[FILE...]表示一系列使用 vim 编辑的文件，使用:next命令可以向前切换所编辑的文件，使用--可以向后切换。这是 vim 常用启动格式；

-：表示待编辑的文件从标准输入读取；

-t TAG：要编辑的文件和光标的初始位置取决于一个标签，一种 goto 标签。标签在标签文件中查找，与标签关联的文件成为当前文件并执行关联的命令。主要用于 C 程序，在这种情况下 TAG 可以是函数名，其结果是包含该函数的文件成为当前文件，并且光标位于函数的开头。参见：:help tag-commands；

-q [ERRORFILE]：使用 quickFix 模式启动 vim，文件 ERRORFILE 将被读取并显示第一个错误。如果 ERRORFILE 省略，则默认为 AztecC.Err（Amiga 系统）或 errors.err（其它系统）。关于 quickFix 模式说明，可以使用:help quickfix查看。
3.选项说明

+NUM
	打开文件时光标跳转到由 NUM 指定的行首
+/PAT
	打开文件时光标跳转到匹配的模式字符串 PAT
+, -c CMD
	在完成对第一个文件的读取后，执行给出的指令
-b
	以二进制模式打开文件，用于编辑二进制文件和可执行文件
-C
	以兼容模式运行 vim，使 vim 的表现更像 vi，即使存在 .vimrc 文件
-d
	以 diff 模式打开文件，当多个文件编辑时，显示文件差异部分
-e
	进入 Ex 模式，即进入冒号开头的末行模式。ex是Unix编辑器
-E
	进入增强 Ex 模式，就像执行命令 exim
-l
	使用 lisp 模式，打开 lisp 和 showmatch
-m
	取消写文件功能，重设 write 选项。你仍然可以修改缓冲内容，但是不可以写入文件
-M
	关闭修改功能
-N
	非兼容模式运行 vim，这会使 vim 表现的更好，但是可能会存在与 vi 不兼容的情况，即使存在 .vimrc 文件
-n
	不使用 swap file，这可能会导致在 vim 意外崩溃的情况下无法恢复未保存的内容
-o [N]
	以上下排列方式同时打开 N 个 vim 窗口，如果未指定 N ，则为每一个文件单独打开一个窗口
-O [N]
	以左右下排列方式同时打开 N 个 vim 窗口，如果未指定 N ，则为每一个文件单独打开一个窗口
-R
	以只读方式打开文件
-r
	列出 swap file
-r FILE
	以指定的交换文件来恢复崩溃的编辑会话。交换文件名后缀为.swp
-s
	安静模式，与 -e 选项结合使用
-u VIMRC
	使用指定的 vimrc 文件中的命令来初始化 vim，所有其它的初始化操作将被跳过。可以给定“NONE”来跳过所有的初始化
-U GVIMRC
	使用指定的 gvimrc 文件中的命令来初始化 GUI，所有其它的 GUI 初始化操作将被跳过。可以给定 “NONE” 来跳过所有的 GUI 初始化
-V [N]
	以冗余模式执行 vim，打印 vim 读取了哪些配置文件 vimrc。可选的数字 N 表示冗余级别，数值越大级别越高，取值范围是 0~10，默认是 10
-x
	写文件时进行加密，会提示输入加密密钥
-h, --help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.内置命令

vim 提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号 : 开头输入。常用内置命令如下：

Ctrl+u：向下滚动半屏
Ctrl+d：向上滚动半屏
Ctrl+f：向下滚动一屏
Ctrl+b：向上滚动一屏
Ctrl+e：向下滚动一行
Ctrl+y：向上滚动一行
Enter：回车向下滚动一行
Esc：从编辑模式切换到命令模式
ZZ：命令模式下保存当前文件所做的修改后退出 vim
:[行号]：光标跳转到指定行的行首
:$：光标跳转到最后一行的行首
gg:跳转到首行;
G:跳转到尾行
Ctrl+g:显示总行数
x, X：删除一个字符或选中的内容。当删除一个字符时，x 删除光标后的，X 删除光标前的。删除即剪切
d：删除选中的文本，删除即剪切
D：删除从当前光标到光标所在行尾的全部字符。删除即剪切
dd：删除光标所在行的整行内容。删除即剪切
ndd：删除当前行及其后n-1行，n为一个数字。删除即剪切
y:复制选中的文本
y0：复制光标前一个字符到行首的内容
y$：复制光标后一个字符到行尾的内容
yh：复制光标前的1个字符
yl：复制光标后的1个字符
nyh：复制光标前的n个字符，比如4yh复制光标前的4个字符
nyl：复制光标后的n个字符，比如4yl复制光标后的4个字符
yy：复制光标所在的当前行
nyy：复制当前行以及其后n-1行，n为一个数字；
p：小写p，粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方
P：大写P，粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方；
/[字符串]：向后搜索，支持正则表达式。用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示。键入字符 n 跳转到下一个，N 跳转到前一个
?[字符串]：向前搜索，支持正则表达式。用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示。键入字符 n 跳转到下一个，N 跳转到前一个
:a,bs/F/T：替换文本操作，将a到b行之间第一个F换成T字符串。其中，":s/"表示进行替换操作。不指定a和b，则默认为当前行；如果b为$,表示替换到末行；如果是a,b为%，即:%s/F/T,表示从第一行替换至末行
:a,bs/F/T/g:替换文本操作，替换第a行到b行，每一行所有F为T。a,b的取值规则同上一条;
a：在当前字符后添加文本
A：在当前行末添加文本
i：在当前字符前插入文本
I：在当前行首插入文本
no：在当前行后面插入n个空行，n为具体的数值
nO：在当前行前面插入n个空行，n为具体的数值
:wq：执行存盘退出操作
:w：执行存盘操作
:w!：执行强制存盘操作
:q：执行退出操作
:q!：执行强制退出操作
:e [文件名]：打开并编辑指定名称的文件
:n：如果同时打开多个文件，则继续编辑下一个文件
:f：显示当前的文件名、文件总行数、光标所在行号占总行数的比例
:set number：在最左端显示行号
:set nonumber：在最左端不显示行号
jkhl或方向键：光标移动快捷键，分别为上下左右
u：撤销
ctrl+r:反向撤销
v+移动光标：使用v进行选择模式，移动光标可选择文本
w：word，右移一个单词，光标停留在单词首部
e：end，右移一个单词，光标停留单词的尾部
b：back，左移一个单词，光标停留在单词首部
^ 或 (:移至行头
$ 或 ):移至行尾
gd：高亮显示光标所在的单词

5.vim 需知
5.1 vim 的四大模式

众所周知，vim 里面最具特色的东西就是它可以切换模式，那什么是模式呢？可以简单的理解为在不同的模式下面按相同的键而得到不同的效果。比如 vim 在插入模式下面连按两次 d，那么就会在光标位置插入两个字母 d，如果在正常模式下面连按两次 d，那么光标所在当前行将会被删除。

既然说是 vim 的四大模式，那么 vim 到底有那四大模式呢？

    正常模式（normal mode）
    可视模式（visual mode）
    插入模式（insert mode）
    命令行模式（command-line mode）

用户可以通过按 ESC 在各个模式之间进行切换。关于 vim 的模式说明，可以打开 vim 后键入 :help mode 来查看。

    正常模式 （command mode）

不管用户处于何种模式，只要按一下 ESC 键，即可进入正常模式。启动 vim 命令默认情况下进入正常模式。

在正常模式下，用户可以输入各种合法的 vim 命令，用于管理自己的文档。此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的 vim 命令，则 vim 在接受用户命令之后完成相应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是 vim 的合法命令，vim 会响铃报警。

    可视模式（visual mode）

可视模式简单来说就是选中一块编辑区域，然后在上面执行一些操作，比如删除，替换，改变大小写等。

在正常模式按下 v（逐个字符选择文本）、 V（逐行选择文本）、Ctrl+v（按照块的方式选择文本），可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。

    插入模式 （insert mode）

在正常模式下输入插入命令 i（insert）、附加命令 a （append）、打开命令 o（open）、修改命令 c（change）、取代命令 r（replace）或替换命令 s（substitute）都可以进入插入模式。在该模式下，用户输入的任何字符都被Vi当做文件内容保存起来，并将其显示在屏幕上。在文本输入过程中，若想回到命令模式下，键入 ESC 键即可。

    命令行模式 （command-line mode）

命令行模式又称为 ex 模式。ex 是 EXtended 的简称，是 Unix 系统上的纯文本编辑器。ex 命令可启动 vim，执行 ex 命令，并键入 visual 就可以进入 vim 的正常模式。

vim 和 ex 编辑器的功能是相同的，二者主要区别是用户界面。在 vim 中，命令通常是单个键，例如 i、a、o 等；而在 ex 中，命令是以按回车键结束的行。在正常模式下，用户按冒号即可进入命令行模式，此时 vim 会在显示窗口的最后一行显示一个冒号作为命令行模式的提示符，等待用户输入命令。多数文件管理命令都是在此模式下执行的（如把编辑缓冲区的内容写到文件中等）。命令执行完后，vim 自动回到正常模式。
5.2 vim 相关编码选项

文件的编码和显示是一个令人头痛的东西，真希望这个世界上只存在utf-8编码，那就没那么痛苦了。vim编码配置涉及4个选项，分别是encoding 、fileencoding、fileencodings和termencoding，四者对应的简写分别为enc、fenc、fencs和tenc。
（1）encoding
encoding是vim内部使用编码。vim运行时，其菜单、标签、以及各个缓冲区统一使用encoding作为字符编码。

（2）fileencoding
fileencoding为文件采用的编码方式。使用vim打开文件后，可以使用末行命令:set fenc=utf-8将文件编码方式更改为UTF-8，注意，前提是vim打开文件时已经正确识别出文件编码，即未出现乱码。

（3）fileencodings
fileencodings用于vim在打开文件的时候进行解码的猜测列表。文件编码没有百分百正确的判断方法，所以vim只能猜测文件编码。~/.vimrc里面fileencodings的设置一般为

set fileencodings=utf-8,gb18030,latin1

（4）termencoding
终端所使用的文本编码。这个选项的值用于告诉VIM终端使用了哪种文本编码用于文本输入和显示。如果该值为空，那么它被设置为encoding的值。
5.3 vim 读写文件时编码转换过程

（1）读文件
vim打开文件时，需要将磁盘文件内容载入缓存，并将缓存中的字符转为换终端编码，通过网络传输的方式，传输到终端进行显示。两个转换环节，有一个出错都会出现乱码。

fileencoding -> encoding -> termencoding

（2）写文件
通过终端编辑文件时，字符编码转换过程是vim读文件的逆过程。

termencoding -> encoding  -> fileencoding 

注意：使用vim读写文件时为避免出现乱码，至关重要的一点就是终端，比如SecureCRT或XShell的编码设置要与vim的termencoding设置相同，如果不同还是还是会出现乱码，尽管vim已经采用正确的编码格式解析了文件。比如将XShell设置为UTF-8。
在这里插入图片描述
6.vim 常见用法

（1）vim 查看文件编码

:set fileencoding
或者简写
:set fenc

可显示文件编码格式。这个命令有致命的缺点。原因是只有正常显示文件内容时，该命令显示的文件编码格式才是文件本身的编码格式。因为该命令显示的编码格式并不是文件本身的编码格式，而是当前打开该文件所使用的编码格式。因此，这个命令在网上的说明大都是不准确的，特此说明。

（2）修改编码类型
使用vim修改：

:set fileencoding=gbk
#或者
:set fenc=gbk

使用iconv来修改文件编码：

iconv -f encoding -t encoding inputfile

#比如将一个GBK编码的文件转换成UTF-8编码
iconv -f GBK -t UTF-8 file1 -o file2UTF-8

iconv的参数说明：

-f, --from-code=名称，原始文本编码
-t, --to-code=名称，输出编码
-l, --list 列举所有已知的字符集
-c 从输出中忽略无效的字符
-o, --output=FILE，输出文件
-s, --silent，关闭警告
--verbose，打印进度信息

（3）vim 指定编码类型浏览文件
如果知道了文件的编码类型，可显示指定编码类型来解析文件，而不用vim去猜测文件的编码类型，事实上猜测的往往是错误。命令如下：

vim file_name -c "e ++enc=utf-8"

或者在使用 vim 打开文件之后，在末行模式使用如下命令：

:e ++enc=utf-8

（4）vim 新增空白行
新增一行空白，在命令行模式下输入 o。如果想添加三行的话，键入 3o ，如果想添加 n 行则键入 n 个 o。如果键入 3o 后立即退出插入模式的话，就可以添加三个空白行。如果输入一些内容再退出，可以添加三行相同的内容。

如果想在每一行执行相同的命令，在 vim 里可以用 :g 实现。一般的语法是：

:g/pattern/cmd

它表示在匹配 /pattern/ 这个正则表达式的行上执行 cmd 命令（也称冒号命令）。而 /^/ 这个表达式，用于匹配行首。因为任何一行都有行首，你的要求就很容易实现了：

:g/^/norm 3o

norm这个命令的意思是，把后面的参数看成是在普通模式下的按键，即命令模式下的按键。

（5）vim 高亮显示选中的单词
将光标移到需要高亮显示的单词上，在命令模式下输入gd，那么就可以将当前的单词在当前文本中全部高亮显示，如下图所示，高亮显示dwBeInvitedUinLen。
这里写图片描述
（6）vim 输入特殊字符
有三种方法，第一种是使用字符编码，第二种是使用二合字母（digraph），三是使用快捷键（Ctrl+字母）。

使用字符编码：
vim可以用字符编码插入任意字符，使用此功能可以方便地输入键盘上找不到的字符。使用步骤如下：
（1）编辑模式下按下Ctrl+v；
（2）如果是ASCII字符，则输入三位十进制ASCII码值，不足三位，前补0。比如输入大写字母A，则输入065；如果是Unicode字符，则输入“u+四位十六进制码值”。比如输入大写字母A，则输入u0041。

更多详情内容可参见vim的帮助文档，末行模式输入：h i_ctrl-v_digit。

使用二合字母（digraph）：
二合字母顾名思义，使用两个字母的组合来标识特殊字符。使用步骤如下：
（1）编辑模式下按下Ctrl+k；
（2）输入特殊字符对应的二合字母。可以使用:dig或:h digraph-table查看对应二合字母。比如回车符（Carriage Return） 的二合字母是CR。

Ctrl+字母：
在vim中，使用:set list显示所有字符时，经常会看到有^I、^M等符号，代表的字符可以使用:h digraph-table查看，特殊字符列表如下：
这里写图片描述
在vim的编辑模式下，可使用“Ctrl+字母”进行输入，例如使用"Ctrl+i"或"Ctrl+I"可以输入字符^I（Tab），使用"Ctrl+m"或"Ctrl+M"可以输入字符^M（回车）。

（7）vim其它常见操作

#显示行号
:set number

#取消行号
:set nonu

#取消高亮显示查找后的字符串
:nohl

#显示换行符
:set list

#不显示换行符 
:set nolist 

7.小结

vim 仍有很多未知的东西等待我们去发现，如果 vim 使用过程中有问题，欢迎留言，一同探讨解决进步。

●iconv 命令:
1.命令简介

iconv命令是用来转换文件的编码方式，比如它可以将UTF8编码的转换成GB18030的编码。Linux下的iconv开发库包括iconv_open,iconv_close,iconv等C函数（非标准库函数），可以用来在C/C++程序中很方便的转换字符编码。
2.命令格式

iconv -f FROMCODE -t TOCODE FILE ...

3.选项说明

iconv 命令将给定编码的文件，转换为指定编码的内容，结果默认输出到标准输出，可以使用--output或-o输出到指定文件。

-c 
	静默丢弃不能识别的字符，而不是终止转换
-f, --from-code=CODE
	指定待转换文件的编码。
-t, --to-code=CODE
	指定目标编码
-l, --list
	列出已知的字符编码。
-o, --output=FILE
	列出指定输出文件，而非默认输出到标准输出
-s, --silent
	关闭警告。
--verbose
	显示进度信息
-?, --help
	显示帮助信息
--usage
	显示简要使用方法
-V, --version
	显示版本信息

-f 和 -t 所能指定的合法编码可以在 -l 选项的结果中查看。
4.常用示例

（1）将 GBK 文件转换为 UTF8 文件。

iconv -f gbk -t utf8 inputFile.txt -o outputFile.txt.utf8

（2）转换时报如下错误：“iconv: 未知 126590 处的非法输入序列”。此时使用-c选项。

iconv -c -f gbk -t utf8 inputFile.txt -o outputFile.txt.utf8

●free 命令:
1.简介

free 命令用于显示系统内存使用情况，包括物理内存（Physical Memory）、虚拟内存（Swap Memory）、共享内存（Shared Memory）以及内核使用的缓冲（Buffers）与缓存（Cached）大小。在 Linux 系统监控的工具中，free 命令经常被用到。

free 命令的所有输出值都是从 /proc/meminfo 中读取的。
2.命令格式

free [-b | -k | -m] [-o] [-s delay ] [-t] [-l] [-V]

3.选项说明

-b：以Byte为单位显示内存使用情况；
-k：以KB为单位显示内存使用情况；
-m：以MB为单位显示内存使用情况；
-g：以GB为单位显示内存使用情况；
-o：不显示缓冲区调节列；
-s [间隔秒数]：以指定间隔时间持续观察内存使用状况；
-t：显示内存总和列；
-l：显示详细的低内存和高内存统计;
-V：显示版本信息。

4.常用示例

（1）使用 GB 为单位显示内存使用情况。

[root@test ~]#free -g
             total       used       free     shared    buffers     cached
Mem:            62         61          0          0          2         56
-/+ buffers/cache:          2         59
Swap:            1          0          1

第一行为各列的名称，其释义如下：

total：物理内存总大小；
used：物理内存已使用大小；
free：物理内存空闲大小；
shared：系统中分配的共享内存大小，此列已经 deprecated，数值一般为 0。当然在一些系统上也可能不是0，主要取决于free命令是怎么实现的。如果为0，要想查看系统分配的共享内存大小，请查看 /proc/meminfo的 Shmem 一项；
buffers：系统分配的buffer大小；
cached：系统分配的cache大小。包含了共享内存和tmpfs内存文件系统占用的内存。这两部分内存之和可通过/proc/meminfo的Shmem字段直接获取。

其中 total = used + free，理论空闲内存大小 free2=free1+buffers+cached=58GB，其中 free2 表示 free 列第二行的取值。实际上，cached 中的共享内存大小和 tmpfs 内存文件系统大小也是实际被使用的内存，所以真正可用内存大小 real free=free1+buffers+cached-Shmem。Shmem 大小具体参见 /proc/meminfo 的 Shmem 字段的取值。

第二行表示减去与增加 buffers 和 cache 大小，分别对应物理内存的理论已使用和理论空闲大小。理论空闲内存大小的计算方法如上文所述，理论已使用大小 used2=used1-（buffers+cache）=3。为什么不是显示的 2呢，因为这里存在四舍五入，导致显示有一定误差，使用 MB 为单位来显示，数值就能对的上了。

第三行 swap 表示交换分区（即虚拟内存）的大小。如果 swap 内存有被使用，则说明系统内存不够使用，需要进行扩容。

（2）显示 high memory 使用情况。

[root@test ~]#free -gl
             total       used       free     shared    buffers     cached
Mem:            62         61          0          0          2         56
Low:            62         61          0
High:            0          0          0
-/+ buffers/cache:          2         59
Swap:            1          0          1

使用-l选项可以查看高低内存使用情况，发现低内存与 Mem 的使用情况相同，高内存全部为零，为什么会这样呢？先看一下什么是 high memory 和 low memory。

32 位的 CPU，最大寻址范围为 2^32 - 1 也就是 4G 的线性地址空间。Linux 简化了分段机制，使得虚拟地址与线性地址总是一致的。Linux 一般把这个 4G 的地址空间划分为两个部分：其中 0～3G 为用户程序地址空间，虚地址 0x00000000 到 0xBFFFFFFF，供各个进程使用；3G～4G为内核的地址空间，虚拟地址 0xC0000000 到 0xFFFFFFFF，供内核使用。

Linux 内核采用了最简单的映射方式来映射物理内存，即把物理地址＋PAGE_OFFSET按照线性关系直接映射到内核空间。PAGE_OFFSET 大小为 0xC0000000。但是 Linux 内核并没有把整个 1G 空间用于线性映射，而只映射了最多 896M 物理内存，预留了最高端的 128M 虚拟地址空间给 IO 设备和其他用途。所以，当系统物理内存较大时，超过 896M 的内存区域，内核就无法通过线性映射直接访问了。这部分内存被称作 high memory。相应的可以映射的低端物理内存称为 low memory。

那 Kernel 就永远无法访问到超过 896M 的内存了吗？不是的，Kernel 已经预留了 128M 虚拟地址，我们可以用这个地址来动态地映射到 high memory，从而访问 high memory。所以预留的 128M 除了映射 IO 设备外，还有一个重要的功能是提供了一种动态访问 high memory 的一种手段（kmap 主要就是干这个的，当然还有 vmalloc）。

结论：
（1）high memory 针对的是物理内存，不是虚拟内存。
（2）high memory 也是被内核管理的（有对应的page结构），只是没有映射到内核虚拟地址空间。当内核需要分配high memory时，通过kmap等从预留的地址空间中动态分配一个地址，然后映射到high memory，从而访问这个物理页。high memory 映射到内核地址空间一般是暂时性的映射，不是永久映射。
（3）high memory 和 low memory一样，都是参与内核的物理内存分配，都可以被映射到内核地址空间，也都可以被映射到用户地址空间。
（4）物理内存<896M时，没有 high memory，因为所有的内存都被kernel直接映射了。
（5）64位系统下不会有 high memory，因为64位虚拟地址空间非常大（分给kernel的也很大），完全能够直接映射全部物理内存。

因为测试的机器是 64 位机器，所以不存在 high memory，故全部为零。
5.常见问题
5.1 buffers 与 cached 的区别

（1）buffers（缓冲）
buffer是用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。缓冲（buffers）是为磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。

buffers 存放即将写到磁盘（块设备）的数据，缓冲满了一次性写入，减少对磁盘的写操作（内存 -> 磁盘）。

（2）cached（缓存）
cache 经常被用在磁盘的 I/O 请求上，如果有多个进程都要访问某个文件，于是该文件便被做成 cache 以方便下次被访问，这样可提供系统性能。

缓存是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。其中的数据会根据读取频率进行组织，把最频繁读取的内容放在最容易找到的位置，把不再读的内容不断往后排，直至从中删除。

cached 存放从磁盘读出的数据，缓存起来，减少对磁盘的读操作（磁盘 -> 内存）。

buffers 和 cached，两者都是 RAM 中的数据。简单来说，buffers 缓存即将要被写入磁盘的数据，cached 缓存从磁盘中读取的数据。
5.2 buffers 与 cached 的释放

buffers 主要用于缓存文件系统中的元数据信息（dentries、inodes），cached 主要用于缓存文件系统中的pages 信息，必要时 buffers、cached 所占内存可被回收用于其他程序。

设置以下值可以将文件系统缓存的 clean pages、dentries、inodes 移出内存，腾出可用内存：

# To free pagecache:  
echo 1 > /proc/sys/vm/drop_caches  
  
# To free dentries and inodes:  
echo 2 > /proc/sys/vm/drop_caches  
  
# To free pagecache, dentries and inodes
echo 3 > /proc/sys/vm/drop_caches  

以上操作并非具有破坏性，因为他们并不会将 dirty caches 释放掉，为了获得更多的可用内存，用户可以先执行 sync 操作将 dirty caches 写回磁盘，使之变为 clean caches（cache中的内容还是保留在内存中），然后再设置 drop_caches。

这里释放完成后，发现 cached 数值仍然不为 0，原因是 free 命令计算的 cached 包含了共享内存的大小，共享内存需要使用ipcrm [ -M key | -m id ]命令来释放。buffers 的数值也不为 0，因为系统时刻在运行着，释放完后，buffers 又被分配出去。

●fdisk 命令:
1.命令简介

fdisk 命令用于创建和维护磁盘分区表。

它采用传统的问答式界面，而不是类似于 fdisk 的 cfdisk 的互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。它兼容 DOS 类型的分区表、BSD 或者 SUN 类型的磁盘列表。
2.命令格式

fdisk [-uc] [-b sectorsize] [-C cyls] [-H heads] [-S sects] device
fdisk -l [-u] [device...]
fdisk -s partition...
fdisk -v
fdisk -h

3.选项说明

-b {sectorsize}
	指定硬盘扇区大小，可用数值为512, 1024, 2048 or 4096
-c
	关闭DOS兼容模式
-C {cyls}
	指定硬盘的柱面数（number of cylinders）
-H {heads}
	指定硬盘的磁头数（number of heads），当然不是物理数值，而是作用于分区表。合理取值是255和16
-S {sects}
	指定每个磁道的扇区数，当然不是物理数值，而是用于分区表。一个合理的数值是63；
-l
	列出指定设备的分区表，然后退出。如果没有给定设备，则使用在/proc/partitions（如果存在）中提到的那些设备；
-u
	在列出分区表时，给出扇区大小而不是柱面大小
-s {partition}
	以块（block）为单位，显示指定分区的大小
-v
	显示版本信息
-h
	显示帮助信息

阅读以上选项说明，需要注意以下几个问题：

（1）块（block）与扇区（sector）的区别。
扇区是对硬盘而言，扇区是硬盘的最小存储单位，块是对文件系统而言，块是文件系统最小存取单位。一般而言，一个扇区大小为512B，一个块大小为4KB，一个block是由连续的8个sector组成。

（2）理解上面选项的含义，需了解磁盘的物理组成结构与相关概念，例如sector、cylinder、head等组成部件的具体含义，可参见硬盘的存储原理和内部架构 。
4.常用示例

（1）列出指定设备的分区情况。

fdisk -l /dev/sda

Disk /dev/sda: 300.0 GB, 299966445568 bytes
255 heads, 63 sectors/track, 36468 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0009808c

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1        1306    10485760   83  Linux
/dev/sda2            1306        1566     2088960   82  Linux swap / Solaris
/dev/sda3            1566        4177    20971520   83  Linux
/dev/sda4            4177       36469   259387694   83  Linux

对fdisk -l相关数值的解释如下：
第一行中说明硬盘 /dev/sda 总大小为 300.0 GB；

第二行中 heads 表示硬盘磁头数，也是盘面数，因为磁头数等于盘面数。随后63 sectors/track说明每条磁道分63个扇区。共 36468 个柱面，柱面是分区的最小单位；

第三行说明每个柱面单位是 8225280 byets，柱面单位大小=磁头数*每条磁道的扇区数*扇区大小=255*63*512B=8225280B；

第四行说明扇区的大小是512B；

第五行说明硬盘最小与最佳的存储单位是512 bytes，等于扇区大小，因为扇区是硬盘的最小存储单位；

第六行说明硬盘标识符是 0x0009808c。

第七行表示每个分区相关参数的含义。

Device：分区名称；
Boot：是否是活动分区。活动分区只能是主分区，一个硬盘只能有一个活动的主分区；一个硬盘的主分区与扩展分区总和不能超过4个。硬盘分区遵循着“主分区→扩展分区→逻辑分区”的次序原则，而删除分区则与之相反。
	主分区：一个硬盘可以划分多个主分区，但没必要划分那么多，一个足矣。
	扩展分区：主分区之外的硬盘空间就是扩展分区，
	逻辑分区：是对扩展分区再行划分得到的。
Start：分区柱面的开始下标；
End：分区柱面的结束下标；
Blocks：该分区的块数量。当前文件系统block=2*sector，所以块数量=（End-Start）*柱面的扇区数/2=1305*255*63/2=10482412.5；
Id：各种分区的文件系统不同，如有ntfs分区，fat32分区，ext3分区，swap分区等。每一种文件系统都有一个代号，对应这里的Id。常见的文件系统ID有：
	f：FAT32 Extend,只限于扩展分区。
	86：NTFS。
	7：HPFS/NTFS
	b：FAT32。
	83：Linux Ext2。
	82：Linux 交换区。
System：文件系统名称。

总结：

一个磁盘的大小=一个柱面大小*柱面的总数=磁头数量*每个磁道上的扇区数*一个扇区大小*柱面总数

即：

磁盘大小=8225280*36468=299959511040 bytes=299GB=255*63*512*36468

上例中显示出的硬盘大小与实际计算出来的有少许出入，这个不必太在意，Linux显示的这些数据不会十分精确。

（2）对指定设备进行分区并挂载。
第一步，选择要进行操作的磁盘，进入问答式界面。

fdisk /dev/sdb

第二步，输入m列出可以执行的命令。

Command (m for help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)

第三步，输入p列出磁盘目前的分区情况。

Disk /dev/sda: 300.0 GB, 299966445568 bytes
255 heads, 63 sectors/track, 36468 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0009808c

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1        1306    10485760   83  Linux
/dev/sda2            1306        1566     2088960   82  Linux swap / Solaris
/dev/sda3            1566        4177    20971520   83  Linux
/dev/sda4            4177       36469   259387694   83  Linux

第四步，输入d然后选择分区，删除现有分区。

Command (m for help): d
Partition number (1-4): 1

Command (m for help): d
Selected partition 2

Command (m for help): d
Selected partition 3

Command (m for help): d
Selected partition 4

第五步，输入n建立新的磁盘分区，首先建立两个主磁盘分区。

Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p    //建立主分区
Partition number (1-4): 1  //分区号
First cylinder (1-391, default 1):  //分区起始位置
Using default value 1
last cylinder or +size or +sizeM or +sizeK (1-391, default 391): 100  //分区结束位置，单位为柱面

Command (m for help): n  //再建立一个主分区
Command action
   e   extended
   p   primary partition (1-4)
p 
Partition number (1-4): 2  //分区号为2
First cylinder (101-391, default 101):
Using default value 101
Last cylinder or +size or +sizeM or +sizeK (101-391, default 391): +200M  //分区结束位置，单位为M

第七步，确认分区建立成功。

Command (m for help): p

Disk /dev/sdb: 3221 MB, 3221225472 bytes
255 heads, 63 sectors/track, 391 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         100      803218+  83  Linux
/dev/sdb2             101         125      200812+  83  Linux

第八步，再建立一个逻辑分区。

Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
e  //选择扩展分区
Partition number (1-4): 3
First cylinder (126-391, default 126):
Using default value 126
Last cylinder or +size or +sizeM or +sizeK (126-391, default 391):
Using default value 391


第九步，确认扩展分区建立成功。

Command (m for help): p

Disk /dev/sdb: 3221 MB, 3221225472 bytes
255 heads, 63 sectors/track, 391 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         100      803218+  83  Linux
/dev/sdb2             101         125      200812+  83  Linux
/dev/sdb3             126         391     2136645    5  Extended

第十步，在扩展分区上建立两个逻辑分区。

Command (m for help): n
Command action
   l   logical (5 or over)
   p   primary partition (1-4)
l //选择逻辑分区
First cylinder (126-391, default 126):
Using default value 126
Last cylinder or +size or +sizeM or +sizeK (126-391, default 391): +400M    

Command (m for help): n
Command action
   l   logical (5 or over)
   p   primary partition (1-4)
l
First cylinder (176-391, default 176):
Using default value 176
Last cylinder or +size or +sizeM or +sizeK (176-391, default 391):
Using default value 391

第十一步，确认逻辑分区建立成功。

Command (m for help): p

Disk /dev/sdb: 3221 MB, 3221225472 bytes
255 heads, 63 sectors/track, 391 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         100      803218+  83  Linux
/dev/sdb2             101         125      200812+  83  Linux
/dev/sdb3             126         391     2136645    5  Extended
/dev/sdb5             126         175      401593+  83  Linux
/dev/sdb6             176         391     1734988+  83  Linux

Command (m for help):

从上面的结果我们可以看到，在硬盘 sdb 我们建立了 2 个主分区（sdb1，sdb2），1个扩展分区（sdb3），2 个逻辑分区（sdb5，sdb6）。

注意：主分区和扩展分区的磁盘号位1-4，也就是说最多有 4 个主分区或者扩展分区，逻辑分区开始的磁盘号为 5，因此在这个实验中是没有 sdb4 的。

最后对分区操作进行保存：

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.

建立好分区之后我们还需要对分区进行格式化才能在系统中使用磁盘。

在 sdb1 上建立 ext2 文件系统。

[root@localhost ~]# mkfs.ext2 /dev/sdb1
mke2fs 1.39 (29-May-2006)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
100576 inodes, 200804 blocks
10040 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=209715200
7 block groups
32768 blocks per group, 32768 fragments per group
14368 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840

Writing inode tables: done                           
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 32 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.

在 sdb6 上建立 ext3 文件系统。

[root@localhost ~]# mkfs.ext3 /dev/sdb6
mke2fs 1.39 (29-May-2006)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
217280 inodes, 433747 blocks
21687 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=444596224
14 block groups
32768 blocks per group, 32768 fragments per group
15520 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912

Writing inode tables: done                           
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 32 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
[root@localhost ~]#

建立两个目录/oracle和/web，将新建好的两个分区挂载到系统：

[root@localhost ~]# mkdir /oracle
[root@localhost ~]# mkdir /web
[root@localhost ~]# mount /dev/sdb1 /oracle
[root@localhost ~]# mount /dev/sdb6 /web

查看分区挂载情况：

[root@localhost ~]# df -h
文件系统              容量  已用 可用 已用% 挂载点
/dev/mapper/VolGroup00-LogVol00
                      6.7G  2.8G  3.6G  44% /
/dev/sda1              99M   12M   82M  13% /boot
tmpfs                 125M     0  125M   0% /dev/shm
/dev/sdb1             773M  808K  733M   1% /oracle
/dev/sdb6             1.7G   35M  1.6G   3% /web

如果需要每次开机自动挂载则需要修改/etc/fstab文件，加入两行配置：

[root@localhost ~]# vim /etc/fstab

/dev/VolGroup00/LogVol00 /                       ext3    defaults        1 1
LABEL=/boot             /boot                   ext3    defaults        1 2
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
/dev/VolGroup00/LogVol01 swap                    swap    defaults        0 0
/dev/sdb1               /oracle                 ext2    defaults        0 0
/dev/sdb6               /web                    ext3    defaults        0 0

●du 命令:
1.简介

du（disk usage）命令用于查看指定的目录或文件所占用的磁盘空间。
2.命令格式

du [OPTIONS] [FILES]
du [OPTIONS] --files0-from=F

3.选项说明

-a, --all
	递归显示目录与其包含的所有文件及子目录的大小，默认仅显示目录及其子目录的大小。
--apparent-size
	显示文件或目录自身大小，而不是它们占用的磁盘空间大小。文件或目录占用磁盘空间的大小与它们自身大小有时候并非完全一致，有可能比较大，原因可能是稀疏文件中存在空洞，内部碎片，间接blocks等。大小等同与使用命令"wc -c"或"ls --blokc-size=1"查看的字节大小。
-B, --block-size=SIZE
	定文件大小的统计单位，SIZE 可取如下字符串: KB（1000）、K（1024）、MB（1000*1000）、M（1024*1024）以及G, T, P, E, Z, Y等
-b,-bytes
	显示目录或文件大小时，以byte为单位,等同于选项 --apparent-size --block-size=1。
-c, --total
	显示占用磁盘空间大小的总和。
-D, --dereference-args
	显示指定符号连接的源文件大小。
--files0-from=F
	列出在文件F中指出的文件名称，如果F等于连字符-，则从标准输入读取文件名称。
-H
	等同于 -D, --dereference-args。
-h, --human-readable
	以易读的单位显示大小，例如以 K，M，G 等为单位进行显示。
--si
	等同于 -h，但是 K，M，G 等以 1000 而非 2014 为换算单位。
-k
	以 K 为单位显示，等同于--block-size=1K。
-l, --count-links
	多次计算硬链接文件。
-m
	以 M 为单位显示，等同于--block-size=1M。
-L, --dereference
	显示符号链接的源文件大小。
-P, --no-dereference
	默认选项，不显示符号链接源文件大小。
-0, --null
	以 NULL 字符取代输出的换行符。
-S, --separate-dirs
	不显示子目录大小（不太明白，为何使用时仍然显示子目录大小）。
-s, --summarize
	只显示给定的文件或目录的总大小。
-x, --one-file-system
	以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
-X, --exclude-from=FILE
	跳过符合指定的文件。
--exclude=PATTERN
	跳过符合指定模式的文件或目录。
--max-depth=N
	指定递归显示的最大目录深度，--max-depth=0 等同于 --summarize。
--time
	显示文件或目录最后修改时间。
--time=WORD
	显示指定类型的时间，而非默认的最后修改时间。WORD 可取值为 atime、access、use（访问时间），或者ctime、status（状态改变时间）。
--time-style=STYLE
	使用指定的时间格式显示时间，STYLE 可取值为 full-iso, long-iso, iso, +FORMAT，其中 FORMAT 解析方式等同于 date 命令。
--help
	显示帮助信息。
--version
	显示版本信息。

4.常用示例

（1）显示指定文件或目录占用磁盘空间大小。

du -sh [file or directory] 

（2）显示指定目录及其所有子目录的大小。

du -h [directory]

5.注意事项

（1）文件大小与占用磁盘空间大小的区别。
文件大小（又名 apparent size）是文件自身实际大小，与占用磁盘空间大小（又名 occupied space size）有本质的区别。举个例子，创建一个1字节的文件，使用du显示的为4KB，使用ls显示为1B，示例如下：

[dablelv@TENCENT64 ~]$ echo -n 1 > 1B.txt
[dablelv@TENCENT64 ~]$ ls -l 1B.txt
-rw-rw-r-- 1 dablelv dablelv 1 Apr  4 19:14 1B.txt
[dablelv@TENCENT64 ~]$ du -h 1B.txt
4.0K	1B.txt

我们先创建一个文件1B.txt，大小是一个字节，ls显示出的size就是1Byte，而1B.txt这个文件在硬盘上会占用1个block，因为Linux文件系统存储最小单位为block，不足1个block大小的文件也要占用1个block大小。这里的一个block等于4K。

（2）稀疏文件（sparse file）
稀疏文件就是在文件中留有很多空余空间，称为空洞（hole），留备将来插入数据使用，这些空洞被填充为NULL字符，特点是文件系统并不会为空余空间分配磁盘空间。

使用如下代码创建稀疏文件：

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
	int fd = open("sparse.file", O_RDWR|O_CREAT);
    lseek(fd, 10240, SEEK_CUR);
    write(fd, "\0", 1);
    return 0;
}

编译生成后执行，创建稀疏文件sparse.file，偏移10240字节后写入一个空字符，使得文件sparse.file内容全为空字符。使用ls命令查看文件大小为10241B，这是文件的大小。使用du命令查看文件占用磁盘空间大小时，发现稀疏文件空洞部分并不占用磁盘空间，被文件系统压缩存储。

[dablelv@TENCENT64 ~]$ ll sparse.file
-rw---x--- 1 dablelv dablelv 10241 Apr  4 20:16 sparse.file
[dablelv@TENCENT64 ~]$ du -h sparse.file 
4.0K	sparse.file

6.小结

历时近 5h，终于完成了此篇 blog，其中对于选项 -S 还存有疑惑，以及文件碎片（fragmentation）、间接块（indirect blocks）等相关概念比较模糊，后续了解后继续补充，也请请知者不吝指教，留言告知，万分感谢！对于文中不足甚至错误之处，也请大家批评指正。

●nohup 命令
1.命令简介

nohup 的作用可以将程序以忽略挂起信号（SIGHUP）的方式运行。常见的用法是和 & 命令一同使用，将命令放置到后台运行，即使终端挂掉，进程会忽略挂起信号，继续运行。

将程序放到后台运行，一般有两种方式：
（1）command & ： 后台运行，关掉终端会停止运行。
（2）nohup command & ： 后台运行，关掉终端也会继续运行。

注意：
（1）如果使用nohup执行程序未显示进行标准输出重定向，则标准输出默认重定向当前工作目录的 nohup.out 文件中。如果当前工作目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开用于追加，那么 command 参数指定的命令不可调用。

（2）如果标准错误未显示重定向，那么标准错误默认重定向到与标准输出相同的文件。
2.命令格式

nohup COMMAND [ARGS]
nohup OPTION

3.选项说明

--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）使用 nohup 命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件。

nohup ./test.sh &

（2）标准输出与标准错误输出重定向。

nohup ./test.sh > test.log 2>&1 &

注意：
（1）2>&1 标识标准错误输出重定向等同于标准输出重定向，即标准错误输出也重定向到文件test.log；
（2）& 命令是命令放在后台执行，需要放在命令的最后面。

●tr 命令:
1.命令简介

tr（translate）用来转换或者删除一段文字。tr 所有的功能均可由 sed 来完成，可以将 tr 视为 sed 一个极简的实现。
2.命令格式

tr [OPTIONS] SET1 [SET2]

3.选项说明

-c, -C, --complement SET1 [SET2]
	将字符集 SET1 以外的其他字符删除或者转换为字符集 SET2 中的最后一个字符（如果你指定了多个字符的话）
-d, --delete
	删除 SET1 这个字符串
-s, --squeeze-repeats
	如果 SET1 中的字符连续出现多次，压缩重复的字符，只保留一个
-t, --truncate-set1
	先将 SET1 的长度截为和 SET2 相等
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）将 last 输出的信息中所有小写的字符变成大写字符。

last | tr [a-z] [A-Z]

（2）将 /etc/passwd 输出的信息中的冒号 : 删除。

cat /etc/passwd | tr -d ':'

（3）将 DOS 文件转成 Unix 文件。

cat /etc/passwd | tr -d '\r'

（4）删除空行。

cat file | tr -s "\n" > new_file

（5）将文件中 “abc” 分别替换为 “xyz” 中对应的字符。

cat file | tr "abc" "xyz" > newFile

**注意：**这里凡是在 file 中出现的"a"字母，都替换成"x"字母，"b"字母替换为"y"字母，“c"字母替换为"z"字母，而不是将字符串"abc"替换为字符串"xyz”。

（6）替换指定字符集以外的字符。

echo -n "alv blv" | tr -c "lv " "x"
xlv xlv

echo -n 表示不输出换行符。

（7）从输入文本中将不在补集中的所有字符删除。

echo -n "alv blv" | tr -dc "lv"
lvlv

●join 命令:
1.命令简介

将两个文件按照指定的相同字段进行笛卡尔乘积横向拼接，并输出到标准输出。默认情况下，join 字段分隔符是空格或 Tab。join 时，两个文件需要按照某个字段排好序。

笛卡尔乘积指两个集合 X 和 Y 成员相互组合构成的有序对的集合。比如集合 X={a,b}，Y={0,1,2}，则

X×Y={(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}
Y×X={(0, a), (0, b), (1, a), (1, b), (2, a), (2, b)}

2.命令格式

join [OPTIONS] FILE1 FILE2

当 FILE1 或 FILE2 是连字符 -（二者不能同时是 -），那么内容从标准输入读取。
3.选项说明

-a FILENUM
	除了显示原来的输出内容之外，还显示文件中没有相同栏位的行。FILENUM 取值为 1 或 2，分别对应 FILE1 和 FILE2
-e EMPTY
	若 FILE1 与 FILE2 中找不到指定的列，则在输出中填入选项中的字符串
-i, --igore-case
	比较列内容时，忽略大小写
-j FIELD
	等价于 -1 FIELD -2 FIELD
-o FORMAT
	按照指定的格式显示结果
-t CHAR
	指定输入和输出列的分隔字符
-v FILENUM
	作用类似于 -a FILENUM，但是只显示文件中没有相同列的行
-1 FIELD
	连接 FILE1 指定的列。FIELD 取 1 表示第一列，2 表示第二列，以此类推
-2 FIELD
	连接 FILE2 指定的列。FIELD 取 1 表示第一列，2 表示第二列，以此类推
--check-order
	默认选项，检查文件是否已经排序
--nocheck-order
	不检查检查文件是否已经排序
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）连接两个文件，默认以第一列作为连接字段。

# file1 内容如下
lvlv dablelv 25
zhangsan San 12

# file2 内容如下
lvlv english 15
lvlv math 75
zhangsan math 14
zhouxun english 45

join file1 file2
lvlv dablelv 25 english 15
lvlv dablelv 25 math 75
zhangsan San 12 math 14

（2）还是以上面的两个文件为例，显示指明按照第一列中文名进行连接。

join -j 1 file1 file2
# 或
join -1 1 -2 1 file1 file2

（3）如果想显示没有相同字段的行，使用 -a1 或 -a2 指定显示第一个或者第二个文件的行。

join -a2 file1 file2
lvlv dablelv 25 english 15
lvlv dablelv 25 math 75
zhangsan San 12 math 14
zhouxun english 45  		//显示了文件 file2 中未匹配的一行

●paste 命令:
1.命令简介

paste 命令将多个文件的相应行默认以 Tab 分隔符横向连接起来，输出到标准输出。paste 后可接多个文件，不限于 2 个文件。如果文件写成连字符 -，表示内容来自标准输入。paste 相对于 join 来说，简单许多，不需要有相同的字段也可按行拼接。
2.命令格式

pasete [OPTIONS] [FILES]

3.选项说明

-d，--delimiters=LIST
	用指定的域分隔符取代Tab。
-s，--serial
	顺序地合并一个文件的所有行到一行
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

有两个文件 file1.txt 和 file2.txt，内容如下：

# file1 内容
abc
def
ghi

# file2 内容
123
456
789
012

（1）将文件 file1.txt 的所有行合并到一行。

paste -s file1.txt
abc	def	ghi

# 指定域分隔符为冒号：
paste -s -d : file1.txt
abc:def:ghi

（2）将多个文件的所有行分别合并为一行。

paste -s file1.txt file2.txt
abc	def	ghi
123	456	789	012

（3）横向连接两个文件，默认以 Tab 分隔。

paste file1.txt file2.txt
abc	123
def	456
ghi	789
	012

# 通过交换文件名可指定列的位置
paste file2.txt file1.txt
123	abc
456	def
789	ghi
012	

（4）paste 黏贴的内容（行）从标准输入读取，此时可以使用 - 来指代。例如查看 /etc 下的文件列表，并用 paste 打印成每行显示五个文件名。

ls /etc/ | paste -d: - - - - -
cpi:adjtime:aliases:alternatives:anacrontab
anthy-conf:asound.conf:at.deny:audisp:audit
bash-command-not-found:bash_completion.d:bashrc:blkid:bonobo-activation
...

5.注意事项

如果文件格式是 DOS，文件换行符是\r\n，那么会出现内容覆盖的情况。比如 file1.txt 和 file2.txt 格式是 DOS，paste 这两个文件会出现如下情况：

[root@tencent ~]# paste file1.txt file2.txt
:123
:456
:789
:012

从结果可以看出，来自 file1.txt 的行被 file2.txt 的行覆盖，解决办法是，使用 vim 的末行命令:set ff=unix将文本格式改为 Unix。

●expand 命令:
1.命令简介

用于将文件的制表符（Tab）转换为空格符（Space），默认一个 Tab 对应8个空格符，并将结果输出到标准输出。若不指定任何文件名或所给文件名为 -，则 expand 会从标准输入读取数据。

功能与之相反的命令是 unexpand，是将空格符转成 Tab 符。
2.命令格式

expand [OPTIONS] [FILES]

3.选项说明

-i, --initial
	不转换非空白符后的制表符
-t, --tabs=NUMBER
	指定一个tab替换为多少个空格，而不是默认的 8
-t, --tabs=LIST
	指定制表符位置列表，用逗号分隔
--help
	显示帮助信息
--version
	输出版本信息

4.常用示例

（1）将文件中每行第一个 Tab 符替换为 6 个空格符，非空白符后的制表符不作转换。

expand -i -t 6 FILE

原文件内容：
这里写图片描述
转换后内容如下：
这里写图片描述
5.常见问题

（1）不是所有的Tab都会转换为默认或指定数量的空格符，expand会以对齐为原则将Tab符替换为适当数量的空格符，替换的原则是使后面非Tab符处在一个物理Tab边界（即Tab size的整数倍）。例如下面的文件：
这里写图片描述
其中CR和LF分别是Windows下的回车和换行符。使用如下命令转换后的结果如下图：

expand -t 4 file

这里写图片描述
可以看到第一行的第二个Tab符和第二行的所有Tab符并没有替换为4个空格符，还是按照原来内容的对齐格式，替换为适当数量的空格符。

●svn 命令:
1.命令简介

SVN 是 Apache Subversion 的缩写 ，是一个开放源代码的版本控制系统。相较于 RCS、CVS，它采用了分支管理系统，它的设计目标就是取代 CVS。互联网上很多版本控制服务已从 CVS 转移到 Subversion。Subversion 在 2000 年由 CollabNet 开发，现在已发展成为 Apache 软件基金会的一个项目。

svn 是Apache Subversion 的客户端，完成与 Apache Subversion 服务端的交互，实现版本控制。
2.命令格式

svn [subcommand] [options] [args]

3.选项说明

可用的子命令：
	add
	blame (praise, annotate, ann)
	cat
    changelist (cl)
    checkout (co)
    cleanup
    commit (ci)
    copy (cp)
    delete (del, remove, rm)
    diff (di)
    export
    help (?, h)
    import
    info
    list (ls)
    lock
    log
    merge
    mergeinfo
    mkdir
    move (mv, rename, ren)
    patch
    propdel (pdel, pd)
    propedit (pedit, pe)
    propget (pget, pg)
    proplist (plist, pl)
    propset (pset, ps)
    relocate
    resolve
    resolved
    revert
    status (stat, st)
    switch (sw)
    unlock
    update (up)
    upgrade

4.常用示例
4.1 svn commit 撤销

（1）找出要回滚的版本号。

svn log --limit 3 FILENAME

--limit 3的意思是显示最新的三个版本。假如根据 svn log 日志查出指定文件要回滚的版本号是 2589。

（2）回滚本地到版本号 2589。

svn merge -r 5730:2589 FILENAME

（3）为了保险起见，确认回滚的结果。

svn diff FILENAME

（4）本地与版本库中没有差异的话，指定文件的当前版本是 2589。提交回滚后的文件。

svn commit -m "Revert revision from r5730 to r2589,because of ..."

●read 命令（builtin）:
1.命令简介

read 命令是 Shell 内建命令，用于从标准输入或 -u 选项指定的文件描述符中读取单行，并将读取的单行根据 IFS 变量分割成多个字段，并将分割后的字段分别赋值给指定的变量列表。第一个字段分配给第一个变量，第二个字段分配给第二个变量，以此类推。如果指定的变量名少于字段数量，则多出的字段连同分隔符分配给最后一个变量。如果指定的变量多于字段数量，则多出的变量赋值为空。如果没有指定任何变量，则分割后的所有字段都存储在特定变量 REPLY 中。当然，read 读取的内容不仅可以赋给变量，还可以赋给数组。

IFS（Internal Field Separator）变量是 Shell 内建的环境变量，用于将 read 命令读取的单行内容分隔为多个字段。默认取值为空格、Tab 和换行符。

REPLY 变量也是 Shell 内建的环境变量，当 read 命令未指明接收变量时，用于接收 read 命令读取的单行内容。
2.命令格式

read [OPTIONS] [VARNAMES]

3.选项说明

-a ANAME
	将分割后的字段依次存储到指定的数组中，存储的起始位置从数组的下标 0 开始
-d DELIM
	后跟一个分隔符，只有第一个字符有用，用以取代换行符作为行的结束标志
-e
	在输入的时候可以使用命令补全功能，使用 Tab 键可自动补全当前目录下文件
-i TEXT
	如果使用 readline 命令读取行，则在开始编辑之前将文本放入编辑缓冲区
-n NCHARS
	后跟一个数字，定义输入文本的长度，而不是读取整行
-N NCHARS
	后跟一个数字，定义输入文本的长度，而不是读取整行。但是如果一行不足 nchars 个字符，则忽略行分隔符继续读取下一行
-p PROMPT
	从终端读取输入时，在输入前打印提示信息
-r
	屏蔽反斜杠 \。如果没有该选项，则 \ 作为一个转义字符，有的话 \ 就是个正常的字符了
-s
	静默模式，输入字符不显示到屏幕，例如 login 时输入密码
-t TIMEOUT
	后面跟秒数，定义输入字符的等待时间
-u FD
	后面跟文件描述符 fd，从文件描述符中读取

4.常用示例

（1）如果没有指定变量，read 会把传入的值传给 REPLY，只要调用 REPLY就可以引用 read 读取的内容。

read; echo "\$REPLY:$REPLY"
dablelv
$REPLY:dablelv

（2）read 从终端读取时指定一个提示语

[root@TENCENT64 ~]# read -p"input u password:";echo "\$REPLY:$REPLY"
input u password:123456
$REPLY:123456

（3）-t 选项指定 read 命令等待输入的秒数，当计时满时，read 命令返回一个非零状态码。

#!/bin/bash

if read -t 5 -p "输入网站名:" name
then
    echo "你输入的网站名是 $website"
else
    echo "\n抱歉，你输入超时了。"
fi
exit 0

执行程序不输入，等待 5 秒后：

输入网站名:
抱歉，你输入超时了

（4）除了控制输入时间，还可以使用 -n 选项控制输入的字符数量。当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量。例如只接收 2 个输入就退出：

#!/bin/bash

read -n2 -p "请随便输入两个字符: " any
echo "\n您输入的两个字符是:$any"
exit 0

（5）-s 选项能够使输入的数据不显示在命令终端上（实际上，输入的内容是显示的，只是 read 命令将文本颜色设置成与背景相同的颜色）。输入密码常用这个选项。

#!/bin/bash

read  -s  -p "请输入您的密码:" pass
echo "\n您输入的密码是 $pass"
exit 0

执行程序输入密码后是不显示的：

请输入您的密码:
您输入的密码是 runoob

（6）读取文件。每次调用 read 命令都会读取文件中的一行文本。当文件没有可读的行时，read 命令将以非零状态码退出。

while read var1 var2
do
	echo $var1 $var2
done < file.txt

●file 命令:
1.命令简介

file 命令用来识别文件类型，对文件的检查分为文件系统、魔数检查和语言检查三个过程，也可用来辨别一些文件的编码格式。它是通过查看文件的头部信息来获取文件类型，而不是像 Windows 通过扩展名来辨识文件类型。
2.命令格式

file [-bchiklLNnprsvz0] [--apple] [--mime-encoding] [--mime-type] [-e testname] [-F separator] [-f namefile] [-m magicfiles] file ...
file -C [-m magicfiles]
file [--help]

3.选项说明

--apple
	输出旧 MacOS 版本使用的文件类型和创建者代码。代码由八个字母组成，第一个字母描述文件类型，第二个字母描述创建者。此选项仅适用于定义了 Apple 风格输出的文件格式
-b, --brief
	简约模式，不显示文件名称
-C, --compile
	生成 magic.mgc 文件。配合选项 -m 使用
-c, --checking-printout
	输出魔法文件的解析结果
-e, --exclude TESTNAME
	排除对指定类型文件的检查，TESTNAME 可取值有 apptype、ascii、encoding、tokens、cdf、compress、elf、soft、tar
-F, --separator SEP
	使用指定分隔符替换输出文件名后的默认的冒号分隔符 :
-f, --files-from NAMEFILE
	从文件 NAMEFILE 中读取待检测的文件，每行一个
-i, --mime
	输出 mime 类型的字符串而不是可读字符串，比如输出"text/plain; charset=us-ascii"而不是"ASCII text"
--mime-type, --mime-encoding
	像 -i，但是只打印指定元素
-k, --keep-going
	不在首次匹配时停止，继续检查
-l, --list
	打印每个魔数模式的强度信息
-L, --dereference
	查看软链接对应文件的文件类型
-m, --magic-file MAGICFILES
	指定 magic file。magic file 指的是那些具有特殊内容的文件，比如 C 文件，它会有 #include 字样；tar 文件的前几个字节会有特殊的规则。而检验 magic file 规则就是根据这些特殊的格式去判断一个文件的类型。而这些规则保存在 $HOME/.magic.mgc
-N, --no-pad
	不要填充文件名以便它们在输出中对齐
-n, --no-buffer
	强制刷新标准输出 stdout。这个选项只在检查多个文件时有效。在通过管道获取文件类型时也可以使用该选项
-p, --preserve-date
	保留待检测文件的access time，即使file命令不更改待检测文件的access time
-r, --raw
	不将不可打印字符转换为\ooo的八进制形式，正常情况下，file会做转换
-s, --special-files
	正常情况下，file命令只支持普通文件的检测，就像stat(2)一样。使用该选项可以让file命令支持特殊文件，比如原始磁盘分区等
-v, --version
	显示版本信息
-z, --uncompress
	尝试去解读压缩文件的内容
-0, --print0
	在文件名后输出空字符 \0
--help
	显示帮助信息

4.常用示例

（1）查看文件类型。

[root@TENCENT64 ~]# file Changelog 
Changelog: ASCII text

（2）不输出文件名称，只显示文件格式以及编码。

[root@TENCENT64 ~]# file -b Changelog 
ASCII text

（3）输出 mime 类型的字符串。

[root@TENCENT64 ~]# file -i Changelog 
Changelog: text/plain; charset=us-ascii

（4）查看软链接对应文件的文件类型。

[root@TENCENT64 ~]# ll Changelog*
-rw-r--r-- 1 root root 1598 Nov  6 22:39 Changelog
lrwxrwxrwx 1 root root    9 Nov  6 23:07 Changelog.ln -> Changelog

#查看软链接本身类型
[root@TENCENT64 ~]# file Changelog.ln
Changelog.ln: symbolic link to `Changelog'

#查看软链接对应文件的文件类型
[root@TENCENT64 ~]# file -L Changelog.ln
Changelog.ln: ASCII text

（5）查看程序是 32 位还是 64 位。

file ./a.out 
./a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7dd2556f5818bc85c64ab82131cf0b748567a976, not stripped

通过 ELF 64-bit LSB executable 可以看出程序是 64 位的。

●stat 命令:
1.命令简介

stat 命令用于显示文件或文件系统的详细信息。在显示文件信息时，比 ls 命令更加详细。
2.命令格式

stat [OPTION]... FILE..

3.命令选项

-L, --dereference:跟随符号链接解析原文件而非符号链接；
-f, --file-system:显示文件所在文件系统信息而非文件信息；
-c,--format=FORMAT:以指定格式输出，而非默认格式；
	显示文件信息可用格式控制符如下：
	%a：以八进制显示访问权限
	%A：以可读形式显示访问权限
	%b：显示占有块数
	%B：显示每一块占有的字节数
	%C：SELinux security context string
	%d：十进制显示文件所在设备号
	%D：十六进制显示文件所在设备号
	%f：十六进制显示文件类型
	%F：文件类型。Linux下文件类型主要分为普通文件、目录、字符设备文件、块设备文件、符号链接文件、套接字等
	%g：文件所有者组ID
	%G：文件所有者组名称
	%h：文件硬链接数
	%i：inode号
	%m：文件所在磁盘分区挂载点，比如/data
	%n：文件名称
	%N：单引号括起来的文件名称，如果是软链接，则同时显示指向的文件名称
	%o：optimal I/O transfer size hint
	%s：实际文件大小，单位字节
	%t：major device type in hex, for character/block device special files
	%T：minor device type in hex, for character/block device special files
	%u：所有者用户ID
	%U：所有者用户名称
	%w：文件创建时间，输出-表示无法得知
	%W：文件创建时间，输出Unix时间戳，0表示无法得知
	%x：可读形式输出最后访问时间atime
	%X：Unix时间戳输出最后访问时间atime
	%y：可读形式输出最后修改时间mtime
	%Y：Unix时间戳输出后修改时间mtime
	%z：可读形式输出最后状态改变时间ctime
	%Z：Unix时间戳输出最后状态改变时间ctime
	
	显示文件系统信息可用格式控制符有：
	%a：非超级用户可使用的自由block数
	%b：文件系统总block数
	%c：文件系统总文件节点数
	%d：可用文件节点数
	%f：可用文件block数
	%i：十六进制文件系统ID
	%l：最大文件名称长度
	%n：文件名称
	%s：一个块的大小，单位字节（for faster transfers）
	%S：一个块的基本大小，单位字节（用于统计block的数量）
	%t：十六进制输出文件系统类型
	%T：可读形式输出文件系统类型
--printf=FORMAT:以指定格式输出，而非默认格式。与--format作用类似，但可以解释反斜杠转义字符，比如换行符\n；
-t, --terse:简洁模式输出，只显示摘要信息；
--help:显示帮助信息；
--version:显示版本信息。

4.常用示例

（1）显示文件信息。

[root@TENCENT64 ~]# stat Changelog
  File: ‘Changelog’
  Size: 1598      	Blocks: 8          IO Block: 4096   regular file
Device: fd01h/64769d	Inode: 1579435     Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2018-11-06 22:39:54.110931887 +0800
Modify: 2018-11-06 22:39:54.110931887 +0800
Change: 2018-11-06 23:07:14.428548887 +0800
 Birth: -

信息解释：

File: ‘Changelog’:文件名称为Changelog
Size: 1598:文件大小1598字节
Blocks: 8：文件占用的块数
IO Block: 4096：
regular file：文件类型（普通文件）
Device: fd01h/64769d：文件所在设备号，分别以十六进制和十进制显示
Inode: 1579435：文件节点号
Links: 1：硬链接数
Access: (0644/-rw-r--r--)：访问权限
Uid：所有者ID与名称
Gid：所有者用户组ID与名称
Access：最后访问时间
Modify：最后修改时间
Change：最后状态改变时间
Birth -：无法获知文件创建时间。注意：Linux下的文件未存储文件创建时间

（2）显示文件所在文件系统信息。

[root@TENCENT64 /data/vas_pgg_proj/apps/penguin_game]# stat -f Makefile
  File: "Makefile"
    ID: 6f75a4f02634e23e Namelen: 255     Type: ext2/ext3
Block size: 4096       Fundamental block size: 4096
Blocks: Total: 43830967   Free: 30155578   Available: 27923259
Inodes: Total: 11162880   Free: 11077199

信息解释：

File: "Makefile"：文件名称为"Makefile"；
ID: 6f75a4f02634e23e：文件系统ID
Namelen: 255：最大文件名称长度
Type: ext2/ext3：文件系统类型名称
Block size: 4096：块大小为4096字节
Fundamental block size: 4096：基本块大小为4096字节
Blocks: Total: 43830967   Free: 30155578   Available: 27923259：
Inodes: Total: 11162880   Free: 11077199

●export 命令:
1.命令简介

export 命令为 Shell 内建命令，用于设置或显示环境变量，环境变量包含变量与函数。

在 Shell 中执行程序时，Shell 会提供一组环境变量。export 可新增、删除或修改环境变量，供后续被执行的程序使用。export 的作用效果仅限于当前登录。
2.命令格式

export [-fn] [NAME[=WORD]]...
export -p

3.选项说明

-f
	表示 NAME 为函数名称
-n
	删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中
-p
	列出所有的 Shell 环境变量

4.常用示例

（1）定义环境变量并赋值。

export MYNEWV=8

（2）修改指明 Shell 命令搜索路径的环境变量 PATH。

export PATH=$PATH:/usr/local/mysql/bin

查看是否已经设置好，可以使用命令export -p命令来查看，也可以使用 echo 命令打印变量内容。

export -p | grep PATH

#或
echo $PATH

（3）export 用于 Shell 脚本。
用户登录到 Linux 系统后，系统将启动一个用户 Shell。在这个 Shell 中，可以使用 Shell 命令或声明变量，也可以创建并运行 Shell 脚本程序。系统将创建一个子 Shell 进程。此时，系统中将有两个 Shell 进程，一个是登录时系统启动的 Shell 进程，另一个是系统为运行脚本创建的 Shell 进程。当一个脚本运行完毕，它的脚本 Shell 进程将终止，可以返回到执行该脚本之前的 Shell。从这种意义上来 说，用户可以有许多 Shell 进程，每个 Shell 进程都是由其父 Shell 进程派生的。

如果在一个 Shell 脚本中定义了一个变量，该脚本运行时，这个定义的变量只是该脚本内的一个局部变量，子 Shell 无法引用它。要使某个变量可以在子 Shell 中被引用，可以使用 export 命令对已定义的变量进行导出，称为导出变量。系统在创建每一个新的 Shell 时会拷贝导出变量，子 Shell 可以访问或修改导出变量，但是这种修改父 Shell 看不到。

例如脚本 test1.sh 中调用脚本 test2.sh，test2.sh 中使用 test1.sh 定义的变量shareVar。

test1.sh 定义如下：

#!/bin/sh
shareVar=666
export shareVar
./test2.sh

test2.sh 定义如下：

#!/bin/sh
echo "in $0"
echo $shareVar

执行 test1.sh 输出结果如下：

./test1.sh
in ./test2.sh
666

5.Linux 设置环境变量的三种方法

（1）使用 export 命令。

export PATH=$PATH:/usr/local/mysql/bin

注意：直接使用 export 设置的变量都是临时变量，也就是说退出当前的 Shell 为该变量定义的值便不会生效了。我们可以使用如下两种方式使变更永久有效。

（2）修改 /etc/bashrc 或 /etc/profile，加入如下行，对所有用户永久生效。

export PATH=$PATH:/usr/local/mysql/bin

注意：修改完这个文件必须要使用如下命令执行配置文件的内容，在不用重启系统的情况下使修改的内容生效。

source /etc/profile
# 或
. /etc/profile

（3）修改 ~/.bashrc 或者 ~/.bash_profile 文件，加入如下行，只对当前用户永久生效。

export PATH=$PATH:/usr/local/mysql/bin

修改这个文件之后同样也需要使用 source 或者是 . 命令使配置文件生效。

●date 命令:
1.命令简介

date 命令用于按照指定格式显示当前时间或者指定的时间，也可以设置系统时间。很多 Shell 脚本里面需要打印不同格式的时间或日期，以及要根据时间和日期执行操作，此时可以使用 date 命令来完成。在类Unix 系统中，日期被存储为一个整数，其大小为协调世界时（UTC）1970 年 1 月 1 日 0 时 0 分 0 秒起流逝的秒数，即 Unix 时间戳。
2.命令格式

date [OPTION]... [+FORMAT]
date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]

其中，FORMAT为格式控制字符串，可取如下值：

%% 字符%
%a 星期的简称（Sun~Sat）
%A 星期的全称（Sunday~Saturday）
%b 月的简称（Jan~Dec）
%B 月的全称（January~December）
%c 日期和时间（Thu 06 Dec 2018 09:43:53 AM CST）。只输入date指令也会显示同样的结果。
%C 世纪。和%Y比较像，但不显示最后两个数字，如20
%d 一个月的第几天（01~31）
%D 日期，等同于%m/%d/%y，如12/06/18
%e 一个月的第几天（1~31），单数字以空格填充，等同于%_d
%F 日期，等同于%Y-%m-%d，如2018-12-06
%g 年的最后两个数字（yy），比如2018则输出18，等同于%y
%G 年份(yyyy)
%h 月的简称（Jan~Dec），等同于%b
%H 小时，24小时制（00~23）
%I 小时，12小时制（01~12）
%j 一年的第几天（001~366）
%k 小时，24小时制（0~23）。单数字填充空格，等同于%_H
%l 小时，12小时制（1~12）。单数字填充空格，等同于%_I
%m 月份（01~12）
%M 分钟（00~59）
%n 换行符newline
%N 纳秒nanoseconds(000000000..999999999)
%p 显示出AM或PM
%P 显示出am或pm
%r 显示时间，12小时制（hh:mm:ss %p）
%R 显示小时与分钟，24小时制，等同于%H:%M
%s 从1970年1月1日00:00:00到目前经历的秒数
%S 显示秒（00~59）
%t Tab符
%T 显示时间，24小时制（hh:mm:ss），等同于%H:%M:%S
%u 一周的第几天(1..7)。1表示星期一
%U 一年的第几周，周日为每周的第一天(00..53)
%V 一年的第几周，周一为每周的第一天(01..53)
%w 一个星期的第几天（0~6），0代表星期天
%W 一年的第几周，周一为每周的第一天(00..53)
%x 日期(mm/dd/yyyy)，如12/06/2018
%X 时间，等同于%H:%M:%S
%y 年的最后两个数字（2018则是18）
%Y 年（yyyy）
%z 以+hhmm格式显示时区（如+0800）
%:z 以+hh:mm格式显示时区（如+08:00）
%::z 以+hh:mm:ss格式显示时区（如+08:00:00）
%Z 缩写显示时区名称，如CST（China Standard Time）
%h,%b 月的简称（Jan~Dec）
填充字符说明：默认地，date命令以0填充数字域，以下填充字符的控制符可以跟在%后使用：
- (hyphen，连字符)：不进行填充
_ (underscore，下划线)：以空格填充
0（zero）以0填充
^ 尽可能地使用大写输出
# 尽可能地按照相反的大小写进行输出

3.命令选项

-d, --date=STRING：显示由STRING指定的时间，而不是当前时间戳；
-f, --file=DATEFILE：显示DATEFILE文件中的每行时间；
-I[TIMESPEC], --iso-8601[=TIMESPEC]：以ISO 8601规范格式按照指定精度[TIMESPEC]显示时间。TIMESPEC默认取值为"date"，亦可取值'hours', 'minutes', 'seconds', 或 'ns'；
-r, --reference=FILE：显示文件的最后修改时间
-R, --rfc-2822：以RFC-2822规定格式显示时间，例如：Wed, 05 Dec 2018 22:10:34 +0800
--rfc-3339=TIMESPEC：以RFC 3339规定格式显示时间，可以由TIMESPEC指明精度，TIMESPEC可取值'date', 'seconds', or 'ns'。例如：2018-12-05 22:09:59.230994842+08:00
-s, --set=STRING：设置系统时间为STRING指定的时间
-u, --utc, --universal：显示或设定为协调世界时（UTC，Coordinated Universal Time）时间格式
--help：显示date命令的帮助信息
--version：显示date命令的版本信息

4.常用示例

（1）获取Unix时间戳。

date +%s
1544067345

（2）将Unix时间戳转换为可读时间。

date -d @1483525407
Wed Jan  4 18:23:27 CST 2017

date -d @1483525407 +"%F %T"
2017-01-04 18:23:27

注意：-d后需跟合法格式的日期，所以时间戳需要添加@符以示区别。

（3）格式化输出当前时间。

date +"%Y-%m-%d %H:%M:%S"
2018-12-06 10:57:33

#或
date +"%F %T"

（4）时间加减操作。

date +"%Y-%m-%d %H:%M:%S"     				//显示当前时间
date -d "+1 day" +"%Y-%m-%d %H:%M:%S"  		//显示前一天的时间
date -d "-1 day" +"%Y-%m-%d %H:%M:%S"  		//显示后一天的时间
date -d "-1 month" +"%Y-%m-%d %H:%M:%S"     //显示上一月的时间
date -d "+1 month" +"%Y-%m-%d %H:%M:%S"     //显示下一月的时间
date -d "-1 year" +"%Y-%m-%d %H:%M:%S"      //显示前一年的时间
date -d "+1 year" +"%Y-%m-%d %H:%M:%S"      //显示下一年的时间

（5）普通格式转换。

date -d "2009-12-12" +"%Y/%m/%d %H:%M:%S"
2009/12/12 00:00:00

（6）设置系统时间。

date -s "2016-11-11 00:00:00"
Fri Nov 11 00:00:00 CST 2016

date
Fri Nov 11 00:00:05 CST 2016

●ipcs 命令:
1.命令简介

ipcs 命令用于查看 Linux 进程间通信设施的状态，包括消息列表、共享内存和信号量的信息。可以帮助开发人员定位进程间通信中出现的问题。

注意，本文描述的是 util-linux 版 ipcs，和其它版本（如 POSIX 版）的实现可能会有出入。
2.命令格式

ipcs [resource-option] [output-format]
ipcs [resource-option] -i id

3.命令选项

-i，--id ID
	详细显示指定资源 ID 的 IPC 信息。使用时需要指定资源类型，资源包括消息队列（-q）、共享内存（-m）和信号量（-s）
-h，--help
	显示帮助信息
-V，--version
	显示版本信息

IPC 资源类型选项：
-q，--queues
	显示活动的消息队列信息
-m，--shmems
	显示活动的共享内存信息
-s, --semaphores
	显示活动的信号量信息
-a，--all
	显示系统内所有的IPC信息。命令的默认选项

输出格式选项：当指定多个时，以最后一个为准。
-c，--creator
	查看 IPC 的创建者和所有者
-l，--limits
	查看 IPC 资源的限制信息
-p，--pid
	查看 IPC 资源的创建者和最后操作者的进程 ID
-t，--time
	查看最新调用 IPC 资源的详细时间。包括 msgsnd() 和 msgrcv() 对 message queues 的操作，shmat() 和 shmdt() 对shared memory 的操作，以及 semop() 对 semaphores 的操作
-u，--summary
	查看 IPC 资源状态汇总信息

显示大小单位控制选项：只对选项 -l, --limits 生效
-b，--bytes
	以字节为单位显示大小
--human
	以可读的格式显示大小

4.常用示例

（1）显示所有IPC信息。

[root@TENCENT64 /]# ipcs
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status      
0x6674431e 0          root       600        50485760   9

------ Semaphore Arrays --------
key        semid      owner      perms      nsems     
0x0000870a 0          root       666        1    

（2）显示共享内存指定ID的信息。

[root@TENCENT64 /]# ipcs -m -i 32769

Shared memory Segment shmid=32769
uid=0	gid=0	cuid=0	cgid=0
mode=0666	access_perms=0666
bytes=12000	lpid=2784	cpid=1077	nattch=3
att_time=Thu Dec 27 10:39:32 2018  
det_time=Thu Dec 27 10:39:32 2018  
change_time=Fri Jul 20 13:17:41 2018 

（3）查看 IPC 的创建这和最最后操作者的进程 ID。

------ Message Queues PIDs --------
msqid      owner      lspid      lrpid     

------ Shared Memory Creator/Last-op PIDs --------
shmid      owner      cpid       lpid      
0          root       702        23364     
32769      root       702        5296      

其中 lspid 代表最近一次向消息队列中发送消息的“进程号”，lrpid 对应最近一次从消息队列中读取消息的“进程号”。但请注意：此处的进程号是弱进程号，既它有可能代表的是线程号，如果进程中是起的线程对消息队列发送、接收消息，则此处 pid 对应的均是线程号。可以采用ps -AL | grep pid来查找该线程对应的进程 id。

●ipcrm 命令:
1.命令简介

ipcrm 命令用于删除指定 ID 的 IPC（Inter-Process Communication，进程间通信）对象，包括消息队列（message queue）、共享内存（shared memory）和信号量（semaphore），同时将与 IPC 对象关联的数据一并删除，只有超级用户或 IPC 对象创建者能够删除。
2.命令格式

ipcrm [OPTIONS]
ipcrm {shm | msg | sem} ID...

3.选项说明

-a, --all [shm | msg | sem]
	删除所有 IPC 资源。当给定选项参数 shm、msg 或 sem，则只删除指定类型的 IPC 资源。注意：慎用该选项，否则可能会导致某些程序出于不确定状态
-M, --shmem-key SHMKEY
	当没有进程与共享内存段绑定时，通过 SHMKEY 删除共享内存段
-m, --shmem-id SHMID
	当没有进程与共享内存段绑定时，通过 SHMID 删除共享内存段
-Q, --queue-key MSGKEY
	通过 MSGKEY 删除消息队列
-q, --queue-id MSGID
	通过 MSGID 删除消息队列
-S, --semaphore-key SEMKEY
	通过 SEMKEY 删除信号量
-s, --semaphore-id SEMID
	通过 SEMID 删除信号量
-h, --help
	显示帮助信息并退出
-V, --version
	显示版本信息并退出
-v, --verbose
	以冗余模式执行 ipcrm，输出 rpcrm 正在做什么

4.常用示例

（1）删除共享内存。

ipcrm -M SHMKEY
# 或
ipcrm -m SHMID
# 或
ipcrm shm SHMID

（2）删除消息队列。

ipcrm -Q MSGKEY
# 或
ipcrm -q MSGID
# 或
rpcrm msg MSGID

（3）删除信号量。

ipcrm -S SEMKEY
# 或
ipcrm -s SEMID
# 或
ipcrm sem SEMID

（4）删除所有 IPC 资源。请谨慎使用。

ipcrm -v -a
removing shared memory segment id `0'
removing shared memory segment id `655361'
removing shared memory segment id `688130'
removing shared memory segment id `720899'
removing shared memory segment id `131076'
removing shared memory segment id `163845'
removing shared memory segment id `753670'
removing semaphore id `851968'
removing semaphore id `884737'
removing semaphore id `917506'
removing semaphore id `950275'
removing semaphore id `983044'
removing semaphore id `1015813'

（5）查看 ipcrm 版本。

ipcrm -V
ipcrm from util-linux 2.23.2

●exit 命令（builtin）:
1.简介

exit 命令是 Shell 内建命令，用于退出当前 Shell 进程。
2.命令格式

exit N

（1）状态码 N 的范围是 0-255，一般情况下，0 表示正常退出，非零表示异常退出。如果是 0-255 之外的数值，则会被强制转换为 uint8_t 类型的数值，比如 -1 会被转换为 255，256 会发生类型宽度截断，被转换为 0；
（2）状态码 N 可以不指定，默认是上一条命令的退出状态码。
3.常用示例

（1）退出终端。

exit

（2）用于Shell脚本，退出当前Shell进程。

#正常结果
exit 0

#异常退出
exit 1

（3）使用 trap 内建命令，用于挂载 Shell 进程结束前需要执行的命令。格式为：trap “commands” EXIT。如脚本exit.sh：

!/bin/bash

echo "start"
trap "echo 'end'" EXIT
echo "before exit"
exit 0

执行exit.sh输出：

start
before exit
end

●trap 命令（builtin）:
1.命令简介

trap 命令是 Shell 内建命令，用于指定在接收到信号后将要采取的动作。常见的用途是在脚本程序被中断时完成清理工作。
2.命令格式

trap [-lp] [ARG] [SIGSPECS]

3.选项说明

-l
	列出信号名称与对应的数值
-p
	列出信号与其绑定的命令列表
ARG
	与指定信号绑定的命令。如果 ARG 为空字符串，表示忽略信号；如果 ARG 不指定（缺省）或为 -，表示执行信号的默认动作
SIGSPECS
	信号列表，可以是信号名称，也可以是信号对应的数值。可用信号可以使用 trap -l 查看

4.常用示例

（1）忽略 HUP、INT、QUIT、TSTP 信号。

trap "" HUP INT QUIT TSTP

（2）捕获 HUP、INT、QUIT、TSTP 信号，并执行默认动作。

trap HUP INT QUIT TSTP
#或
trap - HUP INT QUIT TSTP

（3）挂载 Shell 进程结束前需要执行的命令。格式为：trap “commands” EXIT。如脚本 exit.sh：

#!/bin/bash

echo "start"
trap "echo 'end'" EXIT
echo "before exit"
exit 0

执行 exit.sh 输出：

start
before exit
end

5.信号简介

信号是一种进程间通信机制，它给应用程序提供一种异步的软件中断，使应用程序有机会接受其他程序发送的命令（即信号）。应用程序收到信号后，有三种处理方式：忽略、默认或捕捉。进程收到一个信号后，会检查对该信号的处理机制。如果是 SIG_IGN，就忽略该信号；如果是 SIG_DFT，则会采用系统默认的处理动作，通常是终止进程或忽略该信号；如果给该信号指定了一个处理函数，则会中断当前进程正在执行的任务，转而去执行该信号的处理函数，返回后再继续执行被中断的任务。

在有些情况下，我们不希望自己的 Shell 脚本在运行时被中断，比如说我们写的 Shell 脚本设为某一用户登录系统后默认执行的 Shell 脚本，使这一用户进入系统后只能做某一项工作，如数据库备份， 我们不希望用户使用 Ctrl+C 发送 SIGINT 信号来中断当前 Shell 脚本的执行，进入到 Shell 交互模式，做我们不希望做的事情。这便用到了信号处理。

以下是一些你可能会遇到的，要在程序中使用的常见的信号：
信号名称	信号数值	默认动作	描述
SIGHUP	1	终止进程	终端连接结束时发出。终端连接断开，会向当前终端连接会话关联的所有前台和后台进程组发送SIGHUP信号，用于终止进程。
SIGINT	2	终止进程	程序终止（Interrupt）信号，通常是由Ctrl+C发出。
SIGQUIT	3	终止进程	和SIGINT类似,通常是Ctrl+/发出。进程在收到SIGQUIT信号退出时会产生core文件, 在这个意义上类似于一个程序错误信号。
SIGFPE	8	终止进程，建立CORE文件	在发生致命的算术运算错误（Floating-Point Exception）时发出，不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术错误。
SIGKILL	9	终止进程	用来立即结束程序的运行。本信号不能被阻塞, 处理和忽略。
SIGSEGV	11	终止进程，建立CORE文件	段错误（Segmentation Fault）信号。进程试图访问非法内存地址，如往没有写权限的内存地址写数据时会触发段错误。
SIGALRM	14	终止进程	时钟定时信号, 计时器到时会发出该信号。alarm()函数使用该信号。
SIGTERM	15	终止进程	程序结束(Terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。Shell命令kill缺省产生这个信号。
SIGCHLD	17	忽略信号	子进程结束时, 父进程会收到这个信号

详细的信号列表，可以使用命令trap -l或kill -l查看，也可以查看头文件<signal.h>。例如，执行trap -l，查看系统支持的所有信号如下：

 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX

●netstat 命令:
1.命令简介

netstat 命令用来打印 Linux 系统的网络状态信息，包括网络连接（network connections）、路由表（routing tables）、网络接口设备统计信息（interface statistics）、伪连接（masquerade connections）和多播成员信息（multicast memberships）等，得知 Linux 系统网络的整体情况。

如我们可以通过 netstat 获知系统当前被监听的端口号列表。

netstat 是通过读取 /proc/net/ 路径下的 tcp、udp、unix 等文件来获取连接信息的。
2.命令格式

netstat [OPTIONS]

3.选项说明

-a, --all
	显示所有网络连接
-A，--protocol=FAMILY
	列出指定地址族的连接信息。FAMILY 为逗号分隔的地址族关键字列表，比如inet，inet6，unix，ipx，ax25，netrom，econet 和 ddp 等
-c,--continuous
	每隔 1s 刷新网络状态
-C
	从路由缓存获取路由信息
-e, --extend
	显示网络其他相关信息
-F
	显示 FIB 中的路由信息(默认选项) 
-g, --g
	显示 IPv4 和 IPv6 的多播组成员关系信息
-h, --help
	显示帮助信息
-i, -I=IFACE, --interfaces=IFACE
	显示所有网络接口或指定的网络接口
-l, --listening
	显示监听中的套接字(默认选项)
-M, --masquerade
	显示伪装的网络连接
-n, --numeric
	以数字形式而不是以符号显示主机、端口或用户名。
--numeric-hosts
	以数字形式显示主机地址
--numeric-ports
	以数字形式显示端口号
--numeric-users
	以数字形式显示用户名
-N, --netlink, --symbolic
	显示网络硬件外围设备的符号连接名称
-o, --timers
	显示计时器
-p, --programs
	显示正在使用 Socket 的进程 ID 和进程名
-r, --route
	显示内核路由表。命令 route -e 会产生同样的结果
-s, --statistice
	显示每种协议的统计信息
-t, --tcp
	显示TCP传输协议的连接状况
-u, --udp
	显示 UDP 传输协议的连接状况
-v, --verbose
	显示指令执行过程。特别是打印一些关于未配置地址族的有用信息
-V, --version
	显示版本信息
-w, --raw
	显示 RAW 传输协议的连接状况
-x, --unix
	此参数的效果和指定 "-A unix" 参数相同
--ip, --inet
	此参数的效果和指定 "-A inet" 参数相同

4.常用示例

（1）列出所有端口信息（包括监听和未监听的）。

    列出所有端口。

netstat -an
 Active Internet connections (servers and established)
 Proto Recv-Q Send-Q Local Address           Foreign Address         State
 tcp        0      0 localhost:30037         *:*                     LISTEN
 udp        0      0 *:bootpc                *:*
 
Active UNIX domain sockets (servers and established)
 Proto RefCnt Flags       Type       State         I-Node   Path
 unix  2      [ ACC ]     STREAM     LISTENING     6135     /tmp/.X11-unix/X0
 unix  2      [ ACC ]     STREAM     LISTENING     5140     /var/run/acpid.socket
 ...

    列出所有 tcp 端口。

netstat -ant

    列出所有 UDP 端口。

netstat -anu

（2）列出所有处于监听状态的连接。

    显示处于监听状态的所有连接。

netstat -ln
 Active Internet connections (only servers)
 Proto Recv-Q Send-Q Local Address           Foreign Address         State
 tcp        0      0 localhost:ipp           *:*                     LISTEN
 tcp6       0      0 localhost:ipp           [::]:*                  LISTEN
 udp        0      0 *:49119                 *:*

    只显示处于监听状态的 tcp 连接。

netstat -lnt

    只显示处于监听状态的 udp 连接。

netstat -lnu

    只显示处于监听状态的 unix 连接。

netstat -lnx

（3）显示每个协议的统计信息。

    显示所有端口的统计信息。

netstat -s
 Ip:
 11150 total packets received
 1 with invalid addresses
 0 forwarded
 0 incoming packets discarded
 11149 incoming packets delivered
 11635 requests sent out
 Icmp:
 0 ICMP messages received
 0 input ICMP message failed.
 Tcp:
 582 active connections openings
 2 failed connection attempts
 25 connection resets received
 Udp:
 1183 packets received
 4 packets to unknown port received.
 .....

    显示 TCP 端口的统计信息。

netstat -st 

    显示 UDP 端口统计信息。

netstat -su

（4）显示进程 ID 和名称。

netstat -p
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 10.234.178.144:43538    100.113.169.225:31415   ESTABLISHED -                   
tcp        0      0 10.234.178.144:33295    10.121.151.35:sd        ESTABLISHED 5354/VipMQAgent     
tcp        0      0 10.234.178.144:21095    100.92.40.70:bacula-dir ESTABLISHED 25164/pgg_login_cme

（5）以数字形式显示主机、端口和用户名。这样可以加速输出，因为不用进行比对查询。

netstat -n
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 10.234.178.144:43538    100.113.169.225:31415   ESTABLISHED
tcp        0      0 10.234.178.144:33295    10.121.151.35:9876      ESTABLISHED

如果只是不想让这三个名称中的一个被显示，使用以下命令

netsat -a --numeric-ports
netsat -a --numeric-hosts
netsat -a --numeric-users

（6）每隔一秒持续输出 netstat 信息。

netstat -c

（7）显示系统不支持的地址族 (Address Families)。

netstat --verbose

在输出的末尾，会有如下的信息

netstat: no support for `AF IPX' on this system.
netstat: no support for `AF AX25' on this system.
netstat: no support for `AF X25' on this system.
netstat: no support for `AF NETROM' on this system.

（8）显示核心路由信息。

netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         0.0.0.0         0.0.0.0         U         0 0          0 tunnat
9.0.0.0         10.175.82.193   255.0.0.0       UG        0 0          0 eth1
10.0.0.0        10.175.82.193   255.0.0.0       UG        0 0          0 eth1

注意：使用 netstat -rn 显示数字格式，不查询主机名称。

（9）找出程序运行的端口。并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息。

netstat -anp
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 10.175.82.204:61795     0.0.0.0:*               LISTEN      22006/./spp_pgg_dia 
tcp        0      0 10.175.82.204:55011     0.0.0.0:*               LISTEN      3228/./spp_pgg_vod_ 
tcp        0      0 10.175.82.204:10883     0.0.0.0:*               LISTEN      125115/./spp_pgg_co

（10）显示网络接口列表。

netstat -i
Kernel Interface table
Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth1      1500 32898847246      0      0 51410  34664370715      0      0      0 BMRU
lo       65536 57852071211      0      0 0      57852071211      0      0      0 LRU
tunnat    1480        0      0      0 0      103182603      0      0      0 OPRU

显示详细信息，可以使用 ifconfig 或者 netstat -ie。

netstat -ie
Kernel Interface table
eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.175.82.204  netmask 255.255.255.192  broadcast 10.175.82.255
        ether ec:f4:bb:e3:5b:b1  txqueuelen 10000  (Ethernet)
        RX packets 32900073183  bytes 21958447410400 (19.9 TiB)
        RX errors 0  dropped 0  overruns 51410  frame 0
        TX packets 34665611337  bytes 7109591105017 (6.4 TiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device memory 0x91d00000-91e00000
...

（11）IP 和 TCP 分析。

    查看本机连接的服务端口中连接数 TOP 的服务端 IP。其中 10.234.178.144:22 为本地 IP 端口。

netstat -ant | grep "10.234.178.144:22" |awk '{print $5}'|awk -F: '{print $1}'|sort|uniq -c|sort -nr|head -10
     24 100.112.141.208
      2 10.63.93.159
      2 10.191.131.38
      2 10.101.242.11
      2 100.92.40.70
      2 100.113.141.219
      2 100.112.159.163
      1 9.68.178.53
      1 10.191.134.83
      1 10.139.233.47

第二列为服务端IP，左边是本地发起的连接数。
（b）查看 TCP 各种状态列表。

netstat -ant | awk '{print $6}' | sort | uniq
CLOSE_WAIT
established)
ESTABLISHED
Foreign
LISTEN
TIME_WAIT

（12）显示多播组信息。

netstat -g
IPv6/IPv4 Group Memberships
Interface       RefCnt Group
--------------- ------ ---------------------
lo              1      all-systems.mcast.net
eth1            1      all-systems.mcast.net
tunnat          1      all-systems.mcast.net
lo              1      ff02::1
lo              1      ff01::1
eth0            1      ff02::1
eth0            1      ff01::1
eth1            1      ff02::1

netstat 的大部分功能都介绍了，如果想知道 netstat 更高级的功能，请参考 netstat 帮助手册。
5.输出结果整体说明

执行 netstat 命令输出：

Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 9.77.9.126:47239        100.115.0.57:9922       ESTABLISHED
tcp        0     52 9.77.9.126:36000        10.19.88.119:58814      ESTABLISHED
tcp        0      0 9.77.9.126:37586        10.170.31.139:nsesrvr   ESTABLISHED
udp        0      0 TENCENT64:acp-proto     TENCENT64:openwebnet    ESTABLISHED
udp        0      0 TENCENT64:4216          TENCENT64:openwebnet    ESTABLISHED
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node   Path
unix  2      [ ]         DGRAM                    307286163 /tmp/agent_cmd.sock
unix  2      [ ]         DGRAM                    9484     /var/run/nscd/socket
unix  2      [ ]         DGRAM                    275      /run/systemd/notify
...

从整体上看 netstat 的输出结果可以分为两个部分。一个是 Active Internet connections，二是 Active UNIX domain sockets。

（1）Active Internet connections。

Active Internet connections 表示活跃的网络连接，包括 UDP 和 TCP连接信息。

其中"Recv-Q"和"Send-Q"指接收队列和发送队列，这些数字一般都应该是0，如果不是则表示数据发送和接收队列存在堆积，这种情况较为少见。

Local Address 和 Foreign Address 表示本地和远端的 IP、端口；

State 表示连接的状态，主要有：

LISTEN：监听状态；
SYN_SEND：客户端在发送连接请求后进入SYN_SEND状态，等待服务端的连接请求和确认，即等待服务端发送SYN+ACK包；
SYN_RECV：服务端在收到客户端的连接请求后，发送SYN+ACK包后，进入SYN_RECV状态；
ESTABLISHED：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK后，客户端和服务器进入已建立连接状态；
FIN-WAIT-1：客户端发送连接中断请求后进入FIN-WAIT-1状态，等待服务端的确认；
FIN-WAIT-2：客户端接收到服务端的终端确认后进入FIN-WAIT-2状态，等待服务端的中断请求；
CLOSE-WAIT：服务端在确认客户端的中断请求后，进入CLOSE-WAIT状态，等待从本地用户发来的连接中断请求；
LAST-ACK：服务端向客户端发送连接中断请求后进入LAST-ACK状态，等待来自客户端的中断请求确认；
TIME-WAIT：客户端发送中断请求确认后进入TIME-WAIT状态，等待足够的时间（2MSL）以确保服务端接收到来自客户端的中断请求确认； 
CLOSED：四次挥手结束后，客户端和服务端进入连接断开状态。

（2）Active UNIX domain sockets。
Active UNIX domain sockets，称为活跃 Unix 域套接字。

Proto 显示连接使用的协议；
RefCnt 表示使用数量，即通过此套接字连接的进程数；
Flags 显示的标志为 SO_ACCEPTON（显示为 ACC）、SO_WAITDATA（W）或 SO_NOSPACE（N）。如果相应的进程等待一个连接请求，那么 SO_ACCECPTON 用于未连接的套接字。其它标志通常并不重要。
Types 显示套接口的类型，一般为 DGRAM（数据报）和 STREAM（数据流）；
State 显示套接字当前的状态，此字段包含以下关键字之一：

FREE：套接字未分配。
LISTENING：套接字正在监听一个连接请求。除非设置 --listening (-l) 或者 --all (-a) 选项，否则不显示。
CONNECTING：套接字正要建立连接
CONNECTED：套接字已连接
DISCONNECTING：套接字已断开
(empty)：套接字未连

I-Node 表示套接字的 Inode 节点号；
Path 表示套接字所在路径。

●telnet 命令:
1.简介

telnet 是基于 Telnet 协议的远程登录程序，用于登录远程主机，对远程主机进行管理。

telnet 因采用明文传送报文，安全性不好，很多 Linux 服务器都不开放 telnet 服务，而改用更安全的 ssh 方式了。但仍然有很多别的系统可能采用了 telnet 方式来提供远程登录，因此弄清楚 telnet 的使用方式仍是很有必要的。

telnet 命令还可做别的用途，比如确定远程服务器的某个端口是否能访问。

此外，Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登录服务的标准协议，属于应用层协议，基于 TCP 协议实现远程登录。
2.命令格式

telnet [-8EFKLacdfrx] [-X authtype] [-b hostalias] [-e escapechar] [-k realm] [-l user] [-n tracefile] [host [port]]

3.选项说明

-8
	允许使用 8 位字符资料，包括输入与输出
-a
	尝试自动登入远端系统
-b HOSTALIAS
	使用别名指定远端主机名称
-c
	不读取用户专属目录里的.telnetrc文件
-d
	启动排错模式
-e ESCAPECHAR
	设置转义字符
-E
	滤除转义字符
-f
	此选项的效果和指定 -F 相同
-F
	使用 Kerberos V5 认证时，加上此参数可把本地主机的认证数据上传到远端主机
-k <realm>
	使用 Kerberos 认证时，加上此参数让远端主机采用指定的域名，而非该主机的域名去获取票据
-K
	不自动登入远端主机
-l USER
	指定要登入远端主机的用户名称
-L
	允许输出 8 位字符资料
-n TRACEFILE
	指定文件记录相关信息
-r
	使用类似 rlogin 指令的用户界面
-x
	假设主机有支持数据加密的功能，就使用它
-X ATYPE
	关闭指定的认证类型

4.常用示例

（1）登录主机。不显示提供端口，默认为 23。

telnet 192.168.0.5

（2）确认远端服务器某个端口是否可用。比如查看远端服务器 ssh 服务的 22 号端口是否开放。

telnet 10.234.178.144 22
Trying 10.234.178.144...
Connected to 10.234.178.144.
Escape character is '^]'.
SSH-2.0-OpenSSH_6.0

以上表示远端服务器 ssh 服务的 22 号端口已经开放。注意，这并不表示使用 ssh 命令一定可以与远端服务器建立 SSH 链接，需要远端服务器的授权。

（3）进入命令行交互模式。
如果在没有 host 参数的情况下调用 telnet，它将进入命令模式，提示符为 telnet>。

telnet
telnet> 

交互模式下常用子命令有：

auth <argument> [...]：查看和管理telnet登录身份验证方式。argument可取值：disable、enable和status
close：关闭当前 Telnet 连接
display：使用 display 命令可以查看 Telnet 客户端的当前设置
logout：类似于cloase命令，用于关闭Telnet连接或者挂起。注：Telnet服务端可能不支持
open <host> [-l user] [[-] port]：建立到指定主机的 Telnet 连接
send <arguments>：使用send命令可以向Telnet服务器发送特定字符串。支持包括但不限于以下命令字符串：
	abort：终止服务命令
	ao：Abort Output，放弃输出命令
	ayt：Are you there命令
	brk：Break命令
	eof：发送End Of File字符
	escape：发送当前的转义字符，初始为分组符^]。
	ip：中断进程命令
	synch：执行Telnet同步操作。
quit：退出 Telnet 客户端。
status：显示当前Telnet连接状态

●objdump 命令:
1.功能简介

objdump 命令是 GNU Binutils 二进制工具集的一员，用于查看目标文件或可执行文件的组成信息，以可读的形式打印二进制文件的内容。
2.命令格式

objdump [OPTIONS] OBJFILES

3.选项说明

-a, --archive-headers
	显示档案头信息，展示档案每一个成员的文件格式。效果等同于命令 ar -tv
-b, --target=BFDNAME
	指定目标码格式。这不是必须的，objdump 能自动识别许多格式，比如 objdump -b oasys -m vax -h fu.o 显示 fu.o 的头部摘要信息，明确指出该文件是 Vax 系统下用 Oasys 编译器生成的目标文件。objdump -i 将给出这里可以指定的目标码格式列表
-C, --demangle[=STYLE]
	目标文件中的符号解码成用户级名称。比如移除符号修饰时在变量与函数名前添加的下划线等。
-d, --disassemble
	反汇编目标文件，将机器指令反汇编成汇编代码
-D, --disassemble-all
	与 -d 类似，但反汇编所有段（section）
-z, --disassemble-zeroes
	一般反汇编输出将省略零块，该选项使得这些零块也被反汇编 
-EB, -EL,--endian={big | little}
	指定目标文件的字节序，在目标文件没描述字节序时很有用，例如 S-records。这个选项只影响反汇编
-f, --file-headers
	显示每一个目标文件的头信息
-F, --file-offsets
	反汇编时，打印每一个符号的偏移地址
--file-start-context
	显示源码/汇编代码（假设为 -S）时，将上下文扩展到文件的开头
-g, --debugging
	显示调试信息。企图解析保存在文件中的调试信息并以 C 语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持
-e, --debugging-tags
	类似 -g 选项，但是生成的信息是和ctags工具相兼容的格式
-h, --section-headers, --headers
	显示目标文件各个 section 的头部摘要信息
-i, --info
	显示对于 -b 或者 -m 选项可用的架构和目标格式列表
-j, --section=NAME
	仅显示指定名称的 section 的信息 
-l, --line-numbers
	用文件名和行号标注相应的目标代码，仅仅和 -d、-D 或者 -r 一起使用
-S,--source
	反汇编时尽可能使用源代码表示。隐含了-d参数
-m, --architecture=MACHINE
	指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构
-M, --disassembler-options=OPTIONS
	给反汇编程序传递参数，可以指定多个，使用逗号分隔
-p, --private-headers
	打印目标文件格式的特定信息。打印的信息取决于目标文件格式，对于某些目标文件格式，不打印任何附加信息。
-P, --private=OPTIONS
	打印目标文件格式的特定信息。OPTIONS 是一个逗号分隔的列表。例如对于XCOFF，可用的选项有 header, aout, sections, syms, relocs, lineno, loader, except, typchk, traceback and toc
-r, --reloc
	显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来
-R, --dynamic-reloc
	显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库
-s, --full-contents
	显示section的完整内容。默认所有的非空section都会被显示
-W[lLiaprmfFsoRt],--dwarf=[rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges,=pubtypes,=trace_info,=trace_abbrev,=trace_aranges,=gdb_index]
	显示文件中调试段的内容，如果存在的话
-G, --stabs
	显示请求的任何 section 的全部内容。显示段 .stab、.stab.index 和 .stab.excl 的内容
-t, --syms
	显示文件的符号表入口。类似于nm -s提供的信息
-T, --dynamic-syms
	显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D,--dynamic 显示的信息
-x, --all-headers
	显示所可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -p -r -t 同时指定
-w, --wide
	为具有超过80列的输出设备格式化某些行。也不要在显示符号名称时截断符号名称
--start-address=ADDRESS
	从指定地址开始显示数据，该选项影响 -d、-r 和 -s 选项的输出
--stop-address=ADDRESS
	显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出
--prefix-addresses
	反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式
--no-show-raw-insn
	反汇编时，不显示汇编指令的机器码。当使用--prefix-addresses时，这是缺省选项
--adjust-vma=OFFSET
	当解析信息时，首先给所有的段添加偏移值offset。当段地址与符号表不符时，这个选项很有用。比如将段放置到特殊地址，因为某个格式无法表示段地址，比如 a.out
--special-syms
	显示特殊符号与用户不关心的符号
--prefix=PREFIX
	当使用 -S 时，指定前缀添加到绝对路径中
--prefix-strip=LEVEL
	指定剥离绝对路径中多少个前缀目录名。此选项只有在使用了选项 --prefix=PREFIX 才有效
--insn-width=WIDTH
	指定反汇编后的指令输出的行宽，单位字节
-V, --version
	版本信息
-H, --help
	帮助信息

4.常用示例

首先给出后面大部分测试所基于的源代码以及编译指令。 涉及两个 C++ 源文件。
objdump.cpp：

#include <iostream>

void print()
{
        std::cout<<"objdump"<<std::endl;
}

main.cpp：

#include <iostream>
using namespace std;

void print();

int main()
{
        print();
}

使用-g选项加入调试信息，分别编译生成目标文件objdump.o与main.o。

g++ -c -g objdump.cpp -o objdump.o
g++ -c -g main.cpp -o main.o

然后通过ar命令将两个目标文件打包成静态库libobjdump.a。

ar crv libobjdump.a main.o objdump.o

（1）查看档案包含的目标文件列表。

[root@TENCENT64 ~]# objdump -a libobjdump.a
In archive libobjdump.a:

main.o:     file format elf64-x86-64
rw-r--r-- 0/0  18696 Mar  8 20:25 2019 main.o

objdump.o:     file format elf64-x86-64
rw-r--r-- 0/0  21352 Mar  8 20:25 2019 objdump.o

使用命令ar -tv也可以列出档案中包含的目标文件。

[root@TENCENT64 ~]# ar -tv libobjdump.a
rw-r--r-- 0/0  18696 Mar  8 20:25 2019 main.o
rw-r--r-- 0/0  21352 Mar  8 20:25 2019 objdump.o

（2）显示目标文件objdump.o的代码段（.text）内容。

[root@TENCENT64 ~]# objdump --section=.text  -s objdump.o
objdump.o:     file format elf64-x86-64

Contents of section .text:
 0000 554889e5 be000000 00bf0000 0000e800  UH..............
 0010 000000be 00000000 4889c7e8 00000000  ........H.......
 0020 5dc35548 89e54883 ec10897d fc8975f8  ].UH..H....}..u.
 0030 837dfc01 7527817d f8ffff00 00751ebf  .}..u'.}.....u..
 0040 00000000 e8000000 00ba0000 0000be00  ................
 0050 000000bf 00000000 e8000000 00c9c355  ...............U
 0060 4889e5be ffff0000 bf010000 00e8b0ff  H...............
 0070 ffff5dc3                             ..].

注意，不能单独使用-j或者–section选项，一定要加上-s选项。

（3）反汇编objdump.o中的text段内容，并尽可能用源代码形式表示。

[root@TENCENT64 ~]# objdump --section=.text -S objdump.o
objdump.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 <_Z5printv>:
#include <iostream>

void print()
{
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
	std::cout<<"objdump"<<std::endl;
   4:	be 00 00 00 00       	mov    $0x0,%esi
   9:	bf 00 00 00 00       	mov    $0x0,%edi
   e:	e8 00 00 00 00       	callq  13 <_Z5printv+0x13>
  13:	be 00 00 00 00       	mov    $0x0,%esi
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <_Z5printv+0x20>
}
  20:	5d                   	pop    %rbp
  21:	c3                   	retq   

0000000000000022 <_Z41__static_initialization_and_destruction_0ii>:
  22:	55                   	push   %rbp
  23:	48 89 e5             	mov    %rsp,%rbp
  26:	48 83 ec 10          	sub    $0x10,%rsp
  2a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  2d:	89 75 f8             	mov    %esi,-0x8(%rbp)
  30:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  34:	75 27                	jne    5d <_Z41__static_initialization_and_destruction_0ii+0x3b>
  36:	81 7d f8 ff ff 00 00 	cmpl   $0xffff,-0x8(%rbp)
  3d:	75 1e                	jne    5d <_Z41__static_initialization_and_destruction_0ii+0x3b>
  extern wostream wclog;	/// Linked to standard error (buffered)
#endif
  //@}

  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;
  3f:	bf 00 00 00 00       	mov    $0x0,%edi
  44:	e8 00 00 00 00       	callq  49 <_Z41__static_initialization_and_destruction_0ii+0x27>
  49:	ba 00 00 00 00       	mov    $0x0,%edx
  4e:	be 00 00 00 00       	mov    $0x0,%esi
  53:	bf 00 00 00 00       	mov    $0x0,%edi
  58:	e8 00 00 00 00       	callq  5d <_Z41__static_initialization_and_destruction_0ii+0x3b>
  5d:	c9                   	leaveq 
  5e:	c3                   	retq   

000000000000005f <_GLOBAL__sub_I__Z5printv>:
  5f:	55                   	push   %rbp
  60:	48 89 e5             	mov    %rsp,%rbp
  63:	be ff ff 00 00       	mov    $0xffff,%esi
  68:	bf 01 00 00 00       	mov    $0x1,%edi
  6d:	e8 b0 ff ff ff       	callq  22 <_Z41__static_initialization_and_destruction_0ii>
  72:	5d                   	pop    %rbp
  73:	c3                   	retq

（3）显示目标文件的符号表入口。

[root@TENCENT64 ~]# objdump -t objdump.o
objdump.o:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000000 l    df *ABS*	0000000000000000 objdump.cpp
0000000000000000 l    d  .text	0000000000000000 .text
0000000000000000 l    d  .data	0000000000000000 .data
0000000000000000 l    d  .bss	0000000000000000 .bss
0000000000000000 l     O .bss	0000000000000001 _ZStL8__ioinit
0000000000000000 l    d  .rodata	0000000000000000 .rodata
0000000000000022 l     F .text	000000000000003d _Z41__static_initialization_and_destruction_0ii
000000000000005f l     F .text	0000000000000015 _GLOBAL__sub_I__Z5printv
0000000000000000 l    d  .init_array	0000000000000000 .init_array
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_aranges	0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack
0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 g     F .text	0000000000000022 _Z5printv
0000000000000000         *UND*	0000000000000000 _ZSt4cout
0000000000000000         *UND*	0000000000000000 _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
0000000000000000         *UND*	0000000000000000 _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
0000000000000000         *UND*	0000000000000000 _ZNSolsEPFRSoS_E
0000000000000000         *UND*	0000000000000000 _ZNSt8ios_base4InitC1Ev
0000000000000000         *UND*	0000000000000000 .hidden __dso_handle
0000000000000000         *UND*	0000000000000000 _ZNSt8ios_base4InitD1Ev
0000000000000000         *UND*	0000000000000000 __cxa_atexit

这里，输出的信息类似nm -s命令的输出，相比较之下，nm命令的输出如下：

[root@TENCENT64 ~]# nm -s objdump.o
                 U __cxa_atexit
                 U __dso_handle
000000000000005f t _GLOBAL__sub_I__Z5printv
0000000000000022 t _Z41__static_initialization_and_destruction_0ii
0000000000000000 T _Z5printv
                 U _ZNSolsEPFRSoS_E
                 U _ZNSt8ios_base4InitC1Ev
                 U _ZNSt8ios_base4InitD1Ev
                 U _ZSt4cout
                 U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
0000000000000000 b _ZStL8__ioinit
                 U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc

（4）显示目标文件各个段的头部摘要信息。

[root@TENCENT64 ~]# objdump -h objdump.o
objdump.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000074  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  000000b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000001  0000000000000000  0000000000000000  000000b4  2**2
                  ALLOC
  3 .rodata       00000008  0000000000000000  0000000000000000  000000b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000008  0000000000000000  0000000000000000  000000c0  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  5 .debug_info   000014f9  0000000000000000  0000000000000000  000000c8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_abbrev 0000039f  0000000000000000  0000000000000000  000015c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000030  0000000000000000  0000000000000000  00001960  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000244  0000000000000000  0000000000000000  00001990  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000e4c  0000000000000000  0000000000000000  00001bd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002d  0000000000000000  0000000000000000  00002a20  2**0
                  CONTENTS, READONLY
 11 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00002a4d  2**0
                  CONTENTS, READONLY
 12 .eh_frame     00000078  0000000000000000  0000000000000000  00002a50  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

●readelf 命令:
1.功能简介

readelf 用于读取 ELF（Executable and Linkable Format）格式文件的详细信息，包括目标文件、可执行文件、共享目标文件与核心转储文件。
1.1 ELF 文件分类

（1）可重定位文件（Relocatable File），这类文件包含了代码和数据，用于链接生成可以执行文件或共享目标文件，目标文件和静态链接库均属于可重定位文件，例如*.o或lib*.a文件；

（2）可执行文件（Executable File），用于生成进程映像，载入内存执行。Linux 环境下的 ELF 可执行文件一般没有扩展名，例如用户命令 ls；

（3）共享目标文件（Shared Object File），这种文件包含了代码和数据，用于和可重定位文件或其他共享目标文件一起生成可执行文件。例如 Linux 的动态共享对象（Dynamic Shared Object），C 语言运行时库 glibc-2.5.so；

（4）核心转储文件（Core Dump File），当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件。例如 Linux 下的 core dump。
1.2 ELF 文件组成

ELF 文件头描述了 ELF 文件的总体信息，包括系统相关、类型相关、加载相关和链接相关的信息。
（1）系统相关，比如ELF 文件标识的魔数，以及硬件和平台等相关信息，增加了 ELF 文件的移植性，使交叉编译成为可能；
（2）类型相关，比如 ELF 文件类型，分别有目标文件、可执行文件、动态链接库与核心转储文件；
（3）加载相关，比如程序头，描述了 ELF 文件被加载时的段信息；
（4）链接相关，比如节头，描述了 ELF 文件的节信息。
2.命令格式

readelf <option> <elffile...>

3.选项说明

运行 readelf 的时候，除了 -v 和 -H 之外，其它的选项必须有一个被指定。

-a,--all：显示全部信息，等价于 -h -l -S -s -r -d -V -A -I
-h,--file-header：显示文件头信息
-l,--program-headers,--segments：显示程序头（如果有的话）
-S,--section-headers,--sections：显示节头信息（如果有的话）
-g,--section-groups：显示节组信息（如果有的话）
-t,--section-details：显示节的详细信息（-S的）
-s,--syms,--symbols：显示符号表节中的项（如果有的话）
--dyn-syms：显示动态符号表节中的项（如果有的话）
-e,--headers：显示全部头信息，等价于-h -l -S
-n,--notes：显示note段（内核注释）的信息
-r,--relocs：显示可重定位段的信息。 
-u,--unwind：显示unwind段信息。当前只支持IA64 ELF的unwind段信息。 
-d,--dynamic：显示动态段的信息
-V,--version-info：显示版本段的信息
-A ,--arch-specific：显示CPU构架信息
-D,--use-dynamic：使用动态符号表显示符号，而不是符号表
-x <number or name>,--hex-dump=<number or name>：以16进制方式显示指定节内容。number指定节表中节的索引，或字符串指定文件中的节名
-R <number or name>,--relocated-dump=<number or name>：以16进制方式显示指定节内容。number指定节表中节的索引，或字符串指定文件中的节名。节的内容被展示前将被重定位。
-p <number or name>,--string-dump=<number or name>：以可打印的字符串显示指定节内容。number指定节表中节的索引，或字符串指定文件中的节名。
-c,--archive-index：展示档案头中的文件符号索引信息，执行与 ar 的 t 命令相同的功能，但不使用 BFD 库
-w[liaprmfFsoR],--debug-dump[=line,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges]：显示调试段中指定的内容
--dwarf-depth=n：将“.debug_info”节的转储限制为n个子级。这只对--debug dump=info有用。默认为打印所有DIE（debugging information entry）；n的特殊值0也将具有此效果
--dwarf-start=n：只打印以编号为n的模具开始的DIE，仅适用于使用--debug dump=info选项时。该选项可以与--dwarf-depth=n连用。
-I,--histogram：显示符号的时候，显示 bucket list 长度的柱状图
-v,--version：显示 readelf 的版本信息
-H,--help：显示 readelf 所支持的命令行选项
-W,--wide：宽行输出
@file：可以将选项集中到一个文件中，然后使用这个 @file 选项载入

4.常用示例
4.1准备工作

（1）首先生成可执行文件形式的 ELF 文件。

//
//@file：main.cpp
//

#include <iostream>

void print();

int main()
{
        std::cout<<"objdump"<<std::endl;
}

使用g++，分别不使用和使用-g选项，编译生成可执行文件main.out和main.debug.out。

g++ main.cpp -o main.out
g++ -g main.cpp -o main.debug.out

ll
-rw-r--r-- 1 root root     74 Mar 21 11:48 main.cpp
-rwxr-xr-x 1 root root   9119 Mar 21 11:49 main.out
-rwxr-xr-x 1 root root  19695 Mar 21 11:49 main.debug.out

可见，因为加入了调试信息，main.debug.out 的大小明显比 main.out 大很多。

（2）生成库文件。

//
//@file：print.cpp
//

#include <iostream>

void print()
{
        std::cout<<"readelf"<<std::endl;
}

使用g++和ar，分别生成静态链接库libprint.a和动态链接库libprint.so。

# 生成静态库libmy.a
g++ -c print.cpp -o print.o
ar c libprint.a print.o

#生成动态库libprint.so
g++ -shared -fPIC -o libprint.so print.cpp

编译之后，查看生成的文件。

ll
-rw-r--r-- 1 root root   2810 Mar 21 13:50 libprint.a
-rwxr-xr-x 1 root root   8613 Mar 21 13:56 libprint.so
-rw-r--r-- 1 root root    104 Mar 21 13:40 print.cpp
-rw-r--r-- 1 root root   2664 Mar 21 13:40 print.o

基于以上可执行文件和库，下面给出一些常用的示例。
4.2 常用示例

（1）读取可执行文件形式的 ELF 文件头信息。

readelf -h main.out 
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400780
  Start of program headers:          64 (bytes into file)
  Start of section headers:          4496 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         30
  Section header string table index: 27

从Type:EXEC (Executable file)可以看出其类型为 EXEC（可执行文件）。并且可以看出文件的体系结构为 x86-64。另外，含调试信息的"main.debug.out"和不含调试信息的"main"除了一些大小信息之外，其内容是一样的。

（2）读取目标文件形式的 ELF 文件头信息。

readelf -h print.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          488 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         15
  Section header string table index: 12

可见目标文件的elf文件，其类型为REL(可重定位文件)。且相对于可执行文件，目标文件没有程序头（段头）信息。

（3）读取静态库文件形式的 ELF 文件头信息。

readelf -h libprint.a 

File: libprint.a(print.o)
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          488 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         15
  Section header string table index: 12

可见静态库文件的elf文件，其类型为REL（可重定位文件），且没有程序头（段头）信息。

（4）读取动态库文件形式的 ELF 文件头信息。

readelf -h libprint.so 
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x870
  Start of program headers:          64 (bytes into file)
  Start of section headers:          4464 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         7
  Size of section headers:           64 (bytes)
  Number of section headers:         28
  Section header string table index: 25

这里，可见动态库其类型为DYN（共享目标文件），和可执行文件类似，同样拥有程序头（段头）信息。

（5）查看可执行的 ELF 文件程序头信息。

readelf -l main.out 

Elf file type is EXEC (Executable file)
Entry point 0x400780
There are 9 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x00000000000001f8 0x00000000000001f8  R E    8
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000b04 0x0000000000000b04  R E    200000
  LOAD           0x0000000000000dd8 0x0000000000600dd8 0x0000000000600dd8
                 0x0000000000000284 0x00000000000003a0  RW     200000
  DYNAMIC        0x0000000000000df8 0x0000000000600df8 0x0000000000600df8
                 0x0000000000000200 0x0000000000000200  RW     8
  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                 0x0000000000000044 0x0000000000000044  R      4
  GNU_EH_FRAME   0x000000000000098c 0x000000000040098c 0x000000000040098c
                 0x0000000000000044 0x0000000000000044  R      4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     10
  GNU_RELRO      0x0000000000000dd8 0x0000000000600dd8 0x0000000000600dd8
                 0x0000000000000228 0x0000000000000228  R      1

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 
   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag .note.gnu.build-id 
   06     .eh_frame_hdr 
   07     
   08     .init_array .fini_array .jcr .dynamic .got

注意：含调试信息的可执行文件"main.debug.out"和不含调试信息的"main.out"其内容是一样的。

（6）查看动态库 ELF 文件程序头信息。

readelf -l libprint.so 

Elf file type is DYN (Shared object file)
Entry point 0x870
There are 7 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000acc 0x0000000000000acc  R E    200000
  LOAD           0x0000000000000da8 0x0000000000200da8 0x0000000000200da8
                 0x00000000000002a0 0x00000000000002a8  RW     200000
  DYNAMIC        0x0000000000000dd0 0x0000000000200dd0 0x0000000000200dd0
                 0x00000000000001f0 0x00000000000001f0  RW     8
  NOTE           0x00000000000001c8 0x00000000000001c8 0x00000000000001c8
                 0x0000000000000024 0x0000000000000024  R      4
  GNU_EH_FRAME   0x00000000000009f8 0x00000000000009f8 0x00000000000009f8
                 0x000000000000002c 0x000000000000002c  R      4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     10
  GNU_RELRO      0x0000000000000da8 0x0000000000200da8 0x0000000000200da8
                 0x0000000000000258 0x0000000000000258  R      1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 
   01     .init_array .fini_array .jcr .data.rel.ro .dynamic .got .got.plt .bss 
   02     .dynamic 
   03     .note.gnu.build-id 
   04     .eh_frame_hdr 
   05     
   06     .init_array .fini_array .jcr .data.rel.ro .dynamic .got

（7）查看一个可执行的 ELF 文件的节头信息。

readelf -S main.out
There are 30 section headers, starting at offset 0x1190:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000400238  00000238
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.ABI-tag     NOTE             0000000000400254  00000254
       0000000000000020  0000000000000000   A       0     0     4
  [ 3] .note.gnu.build-i NOTE             0000000000400274  00000274
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298
       0000000000000030  0000000000000000   A       5     0     8
  [ 5] .dynsym           DYNSYM           00000000004002c8  000002c8
       0000000000000138  0000000000000018   A       6     1     8
  [ 6] .dynstr           STRTAB           0000000000400400  00000400
       0000000000000180  0000000000000000   A       0     0     1
  [ 7] .gnu.version      VERSYM           0000000000400580  00000580
       000000000000001a  0000000000000002   A       5     0     2
  [ 8] .gnu.version_r    VERNEED          00000000004005a0  000005a0
       0000000000000040  0000000000000000   A       6     2     8
  [ 9] .rela.dyn         RELA             00000000004005e0  000005e0
       0000000000000030  0000000000000018   A       5     0     8
  [10] .rela.plt         RELA             0000000000400610  00000610
       00000000000000c0  0000000000000018   A       5    12     8
  [11] .init             PROGBITS         00000000004006d0  000006d0
       000000000000001a  0000000000000000  AX       0     0     4
  [12] .plt              PROGBITS         00000000004006f0  000006f0
       0000000000000090  0000000000000010  AX       0     0     16
  [13] .text             PROGBITS         0000000000400780  00000780
       00000000000001e4  0000000000000000  AX       0     0     16
  [14] .fini             PROGBITS         0000000000400964  00000964
       0000000000000009  0000000000000000  AX       0     0     4
  [15] .rodata           PROGBITS         0000000000400970  00000970
       000000000000001c  0000000000000000   A       0     0     8
  [16] .eh_frame_hdr     PROGBITS         000000000040098c  0000098c
       0000000000000044  0000000000000000   A       0     0     4
  [17] .eh_frame         PROGBITS         00000000004009d0  000009d0
       0000000000000134  0000000000000000   A       0     0     8
  [18] .init_array       INIT_ARRAY       0000000000600dd8  00000dd8
       0000000000000010  0000000000000000  WA       0     0     8
  [19] .fini_array       FINI_ARRAY       0000000000600de8  00000de8
       0000000000000008  0000000000000000  WA       0     0     8
  [20] .jcr              PROGBITS         0000000000600df0  00000df0
       0000000000000008  0000000000000000  WA       0     0     8
  [21] .dynamic          DYNAMIC          0000000000600df8  00000df8
       0000000000000200  0000000000000010  WA       6     0     8
  [22] .got              PROGBITS         0000000000600ff8  00000ff8
       0000000000000008  0000000000000008  WA       0     0     8
  [23] .got.plt          PROGBITS         0000000000601000  00001000
       0000000000000058  0000000000000008  WA       0     0     8
  [24] .data             PROGBITS         0000000000601058  00001058
       0000000000000004  0000000000000000  WA       0     0     4
  [25] .bss              NOBITS           0000000000601060  0000105c
       0000000000000118  0000000000000000  WA       0     0     32
  [26] .comment          PROGBITS         0000000000000000  0000105c
       000000000000002c  0000000000000001  MS       0     0     1
  [27] .shstrtab         STRTAB           0000000000000000  00001088
       0000000000000108  0000000000000000           0     0     1
  [28] .symtab           SYMTAB           0000000000000000  00001910
       00000000000006f0  0000000000000018          29    48     8
  [29] .strtab           STRTAB           0000000000000000  00002000
       000000000000039f  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

（8）查看一个包含调试信息的可执行的 ELF 文件的节头信息。

readelf -S main.debug.out
There are 35 section headers, starting at offset 0x3928:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000400238  00000238
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.ABI-tag     NOTE             0000000000400254  00000254
       0000000000000020  0000000000000000   A       0     0     4
  [ 3] .note.gnu.build-i NOTE             0000000000400274  00000274
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298
       0000000000000030  0000000000000000   A       5     0     8
  [ 5] .dynsym           DYNSYM           00000000004002c8  000002c8
       0000000000000138  0000000000000018   A       6     1     8
  [ 6] .dynstr           STRTAB           0000000000400400  00000400
       0000000000000180  0000000000000000   A       0     0     1
  [ 7] .gnu.version      VERSYM           0000000000400580  00000580
       000000000000001a  0000000000000002   A       5     0     2
  [ 8] .gnu.version_r    VERNEED          00000000004005a0  000005a0
       0000000000000040  0000000000000000   A       6     2     8
  [ 9] .rela.dyn         RELA             00000000004005e0  000005e0
       0000000000000030  0000000000000018   A       5     0     8
  [10] .rela.plt         RELA             0000000000400610  00000610
       00000000000000c0  0000000000000018   A       5    12     8
  [11] .init             PROGBITS         00000000004006d0  000006d0
       000000000000001a  0000000000000000  AX       0     0     4
  [12] .plt              PROGBITS         00000000004006f0  000006f0
       0000000000000090  0000000000000010  AX       0     0     16
  [13] .text             PROGBITS         0000000000400780  00000780
       00000000000001e4  0000000000000000  AX       0     0     16
  [14] .fini             PROGBITS         0000000000400964  00000964
       0000000000000009  0000000000000000  AX       0     0     4
  [15] .rodata           PROGBITS         0000000000400970  00000970
       000000000000001c  0000000000000000   A       0     0     8
  [16] .eh_frame_hdr     PROGBITS         000000000040098c  0000098c
       0000000000000044  0000000000000000   A       0     0     4
  [17] .eh_frame         PROGBITS         00000000004009d0  000009d0
       0000000000000134  0000000000000000   A       0     0     8
  [18] .init_array       INIT_ARRAY       0000000000600dd8  00000dd8
       0000000000000010  0000000000000000  WA       0     0     8
  [19] .fini_array       FINI_ARRAY       0000000000600de8  00000de8
       0000000000000008  0000000000000000  WA       0     0     8
  [20] .jcr              PROGBITS         0000000000600df0  00000df0
       0000000000000008  0000000000000000  WA       0     0     8
  [21] .dynamic          DYNAMIC          0000000000600df8  00000df8
       0000000000000200  0000000000000010  WA       6     0     8
  [22] .got              PROGBITS         0000000000600ff8  00000ff8
       0000000000000008  0000000000000008  WA       0     0     8
  [23] .got.plt          PROGBITS         0000000000601000  00001000
       0000000000000058  0000000000000008  WA       0     0     8
  [24] .data             PROGBITS         0000000000601058  00001058
       0000000000000004  0000000000000000  WA       0     0     4
  [25] .bss              NOBITS           0000000000601060  0000105c
       0000000000000118  0000000000000000  WA       0     0     32
  [26] .comment          PROGBITS         0000000000000000  0000105c
       000000000000002c  0000000000000001  MS       0     0     1
  [27] .debug_aranges    PROGBITS         0000000000000000  00001088
       0000000000000030  0000000000000000           0     0     1
  [28] .debug_info       PROGBITS         0000000000000000  000010b8
       00000000000014f9  0000000000000000           0     0     1
  [29] .debug_abbrev     PROGBITS         0000000000000000  000025b1
       000000000000039f  0000000000000000           0     0     1
  [30] .debug_line       PROGBITS         0000000000000000  00002950
       0000000000000241  0000000000000000           0     0     1
  [31] .debug_str        PROGBITS         0000000000000000  00002b91
       0000000000000c4e  0000000000000001  MS       0     0     1
  [32] .shstrtab         STRTAB           0000000000000000  000037df
       0000000000000148  0000000000000000           0     0     1
  [33] .symtab           SYMTAB           0000000000000000  000041e8
       0000000000000768  0000000000000018          34    53     8
  [34] .strtab           STRTAB           0000000000000000  00004950
       000000000000039f  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

可见，相对非调试版本的可执行文件，多了些".debug*"节的信息。

（9）查看一个目标文件的 ELF 文件的节头信息。

readelf -S print.o
There are 15 section headers, starting at offset 0x1e8:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000074  0000000000000000  AX       0     0     4
  [ 2] .rela.text        RELA             0000000000000000  00000900
       0000000000000108  0000000000000018          13     1     8
  [ 3] .data             PROGBITS         0000000000000000  000000b4
       0000000000000000  0000000000000000  WA       0     0     4
  [ 4] .bss              NOBITS           0000000000000000  000000b4
       0000000000000001  0000000000000000  WA       0     0     4
  [ 5] .rodata           PROGBITS         0000000000000000  000000b4
       0000000000000008  0000000000000000   A       0     0     1
  [ 6] .init_array       INIT_ARRAY       0000000000000000  000000c0
       0000000000000008  0000000000000000  WA       0     0     8
  [ 7] .rela.init_array  RELA             0000000000000000  00000a08
       0000000000000018  0000000000000018          13     6     8
  [ 8] .comment          PROGBITS         0000000000000000  000000c8
       000000000000002d  0000000000000001  MS       0     0     1
  [ 9] .note.GNU-stack   PROGBITS         0000000000000000  000000f5
       0000000000000000  0000000000000000           0     0     1
  [10] .eh_frame         PROGBITS         0000000000000000  000000f8
       0000000000000078  0000000000000000   A       0     0     8
  [11] .rela.eh_frame    RELA             0000000000000000  00000a20
       0000000000000048  0000000000000018          13    10     8
  [12] .shstrtab         STRTAB           0000000000000000  00000170
       0000000000000072  0000000000000000           0     0     1
  [13] .symtab           SYMTAB           0000000000000000  000005a8
       0000000000000210  0000000000000018          14    13     8
  [14] .strtab           STRTAB           0000000000000000  000007b8
       0000000000000145  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

（10）查看一个静态库文件的 ELF 文件的节头信息。

readelf -S libprint.a

File: libprint.a(print.o)
There are 15 section headers, starting at offset 0x1e8:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000074  0000000000000000  AX       0     0     4
  [ 2] .rela.text        RELA             0000000000000000  00000900
       0000000000000108  0000000000000018          13     1     8
  [ 3] .data             PROGBITS         0000000000000000  000000b4
       0000000000000000  0000000000000000  WA       0     0     4
  [ 4] .bss              NOBITS           0000000000000000  000000b4
       0000000000000001  0000000000000000  WA       0     0     4
  [ 5] .rodata           PROGBITS         0000000000000000  000000b4
       0000000000000008  0000000000000000   A       0     0     1
  [ 6] .init_array       INIT_ARRAY       0000000000000000  000000c0
       0000000000000008  0000000000000000  WA       0     0     8
  [ 7] .rela.init_array  RELA             0000000000000000  00000a08
       0000000000000018  0000000000000018          13     6     8
  [ 8] .comment          PROGBITS         0000000000000000  000000c8
       000000000000002d  0000000000000001  MS       0     0     1
  [ 9] .note.GNU-stack   PROGBITS         0000000000000000  000000f5
       0000000000000000  0000000000000000           0     0     1
  [10] .eh_frame         PROGBITS         0000000000000000  000000f8
       0000000000000078  0000000000000000   A       0     0     8
  [11] .rela.eh_frame    RELA             0000000000000000  00000a20
       0000000000000048  0000000000000018          13    10     8
  [12] .shstrtab         STRTAB           0000000000000000  00000170
       0000000000000072  0000000000000000           0     0     1
  [13] .symtab           SYMTAB           0000000000000000  000005a8
       0000000000000210  0000000000000018          14    13     8
  [14] .strtab           STRTAB           0000000000000000  000007b8
       0000000000000145  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

（11）查看一个动态库文件的 ELF 文件的节头信息。

readelf -S libprint.so
There are 28 section headers, starting at offset 0x1170:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .note.gnu.build-i NOTE             00000000000001c8  000001c8
       0000000000000024  0000000000000000   A       0     0     4
  [ 2] .gnu.hash         GNU_HASH         00000000000001f0  000001f0
       000000000000003c  0000000000000000   A       3     0     8
  [ 3] .dynsym           DYNSYM           0000000000000230  00000230
       00000000000001e0  0000000000000018   A       4     2     8
  [ 4] .dynstr           STRTAB           0000000000000410  00000410
       00000000000001ab  0000000000000000   A       0     0     1
  [ 5] .gnu.version      VERSYM           00000000000005bc  000005bc
       0000000000000028  0000000000000002   A       3     0     2
  [ 6] .gnu.version_r    VERNEED          00000000000005e8  000005e8
       0000000000000040  0000000000000000   A       4     2     8
  [ 7] .rela.dyn         RELA             0000000000000628  00000628
       0000000000000120  0000000000000018   A       3     0     8
  [ 8] .rela.plt         RELA             0000000000000748  00000748
       0000000000000090  0000000000000018   A       3    10     8
  [ 9] .init             PROGBITS         00000000000007d8  000007d8
       000000000000001a  0000000000000000  AX       0     0     4
  [10] .plt              PROGBITS         0000000000000800  00000800
       0000000000000070  0000000000000010  AX       0     0     16
  [11] .text             PROGBITS         0000000000000870  00000870
       0000000000000174  0000000000000000  AX       0     0     16
  [12] .fini             PROGBITS         00000000000009e4  000009e4
       0000000000000009  0000000000000000  AX       0     0     4
  [13] .rodata           PROGBITS         00000000000009ed  000009ed
       0000000000000008  0000000000000000   A       0     0     1
  [14] .eh_frame_hdr     PROGBITS         00000000000009f8  000009f8
       000000000000002c  0000000000000000   A       0     0     4
  [15] .eh_frame         PROGBITS         0000000000000a28  00000a28
       00000000000000a4  0000000000000000   A       0     0     8
  [16] .init_array       INIT_ARRAY       0000000000200da8  00000da8
       0000000000000010  0000000000000000  WA       0     0     8
  [17] .fini_array       FINI_ARRAY       0000000000200db8  00000db8
       0000000000000008  0000000000000000  WA       0     0     8
  [18] .jcr              PROGBITS         0000000000200dc0  00000dc0
       0000000000000008  0000000000000000  WA       0     0     8
  [19] .data.rel.ro      PROGBITS         0000000000200dc8  00000dc8
       0000000000000008  0000000000000000  WA       0     0     8
  [20] .dynamic          DYNAMIC          0000000000200dd0  00000dd0
       00000000000001f0  0000000000000010  WA       4     0     8
  [21] .got              PROGBITS         0000000000200fc0  00000fc0
       0000000000000040  0000000000000008  WA       0     0     8
  [22] .got.plt          PROGBITS         0000000000201000  00001000
       0000000000000048  0000000000000008  WA       0     0     8
  [23] .bss              NOBITS           0000000000201048  00001048
       0000000000000008  0000000000000000  WA       0     0     4
  [24] .comment          PROGBITS         0000000000000000  00001048
       000000000000002c  0000000000000001  MS       0     0     1
  [25] .shstrtab         STRTAB           0000000000000000  00001074
       00000000000000f9  0000000000000000           0     0     1
  [26] .symtab           SYMTAB           0000000000000000  00001870
       0000000000000600  0000000000000018          27    46     8
  [27] .strtab           STRTAB           0000000000000000  00001e70
       0000000000000335  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

●c++filt 命令：
1.命令简介

c++filt 命令可用于解析 C++ 和 Java 中被修饰的符号，比如变量与函数名称。

我们知道， 在 C++ 和 Java 中， 允许函数重载，也就是说我们可以写出多个同名但参数类型不同的函数，其实现依赖于编译器的名字改编（Name Mangling）机制，即编译器会将函数的名称进行修饰，加入参数信息。考察如下程序：

//
//@file:print.cpp
//

#include <iostream>
#include <string>
using namespace std;

const int dTest=0;

void print(const string& strElfFileName)
{
        std::cout<<"readelf "<<strElfFileName<<std::endl;
}

使用 g++ 编译上面的 print.cpp 生成目标文件 print.o。

g++ -c print.cpp -o print.o

然后使用命令 strings 查找 print.o 中的可打印字符串。

strings print.o
readelf 
GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-4)
.symtab
.strtab
.shstrtab
.rela.text
.data
.bss
.rodata
.rela.init_array
.comment
.note.GNU-stack
.rela.eh_frame
print.cpp
_ZStL8__ioinit
_Z41__static_initialization_and_destruction_0ii
_ZL5dTest
_GLOBAL__sub_I__Z5printRKSs
_Z5printRKSs
_ZSt4cout
_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
_ZStlsIcSt11char_traitsIcESaIcEERSt13basic_ostreamIT_T0_ES7_RKSbIS4_S5_T1_E
_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
_ZNSolsEPFRSoS_E
_ZNSt8ios_base4InitC1Ev
__dso_handle
_ZNSt8ios_base4InitD1Ev
__cxa_atexit

找到其中两个字符串，分别是_ZL5dTest 和 _Z5printRKSs ，根据其包含的内容，我们大致能够猜测，两个字符串分别对应源码中的常量 dTest 和函数 print()。使用 c++filt 进行符号解析（symbol demangling）来验证我们的猜想。

c++filt _ZL5dTest
dTest

c++filt _Z5printRKSs
print(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)

猜测正确，源码文件中的变量名和函数名被修饰后，通过 c++filt 命令可以还原回来，这正是 c++filt 命令的功能。
2.命令格式

c++filt [-_|--strip-underscore]
		[-n|--no-strip-underscore]
		[-p|--no-params]
		[-t|--types]
		[-i|--no-verbose]
		[-s format|--format=format]
		[--help]  [--version]  [symbol...]

注意，如果没有给出符号参数 [symbol…]，c++filt 将从标准输入中读取符号名称。
3.选项说明

-_, --strip-underscore
	在某些系统中，C和C++编译器都在每个名字前面加下划线。例如，C 名称 foo 获得低级名称为 _foo。此选项用于删除初始下划线，c++filt 是否默认删除下划线是依赖于目标的
-n, --no-strip-underscore
	不删除初始下划线
-p, --no-params
	当解析函数名时，不显示函数参数的类型
-t, --types
	试图解析类型与函数名
-i, --no-verbose
	输出结果中不包括任何实现细节
-s, --format=FORMAT
	c++filt 可以解析不同编译器修饰的符号，此选项用于指明符号修饰所采用的方法：
	"auto"：根据可执行文件自动选择符号解析方法，此为默认选项
	"gnu"： GNU C++ compiler （g++）的符号修饰方法
	"lucid"： Lucid compiler （lcc）的符号修饰方法
	"arm"：C++ Annotated Reference Manual 指明的方法
	"hp"：HP compiler （aCC）的符号修饰方法
	"edg"：EDG compiler 的符号修饰方法
	"gnu-v3"：GNU C++ compiler (g++) with the V3 ABI 的符号修饰方法
	"java"：GNU Java compiler （gcj）的符号修饰方法
	"gnat"：GNU Ada compiler (GNAT) 的符号修饰方法
--help
	显示帮助信息
--version
	显示版本信息
@FILE
	从文件 FILE 中读取命令行选项，读取的选项将插入到 @FILE 选项的位置。如果文件不存在，或者无法读取，那么选项 @FILE 将被按照字面意义处理，而不是被忽略

4.常用示例

（1）解析编译器 g++ 修饰的函数名称。还是以第一节“1.命令简介”中函数 print() 的名字为例。

c++filt -s gnu-v3 _Z5printRKSs
print(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)

（2）解析编译器 g++ 修饰的函数名称，但不显示函数参数类型。

c++filt -p _Z5printRKSs
print

（3）解析编译器 g++ 修饰的变量名称。还是以第一节“1.命令简介”中变量 dTest 的名字为例。

c++filt _ZL5dTest
dTest

●strip 命令：
1.命令简介

strip 命令是 GNU Binutils 中的一员，用于剥掉目标文件中一些符号信息和调试信息，使文件变小。
2.命令格式

strip [-F bfdname |--target=bfdname]
	  [-I bfdname |--input-target=bfdname]
      [-O bfdname |--output-target=bfdname]
      [-s|--strip-all]
      [-S|-g|-d|--strip-debug]
      [--strip-dwo]
      [-K symbolname |--keep-symbol=symbolname]
      [-N symbolname |--strip-symbol=symbolname]
      [-w|--wildcard]
      [-x|--discard-all] [-X |--discard-locals]
      [-R sectionname |--remove-section=sectionname]
      [-o file] [-p|--preserve-dates]
      [-D|--enable-deterministic-archives]
      [-U|--disable-deterministic-archives]
      [--keep-file-symbols]
      [--only-keep-debug]
      [-v |--verbose] [-V|--version]
      [--help] [--info]
      objfile...

3.选项说明

	  [-F bfdname |--target=bfdname]：使用指定的二进制文件格式（Binary Format Descriptor）解析输入的目标文件，输出目标文件时也采用相同的格式
	  [-I bfdname |--input-target=bfdname]：使用指定的二进制文件格式（Binary Format Descriptor）解析输入的目标文件
	  [-O bfdname |--output-target=bfdname]：使用指定的二进制文件格式（Binary Format Descriptor）输出目标文件
	  [-s|--strip-all]：删除所有符号
      [-S|-g|-d|--strip-debug]：仅删除调试符号
      [--strip-dwo]：删除所有DWARF .dwo节的内容，保留其余调试节和所有符号不变
      [-K symbolname |--keep-symbol=symbolname]：保留源文件中指定的符号symbolname
      [-N symbolname |--strip-symbol=symbolname]：从源文件中删除符号symbolname。此选项可能不止一次
      [-w|--wildcard]：允许在其他命令行选项中对符号名称使用正则表达式。问号（？）、星号（*）、反斜杠（\）和方括号（[]）运算符可以在符号名的任何位置使用
      [-x|--discard-all]：删除非全局符号
      [-X |--discard-locals]：删除编译器生成的本地符号
      [-R sectionname |--remove-section=sectionname]：从输出文件中删除名为sectionname的任何节。此选项可能会给出多次。请注意，不适当地使用此选项可能会使输出文件不可用。通配符*可以在sectionname的末尾给出。如果是这样，则将删除以sectionname开头的任何节
      [-o file]：将剥离的输出放入文件 file 中，而不是替换现有文件。使用此参数时，只能指定一个objfile
      [-p|--preserve-dates]：保留文件的访问和修改日期
      [-D|--enable-deterministic-archives]：以确定性模式（deterministic mode）操作。复制存档成员和写入存档索引时，对UIDs、GIDs、时间戳使用零，对所有文件使用一致的文件模式
      [-U|--disable-deterministic-archives]：不以确定性模式（deterministic mode）操作。这与上面的-D选项相反：复制存档成员并写入存档索引时，使用它们的实际UID、GID、时间戳和文件模式值
      [--keep-file-symbols]：保留符号信息
      [--only-keep-debug]：保留调试信息
      [-v |--verbose] ：详细输出：列出所有修改的对象文件。对于归档文件，strip-v 列出了归档文件的所有成员
      [-V|--version]：显示版本信息
      [-h|--help]：显示帮助信息
      [--info]：列出支持的目标文件格式和架构
      objfile...：目标文件，包括库文件或可执行文件

4.常用示例

先看一个 C++ 源码文件 main.cpp。

//
//@file：main.cpp
//

#include <iostream>

int main()
{
        std::cout<<"strip"<<std::endl;
}

使用 g++ 编译生成可执行文件 main.out。

g++ -o main.out main.cpp
ll
-rw-r--r-- 1 root root     68 Mar 22 15:55 main.cpp
-rwxr-xr-x 1 root root   9119 Mar 22 15:55 main.out

（1）剥掉可执行文件中一些符号信息和调试信息，使文件变小。

首先使用file命令来查看可执行文件main.out的基本信息，可见其是not stripped。

file main.out 
main.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=9d0d7d3718cf9a4cfdc3e026de804e2428bb60fa, not stripped

然后使用 nm 命令来查看 main.out 中的符号。

nm main.out
000000000060105c B __bss_start
0000000000601170 b completed.6337
                 U __cxa_atexit@@GLIBC_2.2.5
0000000000601058 D __data_start
0000000000601058 W data_start
00000000004007b0 t deregister_tm_clones
0000000000400820 t __do_global_dtors_aux
0000000000600de8 t __do_global_dtors_aux_fini_array_entry
0000000000400978 R __dso_handle
0000000000600df8 d _DYNAMIC
000000000060105c D _edata
...

使用strip来剥掉main.out中的符号信息，并查看大小，文件基本信息和符号信息。

strip main.out

ll main.out
-rwxr-xr-x 1 root root 6272 Mar 22 16:14 main.out

file main.out
main.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=9d0d7d3718cf9a4cfdc3e026de804e2428bb60fa, stripped

nm main.out
nm: main.out: no symbols

可见main.out的大小从9119字节变为6272字节，且file命令显示文件状态为stripped，使用nm命令显示main.out已经没有符号了。
5.小结

通过上面的例子可以看出，strip 命令可用于剥掉目标文件的符号，使文件变小，这就节省了很多空间。

其实， strip 不仅仅针对可执行文件， 还能针对目标文件和静态、动态库等。在实际的开发中， 经常需要对动态库 .so 进行 strip 操作， 减少空间。 而在调试的时候（比如用 addr2line），就需要符号了。因此，通常的做法是用 strip 前的库来调试，strip 后的库用来发布， 发布的 strip 后的库一旦出了问题， 就可以找对应的未 strip 的库来定位。

●ldd 命令：
1.命令简介

ldd 命令用于打印程序或者共享库文件所依赖的共享库列表。注意，ldd 本身不是一个二进制程序，而是一个 Shell 脚本，使用文本编辑器 vim 可以查看其内容，具体目录可以使用 which 命令查看：

which ldd
/usr/bin/ldd

我们知道，Linux 的动态库装载器 ld-linux.so 模块会先于 executable 模块工作，并获得控制权，ld-linux.so 会通过系统环境变量的设置，选择只显示可执行模块的dependency，而不运行可执行模块。相关环境变量有：

LD_TRACE_LOADED_OBJECTS
LD_WARN
LD_BIND_NOW
LD_LIBRARY_VERSION
LD_VERBOSE
LD_DEBUG

ldd 默认开启的环境变量是：LD_TRACE_LOADED_OBJECTS=1。也就是说，LD_TRACE_LOADED_OBJECTS为必要环境变量，其他环境变量的设置是可选的。其他的变量的设置与ldd命令选项的对应关系如下：

-d, --data-relocs -> LD_WARN=yes
-r, --function-relocs ->LD_WARN和LD_BIND_NOW=yes
-u, --unused -> LD_DEBUG="unused"
-v, --verbose -> LD_VERBOSE=yes

比如设置LD_TRACE_LOADED_OBJECTS环境变量不为空时，任何可执行程序在运行时，都会只显示依赖的动态库，程序并不真正地执行。测试如下：

export LD_TRACE_LOADED_OBJECTS=1
ls
	linux-vdso.so.1 =>  (0x00007ffd1d3cf000)
	/$LIB/libonion.so => /lib64/libonion.so (0x00007fbbe7162000)
	libselinux.so.1 => /lib64/libselinux.so.1 (0x00007fbbe6e2e000)
	libcap.so.2 => /lib64/libcap.so.2 (0x00007fbbe6c29000)
	libacl.so.1 => /lib64/libacl.so.1 (0x00007fbbe6a20000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fbbe665e000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007fbbe645a000)
	libpthread.so.0 => /lib64/libpthread.so.0 (0x00007fbbe623e000)
	libpcre.so.1 => /lib64/libpcre.so.1 (0x00007fbbe5fdd000)
	liblzma.so.5 => /lib64/liblzma.so.5 (0x00007fbbe5db8000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fbbe7053000)
	libattr.so.1 => /lib64/libattr.so.1 (0x00007fbbe5bb3000)

撤销该环境变量，ls 即可恢复正常使用：

unset LD_TRACE_LOADED_OBJECTS
ls
Changelog  Changelog.ln  dablelv  txt.txt

由此可见，ldd 命令其实是通过设置 ld-linux.so 依赖的环境变量来影响 ld-linux.so的工作方式，使得可执行模块加载时显示其依赖的动态库。实际上可以直接执行 ld-linux.so 模块，如/lib/ld-linux.so.2 --list program，来达到命令ldd program的效果。
2.命令格式

ldd [OPTIONS] <FILES>

其中[OPTIONS]为可选的命令选项，<FILES>...为必填的程序或者共享库文件列表。
3.选项说明

--version：打印ldd版本号
-v, --verbose：详细信息模式，打印所有相关信息
-u, --unused：打印未使用的直接依赖
-d, --data-relocs：执行重定位和报告任何丢失的对象
-r, --function-relocs：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数。（只对ELF格式文件有效）
--help：显示帮助信息

4.示例说明

（1）显示可执行文件依赖的动态链接库。

ldd /usr/bin/ls
	linux-vdso.so.1 =>  (0x00007ffd90514000)
	/$LIB/libonion.so => /lib64/libonion.so (0x00007f294ade8000)
	libselinux.so.1 => /lib64/libselinux.so.1 (0x00007f294aab4000)
	libcap.so.2 => /lib64/libcap.so.2 (0x00007f294a8af000)
	libacl.so.1 => /lib64/libacl.so.1 (0x00007f294a6a6000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f294a2e4000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007f294a0e0000)
	libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f2949ec4000)
	libpcre.so.1 => /lib64/libpcre.so.1 (0x00007f2949c63000)
	liblzma.so.5 => /lib64/liblzma.so.5 (0x00007f2949a3e000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f294acd9000)
	libattr.so.1 => /lib64/libattr.so.1 (0x00007f2949839000)

●ar 命令：
1.命令简介

ar（ARchiver）命令是 GNU Binutils 的一员，可以用来创建、修改静态库，也可以从静态库中提取单个模块。静态库是一个独立的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的 member）。原始文件的内容、访问模式、时间戳、属主和组等属性都保留在库文件中。
2.命令格式

ar [--plugin <name>] [-X32_64] [-]<d|m|p|q|r|s|t|x>[abcDfilNoPsSTuUvV [relpos] [count]] [--target <bfdname>] [archive] [member...]

其中连字符[-]是可选的，选项<d|m|p|q|r|s|t|x>为操作选项，使用时只能使用其中一个，选项[abcDfilNoPsSTuUvV]为修饰选项，用来修饰操作选项，与操作选项配合使用时，二者的顺序可以任意。[relpos]表示库中的成员名，用于加入新文件时指定相对位置，与选项a、b和i结合使用。[count]表示在库中有多个同名的成员时，指定提取或删除的个数。[archive]为库名称，[member...]为库的成员名称。
3.选项说明

#操作选项说明
d：Delete，从库中删除由[member...]指定的模块，如果使用了修饰选项v则列出被删除的每个模块
m：Move，该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义（如函数定义），则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用a，b或i选项指定移动到的位置
p：Print，显示库中指定的成员到标准输出。如果指定修饰选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来
q：Quick append，快速追加。增加新模块到库的结尾处。并不检查是否需要替换。a，b或 i 修饰选项对此操作没有影响，模块总是追加到库的结尾处。如果使用了修饰选项v则列出每个模块。这时，库的符号表没有更新，可以用ar s或ranlib来更新库的符号表索引
r：Replacement，以替换模式向库中插入成员。当插入的模块名已经在库中存在，则替换同名的模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项a，b或i来改变增加的位置
s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。注意，s也可以作为修饰选项来使用
t：Table，显示库的模块表清单。如果指定文件名称，则仅显示指定的那些文件。如果不指定任何文件，则列出库中的所有文件。一般只显示模块名，如果结合选项v可显示文件的访问权限、时间戳、属主和组等信息
x：eXtract，从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块

#修饰选项说明
a：After，在库的一个已经存在的成员后面增加一个新的文件。已经存在的成员由relpos 参数指定
b：Before，在库的一个已经存在的成员前面增加一个新的文件。已经存在的成员由relpos 参数指定
c：Create，创建一个库。不管库是否存在，都将创建
D：Deterministic，以确定性模式操作。添加文件和存档索引时，对uids、gid、时间戳使用零，对所有文件使用一致的文件模式。使用此选项时，如果ar与相同的选项和相同的输入文件一起使用，则多次运行将创建相同的输出文件，而不考虑输入文件的所有者、组和文件。模式或修改时间。如果binutils配置为--enable deterministic archives，那么默认情况下，此模式为on。可以使用下面的U修饰符禁用它
f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容
i：Insert，在库中一个已经存在的成员前面增加一个新的文件已经存在的成员由relpos 参数指定（类似选项b）
l：暂未使用
N：与[count]参数一起使用，在库中有多个相同的文件名时指定提取或删除的个数
o：Original，当提取成员时，保留成员的原始数据。如果不指定该选项，则提取出的模块的时间将标为提取出的时间
P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。此选项将导致GNU AR使用完整的路径名匹配文件名，这在从另一个工具创建的存档中提取单个文件时非常方便
s：等同于操作选项s，具体见必选项s的说明
S：不创建目标文件索引，这在创建较大的库时能加快时间
T：Thin，将指定的存档设为精简存档。如果库已经存在并且是常规库，则现有成员必须与存档位于同一目录中
u：一般说来，命令ar r member...插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，可以使用该选项。该选项只与 r 操作选项一起使用
U：Undeterministic，不要在确定性模式下操作。这与上面的D选项相反：被添加的文件和存档索引将获得它们的实际uid、gid、时间戳和文件访问权限模式值。
v：该选项用来显示执行操作选项的附加信息
V,--version：显示ar的版本信息

#其它选项说明
--help：显示ar的帮助信息
--plugin：使ar加载指定的插件，这增加了对更多文件格式的支持。只有工具链构建时开启了插件支持的情况下，此选项才可用
-X32_64：此选项是GNU ar的默认选项，AR不支持任何其他-X选项，比如-x32，此选项是AIX ar的默认选项
--target：当库成员的目标文件格式与系统的默认格式不同时指定具体的格式

4.常用示例

（1）创建一个静态库。

ar crv libtest.a hello.o dablelv.o

（2）从静态库中提取指定目标文件。

ar x /usr/lib64/libc.a errno.o

（3）查看静态库中指定目标文件的详细信息。

ar tv /usr/lib64/libc.a errno.o
rw-r--r-- 1000/135   1106 Feb 14 10:14 2017 errno.o

（4）从静态库中要删除一个成员。注意，删除前请备份C标准静态库libc.a。

ar dv libc.a strlen.o

●nm 命令：
1.命令简介

nm 命令是 GNU Binutils 二进制工具集的一员，用于显示目标文件中的符号。如果没有为 nm 命令指明目标文件，则 nm 假定目标文件是 a.out。

nm 命令显示的符号类型，至少使用以下类型，其他类型取决于目标文件格式。符号类型如果是小写，符号通常是本地的；如果是大写，符号是全局的（外部的）。但是，有一些小写符号类型表示特殊的全局符号，例如 u、v 和 w。

A
该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。

b,B
该符号的值出现在非初始化数据段（BSS）中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在BSS段中的偏移。

C
该符号为common。common symbol是未初始化的数据。该符号没有包含在一个普通section中，只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个C文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C，否则其类型为B。

d,D
该符号位于初始化数据段（data section）。例如定义全局变量 int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，则会被分配在初始化数据段中。

g,G
该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式

i
这是对标准ELF符号类型集的GNU扩展。它表示一个符号如果被重定位引用，不会计算该符号的地址，而是必须在运行时计算

N
该符号是一个debugging符号。

p
该符号在stack unwind section

r,R
该符号位于只读数据段（read only data section）。例如定义全局const int test[] = {123, 123};则test就是一个只读数据段的符号。

s,S
符号位于非初始化数据区，用于small object。

t,T
该符号位于代码段（text section）。

u
符号是唯一的全局符号。这是GNU对标准ELF符号绑定集的扩展。对于这样的符号，动态链接器将确保在整个过程中只有一个使用此名称和类型的符号。

U
该符号在当前文件中是未定义的，即该符号定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，这个被调用的函数在当前文件就是未定义的，但是在定义它的文件中类型是T。对于全局变量来说，在定义它的文件中，其符号类型为B或D，在使用它的文件中，其类型为U。

v,V
该符号是一个弱符号。当弱定义符号与正常定义符号链接时，使用正常定义符号时不会出错。当链接未定义的弱定义符号，弱符号的值将变为零，且没有错误。在某些系统上，大写表示已指定默认值

w,W
该符号是一个弱符号，未专门标记为弱对象符号。当弱定义符号与正常定义符号链接时，使用正常定义符号时不会出错。当链接未定义的弱未定义符号时，该符号的值将以系统特定的方式确定，且不会出错。在某些系统上，大写表示已指定默认值

-
该符号是a.out格式文件中的stabs symbol。在这种情况下，打印的下一个值是stabs other字段、stabs desc字段和stab类型。stabs符号用于保存调试信息

?
该符号类型没有定义

2.命令格式

nm [-A|-o|--print-file-name] [-a|--debug-syms]
   [-B|--format=bsd] [-C|--demangle[=style]]
   [-D|--dynamic] [-f<format>|--format=<format>]
   [-g|--extern-only] [-h|--help]
   [-l|--line-numbers] [-n|-v|--numeric-sort]
   [-P|--portability] [-p|--no-sort]
   [-r|--reverse-sort] [-S|--print-size]
   [-s|--print-armap] [-t <radix>|--radix=<radix>]
   [-u|--undefined-only] [-V|--version]
   [-X 32_64] [--defined-only] [--no-demangle]
   [--plugin <name>] [--size-sort] [--special-syms]
   [--synthetic] [--target=bfdname]
   [objfile...]

3.选项说明

-A, -o, --print-file-name
	在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次
-a, --debug-syms
	显示调试符号
-B, --format=bsd
	用来兼容 MIPS 的 nm
-C, --demangle[=STYLE]
	将低级符号名解码（demangle）成用户级名字，比如去除编译时添加的前置下划线，这样可以使得 C++ 函数名具有可读性。不同的编译器符号修饰风格不同，可以使用 =STYLE 参数来选择合适的解码风格
-D, --dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义
-f, --format=FORMAT
	FORMAT 可取值 bsd、sysv 或 posix，该选项在 GNU nm 中有用，默认为 bsd
-g, --extern-only
	仅显示外部符号
-h, --help
	显示帮助信息
-l, --line-numbers
	对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后
-n, -v, --numeric-sort
	按符号对应地址的顺序排序，而非按符号名的字符顺序
-P, --portability
	使用 POSIX.2 标准输出格式代替默认的输出格式。等同于 -f posix
-p, --no-sort
	按目标文件中遇到的符号顺序显示，不排序
-r, --reverse-sort
	逆序排序。例如，升序变为降序
-S, --print-size
	以 BSD 输出样式输出已定义符号的值和大小。对于不记录符号大小的目标文件格式，此选项不起作用，除非使用了--size sort，在这种情况下，将显示计算的大小
-s, --print-armap
	当列出库中成员的符号时，同时列出索引。索引的内容包含：模块与其包含的名字的定义之间的映射
-t, --radix=RADIX
	使用基数 radix 进制显示符号值。radix 只能为 d（十进制）、o（八进制）或 x（十六进制）
-u, --undefined-only
	仅显示没有定义的符号
-V, --version
	显示版本信息并退出
-X
	为了与 AIX 版本的 nm 兼容，选项 -X 将被忽略。它可接受一个参数，该参数必须是字符串32_64。AIX nm 的默认模式对应于 -X 32，GNU nm 不支持模式 -X 32
--defined-only
	仅显示有定义的符号
--no-demangle
	不解码低级符号名，这是默认选项
--plugin NAME
	加载名为 name 的插件以添加对额外目标类型的支持。只有在启用插件支持的情况下构建了工具链时，此选项才可用
--size-sort
	按符号大小排列
--special-syms
	显示目标相关的具体特殊含义的符号。这些符号通常被特定目标文件用于某些特殊处理，当包含在正常符号列表中时通常不起作用。例如，对于ARM目标，此选项将跳过用于标记ARM代码、Thumb代码和数据之间转换的映射符号
--synthetic
	输出合成符号。合成符号是链接器为各种目的创建的特殊符号，默认情况下不会显示它们，因为它们不是二进制文件源代码的一部分
--target=BFDNAME
	指定系统默认格式以外的目标文件格式

4.常用示例

首先给出后面大部分示例所基于的源代码以及编译指令。 涉及两个 C++ 源文件。
test.cpp：

#include <iostream>

int dUnInitialized;
int dInitialized = 1;
char sTest[] = "good";

void print() {
        std::cout<<"dUnInitialized="<<dUnInitialized<<" dInitialized="<<dInitialized<<" sTest="<<sTest<<std::endl;
}

main.cpp：

#include <iostream>
using namespace std;

void print();
extern int dUnInitialized;
int main() {
	int localVar=666;
	dUnInitialized=2;
	print();
}

使用-g选项加入调试信息，分别编译生成目标文件objdump.o与main.o。

g++ -c -g test.cpp -o test.o
g++ -c -g main.cpp -o main.o

然后通过ar命令将两个目标文件打包成静态库libobjdump.a。

ar crv libnm.a main.o test.o

（1）列出目标文件 test.o 与 main.o 的符号清单。

nm -C *.o
main.o:
                 U __cxa_atexit
                 U __dso_handle
                 U dUnInitialized
0000000000000057 t _GLOBAL__sub_I_main
0000000000000000 T main
000000000000001a t __static_initialization_and_destruction_0(int, int)
                 U print()
                 U std::ios_base::Init::Init()
                 U std::ios_base::Init::~Init()
0000000000000000 b std::__ioinit

test.o:
                 U __cxa_atexit
0000000000000000 D dInitialized
                 U __dso_handle
0000000000000000 B dUnInitialized
00000000000000ae t _GLOBAL__sub_I_dUnInitialized
0000000000000004 D sTest
0000000000000071 t __static_initialization_and_destruction_0(int, int)
0000000000000000 T print()
                 U std::ostream::operator<<(int)
                 U std::ostream::operator<<(std::ostream& (*)(std::ostream&))
                 U std::ios_base::Init::Init()
                 U std::ios_base::Init::~Init()
                 U std::cout
                 U std::basic_ostream<char, std::char_traits<char> >& std::endl<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&)
0000000000000004 b std::__ioinit
                 U std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)

使用 -C 选项将符号解码成可读形式，从 test.o 的输出结果可以看出，已初始化的全局变量 dInitialized 与 sTest，符号类型是 D，所以其位于初始化的 Data 段。未初始化的全局变量 dUnInitialized 符号类型是 B，所以其位于未初始化的 BSS 段。函数print() 的符号类型是 T，说明其位于代码段（Text Section）。

从 main.o 的输出结果可以看出，变量 dUnInitialized 与函数 print() 因为均定义在其它文件中，所以符号类型是 U，表示该符号在当前文件中是未定义的。值得注意的是，变量 localVar 因为是局部变量， nm 无法获取其符号。

●strings 命令：
1.命令简介

strings 在二进制目标文件或其他二进制文件中查找可打印的字符串。

字符串默认至少是 4 个或更多可打印字符的任意序列，可使用选项改变字符串最小长度。

注意，不同 Linux 发行版提供的 strings 实现可能有所不同，本文以 GNU Binutils 二进制工具集中的 strings 为例讲解。使用时，请参阅相应 Linux 关于 strings 的帮助手册。
2.命令格式

strings [<options>] <file>...

3.选项说明

注意，长选项的参数对于短选项也是必须的。

-a, --all, -
	扫描整个文件而不是只扫描目标文件初始化和装载段
-d, --data
	仅打印文件中已初始化、加载的数据段中的字符串，这可能会减少输出中的垃圾量
-e, --encoding=ENCODING
	选择字符编码与字节序。encoding可取值s=7bits的ASCII, S=8bits的Latin1, {b,l}=16bits宽字符大小端编码, {B,L}=32bits宽字符大小端编码。其中b，B代表bigendian，l，L代表littleendian
-f,–-print-file-name
	在显示字符串前先显示文件名
--help
	显示帮助信息
-, -n, --bytes=MIN_LEN
	指定可打印字符序列的最小长度，而不是默认的4个字符
-o
	类似 --radix=o
-t, --radix=RADIX
	输出字符串在文件中的偏移位置，RADIX 可取值 o（octal，八进制）、d（decimal，十进制）或者 x（hexadecimal，十六进制）
-T, --target=BFD_NAME
	指定二进制文件格式
-v, -V, --version
	显示版本信息
-w, --include-all-whitespace
	默认情况下，Tab 和空格字符包含在字符串中，但其他空白字符除外，比如换行符和回车符等字符不是。-w 使所有的空白字符被认为是字符串的一部分
@FILE
	从指定的文件 FILE 中读取命令行选项

4.常用示例

（1）打印可执行文件中的所有可读字符串。

strings /bin/ls
/lib64/ld-linux-x86-64.so.2
libselinux.so.1
_ITM_deregisterTMCloneTable
__gmon_start__
_Jv_RegisterClasses
_ITM_registerTMCloneTable
_init
fgetfilecon
freecon
lgetfilecon
...

（2）查看某一个字符串属于哪个文件。

strings -f * | grep "xxx"

（3）查看glibc支持的版本。libc.so.6是c标准库，而这个标准库的制作者为了让库的使用者知道该库兼容哪些版本的标准库，就在这个库中定义了一些字符串常量，使用如下命令可以查看向下兼容的版本。

strings /lib64/libc.so.6 | grep GLIBC
GLIBC_2.2.5
GLIBC_2.2.6
GLIBC_2.3
GLIBC_2.3.2
GLIBC_2.3.3
GLIBC_2.3.4
GLIBC_2.4
GLIBC_2.5
GLIBC_2.6
GLIBC_2.7
GLIBC_2.8
GLIBC_2.9
GLIBC_2.10
GLIBC_2.11
GLIBC_2.12
GLIBC_2.13
GLIBC_2.14
GLIBC_2.15
GLIBC_2.16
GLIBC_2.17
GLIBC_PRIVATE

●ld 命令：
1.命令简介

ld（Link eDitor）命令是二进制工具集 GNU Binutils 的一员，是 GNU 链接器，用于将目标文件与库链接为可执行文件或库文件。
2.命令格式

ld [OPTIONS] OBJFILES

3.选项说明

ld 命令支持众多链接选项，但是大部分选项很少被使用，下面是 GNU ld 命令接受的选项。

-b <input-format>
	指定目标代码输入文件的格式
-Bstatic
	只使用静态库
-Bdynamic
	只使用动态库
-Bsymbolic
	把引用捆绑到共享库中的全局符号
-c <MRI-commandfile>, --mri-script=<MRI-commandfile>
	为与 MRI 链接器兼容，ld 接受由 MRI 命令语言编写的脚本文件
--cref
	创建跨引用表
-d,-dc,-dp
	即使指定了可重定位的输出文件（使用-r），也会为公共符号分配空间。脚本命令“FORCE_COMMON_ALLOCATION”具有相同的效果
-defsym
	在输出文件中创建指定的全局符号
-demangle
	在错误消息中还原符号名称
-e <entry>
	使用指定的符号作为程序的初始执行点
-E,--export-dynamic
	对于ELF格式文件，创建动态链接的可执行文件时，把所有符号添加到动态符号表
-f <name>, --auxiliary=<name>
	对于 ELF 格式共享对象，设置 DT_AUXILIARY 名称
-F <name>, --filter=<name>
	对于ELF格式共享对象，设置 DT_FILTER 名称。这告诉动态链接器，正在创建的共享对象的符号表应该用作共享对象名称的符号表的筛选器。
-g
	被忽略。用于提供和其他工具的兼容性
-h
	对于 ELF 格式共享对象，设置 DT_SONAME 名称
-I<file>, -dynamic-linker <file>, --dynamic-linker=<file>
	指定动态链接器。这仅在生成依赖动态链接库的 ELF 可执行文件时才有意义。默认的动态链接器通常是正确的，除非您知道正在做什么，否则不要使用该选项。
-l <namespec>, --library=<namespec>
	把指定的库文件添加到要链接的文件清单
-L <searchdir>, --library-path=searchdir
	把指定的路径添加添加到搜索库的目录清单
-M, --print-map
	显示链接映射，用于诊断目的
-Map=<mapfile>:
	将链接映射输出到指定的文件
-m <emulation>
	模拟指定的链接器
-N,--omagic
	指定读取/写入文本和数据段
-n,--nmagic
	关闭节的页面对齐，并禁用对共享库的链接。如果输出格式支持Unix样式的幻数，则将输出标记为"NMAGIC"
-noinhibit-exec
	生成输出文件，即使出现非致命链接错误。通常，如果链接器在链接过程中遇到错误，它将不会生成输出文件。
-no-keep-memory
	ld 通常在内存中缓存输入文件的符号表来优化内存使用速度。此选项告诉 ld 不要缓存符号表。当链接大型可执行文件时，如果ld耗尽内存空间，则可能需要使用该选项
-O <level>
	对于非零的优化等级，ld将优化输出。此操作会比较耗时，应该在生成最终的结果时使用。
-o <output>, --output=<output>
	指定输出文件的名称
-oformat=<output-format>
	指定输出文件的二进制格式
-R <filename>,--just-symbols=<filename>
	从指定的文件读取符号名称和地址
-r,--relocatable
	生成可重定位的输出（称为部分连接）
-rpath=<dir>
	把指定的目录添加到运行时库搜索路径
-rpath-link=<dir>
	指定搜索运行时共享库的目录
-S,--strip-debug
	忽略来自输出文件的调试器符号信息
-s,--strip-all
	忽略来自输出文件的所有符号信息
-shared, -Bshareable
	创建共享库
-split-by-file[=size]
	为每个目标文件在输出文件中创建额外的段大小达到size。size默认为1
-split-by-reloc[=count]
	按照指定的长度在输出文件中创建额外的段
--section-start=<sectionname>=<org>
	在输出文件中指定的地址定位指定的段
-T <scriptfile>, --script=<scriptfile>
	使用 scriptfile 作为链接器脚本。此脚本将替换 ld 的默认链接器脚本（而不是添加到其中），因此脚本必须指定输出文件所需的所有内容。如果当前目录中不存在脚本文件，ld 会在 -L 选项指定的目录中查找
-Ttext=<org>
	使用指定的地址作为文本段的起始点
-Tdata=<org>
	使用指定的地址作为数据段的起始点
-Tbss=<org>
	使用指定的地址作为bss段的起始点
-t,--trace
	在处理输入文件时显示它们的名称
-u <symbol>, --undefined=<symbol>
	强制指定符号在输出文件中作为未定义符号
-v, -V, --version
	示ld版本号
-warn-common
	当一个通用符号和另一个通用符号结合时发出警告
-warn-constructors
	如果没有使用任何全局构造器，则发出警告
-warn-once
	对于每个未定义的符号只发出一次警告
-warn-section-align
	如果为了对齐而改动了输出段地址，则发出警告
--whole-archive
	对于指定的存档文件，在存档中包含所有文件
-X, --discard-locals
	删除所有本地临时符号
-x, --discard-al
	删除所有本地符号

4.常用示例

（1）链接目标文件生成可执行文件。如给定 C++ 目标文件 test.o 与 main.o，生成可执行文件 test.out。

ld /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib64/crtn.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5 -L/usr/lib64 -L/usr/lib -lstdc++ -lm -lgcc_s -lc -lgcc  main.o test.o -o test.out

因为生成一个C++可执行文件，需要依赖很多系统库和相关的目标文件，比如C语言库libc.a，所以使用ld进行链接时，需要注意添加较长的命令选项，不然会报链接错误。使用g++ -v命令可以查看最后一行collect2使用的命令选项，进而了解生成可执行文所需的相关依赖。

g++ -v main.o test.o
...
usr/libexec/gcc/x86_64-redhat-linux/4.8.5/collect2 --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib64/crtn.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5 -L/usr/lib64 -L/usr/lib -lstdc++ -lm -lgcc_s -lc -lgcc  main.o test.o

●as 命令：
1.命令简介

as 命令是二进制工具集 GNU Binutils 的一员，是 GNU 推出的一款汇编语言编译器集，用于将汇编代码编译为二进制代码，它支持多种不同类型的处理器。
2.命令格式

as [OPTIONS] --|FILES

3.选项说明

@FILE
	从文件 FILE 中读取命令行选项，读取的选项将插入到原始 @FILE 选项的位置
-a[cdghlmns]
	开关列表。以下选项可以进行组合；如果使用=FILE选项，必须是最后一个。默认地，-a 等于 -ahls。
	-ac：忽略失败条件； 
	-ad：忽略调试指令； 
	-ah：包括高级源； 
	-al：包括装配； 
	-am：包括宏扩展； 
	-an：忽略形式处理； 
	-as：包括符号； 
	=FILE：指定列出文件的名字； 
--alternate
	以交替宏模式开始
--debug-prefix-map OLD=NEW
	在旧目录中汇编文件时，记录调试信息，将其描述为新目录
--defsym SYM=VALUE
	对输入文件进行汇编时，将指定符号设置为指定值。VALUE 必须是整型常量
-f
	表示 fast，跳过空白和注释预处理
-g, --gen-debug
	产生调试信息
--help
	显示帮助信息
-I DIR
	将目录 DIR 加入到指令 .include 的搜索列表
-J
	符号溢出不警告
-K
	当长位移改变了不同的表时发出警告
-L, --keep-locals
	在符号表中保留本地符号
-o OBJFILE
	指定要生成的目标文件
-R
	将数据段折叠到代码段
--statistics
	打印汇编所用的最大空间和总时间
--strip-local-absolute
	从传出符号表中删除本地绝对符号
-v, -version
	打印版本信息不退出
--version
	打印版本信息并退出
-W, --no-warn
	不显示告警信息
--fatal-warnings
	将告警视为错误
--warn
	显示告警或将告警视为错误
-Z
	产生目标文件即使发生错误
-- | FILES
	从标准输入读取或由文件指定汇编代码

4.常用示例

（1）假设有汇编文件 test.s，将其会变成二进制 .o 文件。

as test.s -o test.o

●time 命令：
1.命令简介

time 用于统计命令执行所消耗的时间及相关系统资源等信息，默认情况下在命令执行结束后将统计结果输出到标准错误输出。time 可以显示的资源有四大项：

Time resources
Memory resources
IO resources
Command info

注意，由于某些 Shell（比如 bash）自带了内建命令 time，并且提供的功能不全，要想使用本文描述的 time，请指明路径，比如 /usr/bin/time。
2.命令格式

time [OPTIONS] COMMAND [ARGUMENTS]

3. 选项说明

长选项的参数对于短选项也是必须的。

-f, --format=FORMAT
	使用指定格式输出。如果没有指定输出格式，采用环境变量 TIME 指定的格式
-p, --portability
	使用兼容 POSIX 的格式输出，real %e\nuser %U\nsys %S
-o, --output=FILE
	结果输出到指定文件。如果文件已经存在，覆写其内容
-a, --append
	与 -o 选项一起使用，使用追加模式将输出写入指定文件
-v, --verbose
	使用冗余模式尽可能地输出统计信息
--help
	显示帮助信息
-V, --version
	显示版本信息
--
	终止选项列表

其中输出格式以类似 printf 的方式解释，普通字符将直接输出，制表符、换行符、反斜杠和百分号分别使用\t、\n、\\、%%表示。%后跟其它字母表示特殊格式，可用格式如下：

Time
%E：执行指令所花费的时间，格式[hours:]minutes:seconds
%e：执行指令所花费的时间，单位是秒
%S：指令执行时在内核模式（kernel mode）所花费的时间，单位是秒
%U：指令执行时在用户模式（user mode）所花费的时间，单位是秒
%P：执行指令时 CPU 的占用比例。其实这个数字就是内核模式加上用户模式的 CPU 时间除以总时间（(%S+%U)/%E）

Memory
%M：执行时所占用的内存的最大值。单位KB
%t：执行时所占用的内存的平均值，单位是 KB
%K：执行程序所占用的内存总量（stack+data+text）的平均大小，单位是 KB
%D：执行程序的自有数据区（unshared data area）的平均大小，单位是 KB
%p：执行程序的自有栈（unshared stack）的平均大小，单位是 KB
%X：执行程序是共享代码段（shared text）的平均值，单位是 KB
%Z：系统内存页的大小，单位是 byte。对同一个系统来说这是个常数
%F：内存页错误次数。内存页错误指需要从磁盘读取数据到内存
%R：次要或可恢复的页面错误数。这些是无效页面的错误，但其他虚拟页面尚未使用该内存页。因此，页面中的数据仍然有效，但必须更新系统表
%W：进程从内存中交换的次数
%c：进程上下文被切换的次数（因为时间片已过期）
%w：进程等待次数，指程序主动进行上下文切换的次数，例如等待I/O操作完成

I/O
%I：此程序所输入的档案数
%O：此程序所输出的档案数
%r：此程序所收到的 Socket Message
%s：此程序所送出的 Socket Message
%k：此程序所收到的信号 （Signal）数量

Command Info
%C：执行时的参数指令名称
%x：指令的结束代码 ( Exit Status )

4.常用示例

（1）统计命令执行时间。

time date 
Fri May 31 11:30:04 CST 2019

real	0m0.001s
user	0m0.000s
sys 	0m0.000s

（2）输出命令名称、参数与退出码。

/usr/bin/time --format="%C\n%x" date +%s
1580507732
date +%s
0

●realpath 命令：
1.命令简介

realpath 用于获取指定目录或文件的绝对路径。

编写 Shell 脚本中，通常会使用相对路径来指明文件，但有时候，我们需要用到绝对路径，此时可以使用 realpath 来获取。
2.命令格式

realpath [OPTIONS] FILES

3.选项说明

-e, --canonicalize-existing
	文件 FILE 的所有组成部件必须都存在
-m, --canonicalize-missing
	文件 FILE 的组成部件可以不存在
-L, --logical
	在软链接之前解析父目录 ..
-P, --physical
	解析软链接，默认动作
-q, --quiet
	静默模式输出，禁止显示大多数错误消息
--relative-to=DIR
	相对于目录 DIR 的路径
--relative-base=DIR
	如果文件在基目录 DIR下，打印结果会省去基目录，否则打印绝对路径
-s, --strip, --no-symlinks
	不扩展软链接
-z, --zero
	不分隔输出，即所有的输出均在一行而不是单独每行
--help
	显示帮助信息
--version
	显示版本信息

4.常用示例

（1）打印指定文件的绝对路径。执行命令时当前工作目录为 /data/test/src。

realpath ./hello.tgz
/data/test/src/hello.tgz

（2）显示软链接指向的目标文件的绝对路径。执行命令时当前工作目录为 /data/test。

ll
total 4
-rw-r--r-- 1 root root    0 Feb  1 07:26 foo
lrwxrwxrwx 1 root root   13 Feb  1 07:05 hello.sln -> src/hello.tgz
drwxr-xr-x 2 root root 4096 Feb  1 07:19 src

realpath ./hello.sln
/data/test/src/hello.tgz

可见，即便使用相对路径创建的软链接，realpath 也能顺利解析。

（3）打印某个文件相对于另外一个目录的路径。执行命令时当前工作目录为 /data/test。

realpath --relative-to=./src ./foo
../foo

（4）打印某个文件相对于基目录的路径，如果文件在基目录下，则会省去基目录。执行命令时当前工作目录为 /data/test。

realpath --relative-base=/data/test ./foo
foo

●objcopy 命令：
1.命令简介

将目标文件的一部分或者全部内容拷贝到另外一个目标文件中，或者实现目标文件的格式转换，是 GNU Binutils 的一员。

objcopy 工具使用 BFD 库读写目标文件，它可以将一个目标文件的内容拷贝到另外一个目标文件。objcopy 通过它的选项来控制其不同的动作，它可以将目标文件拷贝成和原来的文件不一样的格式。需要注意的是 objcopy 能够在两种格式之间拷贝一个完全链接的文件，在两种格式之间拷贝一个可重定位的目标文件可能不会正常地工作。

objcopy 在做转换的时候会创建临时文件，然后将这些临时文件删除。objcopy 使用 BFD 来做它所有的转换工作；它访问 BFD 中描述的所有格式，可以不必指定就识别大多数的格式。
通过指定输出目标为 srec（例如 -O srec），objcopy 可以用来生成 S-record 文件。

通过指定输入目标为二进制文件（例如-O binary），objcopy 可以生成原始格式的二进制文件。当 objcopy 生成一个原始格式的二进制文件的时候，它会生成输入的目标文件的基本内存拷贝，然后所有的符号和可重定位信息都会被去掉。内存拷贝开始于最低段的加载地址，拷贝到输出文件。

当生成一个 S-record 或者原始的二进制文件的时候，可以使用-S选项来移除一些调试信息。有时-R可以用来移除一些二进制文件不需要的段。

注意：objcopy 不能用来改变文件的大小端属性。
2.命令格式

objcopy [OPTION] [INFILE] [OUTFILE]

3.选项说明

-I bfdname, --input-target=bfdname
	指定输入文件的格式 bfdname，可取值 elf32-little，elf32-big 等，而不是让 objcopy 去推测
-O bfdname, --output-target=bfdname
    指定输出文件的的格式 bfdname
-F bfdname, --target=bfdname
    指定输入、输出文件的 bfdname，目标文件格式，只用于在目标和源文件之间传输数据，不转换
-B bfdarch, --binary-architecture=bfdarch
	将无架构的输入文件转换为目标文件时很有用，输出体系结构可以设置为 bfdarch。如果输入文件具有已知的架构，将忽略此选项。可以在程序内通过引用转换过程创建的特殊符号来访问二进制数据。这些符号称为 _binary_objfile_start、_binary_objfile_end 和 _binary_objfile_size。例如，您可以将图片文件转换为对象文件，然后使用这些符号在代码中访问它
-j sectionname, --only-section=sectionname 
    只将由 sectionname 指定的 section 拷贝到输出文件，可以多次指定，并且注意如果使用不当会导致输出文件不可用
-R sectionname, --remove-section=sectionname 
	从输出文件中去除掉指定的 section，可以多次指定，并且注意如果使用不当会导致输出文件不可用
-S, --strip-all 
    不从源文件拷贝符号信息和relocation信息。 
-g, --strip-debug 
    不从源文件拷贝调试符号信息和相关的段。对使用 -g 编译生成的可执行文件执行该选项后，生成的结果文件几乎和不用 -g 编译生成的可执行文件一样
--strip-unneeded 
	去掉所有重定位处理不需要的符号
-K symbolname, --keep-symbol=symbolname
    strip 的时候，保留由 symbolname 指定的符号信息。该选项可以多次指定
-N symbolname, --strip-symbol=symbolname 
    不拷贝由 symbolname 指定的符号信息。该选项可以多次指定 
--strip-unneeded-symbol=symbolname
	不拷贝重定位不需要的符号。该选项可以多次指定
-G symbolname, --keep-global-symbol=symbolname
	只保留 symbolname 为全局的，让其他符号均为局部符号，外部不可见。该选项可以多次指定
--localize-hidden
	在 ELF 目标文件中，将所有具有隐藏或内部可见性的符号标记为“局部”。此选项适用于特定的符号本地化的选项，如 -L
-L symbolname, --localize-symbol=symbolname 
	将变量 symbolname 变成文件局部的变量。该选项可以多次指定
-W symbolname, --weaken-symbol=symbolname 
    将指定符号变为弱符号。该选项可以多次指定
--globalize-symbol=symbolname 
    让变量symbolname变成全局范围，这样它可以在定义它的文件外部可见。可以多次指定。 
-w, --wildcard
    允许对其他选项中的 symbolname 使用正则表达式。问号(?)，星号(*)，反斜线(\)，和中括号([])可以出现在 symbolname 的任何位置。如果 symbolname 
	的第一个字符是感叹号(!)，那么表示相反的含义，例如
    -w -W !foo -W fo*
    表示将要弱化所有以 "fo" 开头的符号，但是除了符号 "foo"
-x, --discard-all
	不从源文件中拷贝非全局符号
-X, --discard-locals
	不拷贝编译器生成的局部变量(一般以 L 或者 .. 开头)
-b byte, --byte=byte
	只保留输入文件的每个第 byte 个字节(不会影响头部数据)。byte 的范围可以是 0 到 interleave-1。这里，interleave 通过 -i 选项指定，默认为 4。将文件创建成程序 rom 的时候，这个命令很有用。它经常用于 srec 输出目标
-i interleave, --interleave=interleave 
	每隔 interleave 字节拷贝 1 byte，interleave 默认为 4。通过 -b 选项指定选择哪个字节如果不指定 -b 那么 objcopy 会忽略这个选项
--interleave-width=width
	与 --interleave 配合使用，-b 指定起始下标，--interleave-width 则指定每次拷贝的字节数为 width，width 默认为 1。注意 -b 指定的下标与 --interleave-width 指定的字节数相加不能超过 -i 设定的宽度
-p, --preserve-dates
	将输出文件的访问和修改日期设置为与输入文件的访问和修改日期相同
-D, --enable-deterministic-archives
	以确定性模式操作。复制存档成员和写入存档索引时，对 uid、gid、时间戳使用零，对所有文件使用一致的文件模式。如果 binutils 配置了 --enable-deterministic-archives，那么这个模式是打开的，可以使用 -U 来禁止
-U, --disable-deterministic-archives
	与 -D 作用相反。复制存档成员和写入存档索引时，复制存档成员和写入存档索引时，使用他们实际的 uid、gid、时间戳和文件模式。这个选项是默认的，除非 binutils 配置了 --enable-deterministic-archives
--debugging
	如果可能，转换调试信息。这不是默认设置，因为只支持某些调试格式，而且转换过程可能很耗时
--gap-fill val
    在 section 之间的空隙中填充 val
--pad-to address
	将输出文件填充到加载地址 address。这是通过增加最后一段的大小来完成的。用 --gap-fill 指定的值（默认为零）填充额外的空间
--set-start val 
    设定新文件的起始地址为 val，并不是所有格式的目标文件都支持设置起始地址
--change-start INCR, --adjust-start INCR
    通过增加指定的值 INCR来调整起始地址，并不是所有格式的目标文件都支持设置起始地址
--change-addresses INCR, --adjust-vma INCR
	通过增加 INCR 调整所有 sections 的 VMA（virtual memory address）和 LMA（load memory address）以及起始地址。有些目标文件格式不支持对段地址的任意改动。注意，这不会重新定位分区
--change-section-address sectionpattern{=,+,-}val, --adjust-section-vma sectionpattern{=,+,-}val 
	调整指定 section 的 VMA/LMA 地址。如果 sectionpattern 未匹配到 section，则会引发告警，除非使用 --no-change-warnings 抑制告警
--change-section-lma sectionpattern{=,+,-}val
	调整指定 section 的 LMA 地址
--change-section-vma sectionpattern{=,+,-}val
	调整指定 section 的 VMA 地址
--change-warnings, --adjust-warnings
	使用 --change-section-address、--adjust-section-lma、--adjust-section-vma，如果 section pattern 没有匹配到 section，引发告警。该选项为默认选项
--no-change-warnings, --no-adjust-warnings
	使用 --change-section-address、--adjust-section-lma、--adjust-section-vma，如果 section pattern 没有匹配到 section，不引发告警
--set-section-flags sectionpattern=flag 
    为指定的 section 设置 flag，flag 是一个逗号分隔的由 flag name 组成的字符串，取值可以为 alloc, contents, load, noload, readonly, code, data, rom, share, debug。我们可以为一个没有内容的 section 设置 contents flag，但是清除一个有内容的 section 的 contents flag 是没有意义的--应当把相应的 section 移除。并不是所有的 flags 对所有格式的目标文件都有意义
--add-section sectionname=filename
    在拷贝文件的时候，添加一个名为 sectionname 的 section，该 section 的内容为 filename 的内容，大小为文件大小。这个选项只在那些可以支持任意名称 section 的文件格式上生效
--rename-section oldname=newname[,flags]
	将一个 section 的名字从 oldname 更改为 newname，同时也可以更改其 flags。这个在执行 linker 脚本进行重命名的时候，并且输出文件还是一个目标文件且不会是可执行文件的时候很有优势。 
    这个项在输入文件格式是 binary 的时候很有用，因为这经常会创建一个名称为 .data 的 section，例如，你想创建一个名称为 .rodata 的包含二进制数据的 section，这时候，你可以使用如下命令： 
    objcopy -I binary -O <output_format> -B <architecture> --rename-section .data=.rodata,alloc,load,readonly,data,contents <input_binary_file> <output_object_file>
--long-section-names {enable,disable,keep}
	在处理 COFF 和 PE-COFF 格式目标文件时，控制对长段名称的处理。默认行为是 keep，保留长段名称（如果有）。enable 和 disable 分别强制启用或禁用在输出目标文件中使用长段名称
--change-leading-char
	有些格式的目标文件在符号前使用特殊的前导字符，最常用的是下划线。此选项告诉 objcopy 在目标文件格式之间转换时更改每个符号的前导字符。如果不同的目标文件使用相同的前导字符，则此选项无效。否则，它将根据需要添加字符、删除字符或更改字符
--remove-leading-char
	移除目标文件全局符号前的前导字符
--reverse-bytes=num
	反转段中的字节。注意，段的大小必须可以被指定的数值 num 均分。该选项一般用于产生 ROM 映像用于在有问题的目标系统上进行调试。假如一个段的内容只有 8 个字节，为 12345678。
	使用 --reverse-bytes=2 ，输出文件中的结果是 21436587
	使用 --reverse-bytes=4，输出文件中的结果是 43218765
	使用 --reverse-bytes=2，接着再对输出文件使用 --reverse-bytes=4，再第二个输出文件中的结果将是 34127856
--srec-len=ival
	只对输出目标文件格式 SREC 有意义。指定生成 SREC 文件的最大长度为 ival
--srec-forceS3
	只对输出目标文件格式是 SREC 有意义。避免产生 S1/S2 记录，只产生 S3 格式的记录
--redefine-sym old=new
	变更符号名称。当链接两个目标文件产生符号名称冲突时，可以使用该选项来解决
--redefine-syms=filename
	将 --redefine-sym 选项应用于指定的文件 filename。该选项可以多次出现
--weaken
	将所有全局符号变更为弱符号。改选只对在支持弱符号的目标文件格式有效
--keep-symbols=filename
	将 --keep-symbol 选项应用于指定的文件 filename。该选项可以多次出现
--strip-symbols=filename
	将 --strip-symbol 选项应用于指定的文件 filename。该选项可以多次出现
--strip-unneeded-symbols=filename
	将 --strip-unneeded-symbol 选项应用于指定的文件 filename。该选项可以多次出现
--keep-global-symbols=filename
	将 --keep-global-symbol 选项应用于指定的文件 filename。该选项可以多次出现
--localize-symbols=filename
	将 --localize-symbol 选项应用于指定的文件 filename。该选项可以多次出现
--globalize-symbols=filename
	将 --globalize-symbol 选项应用于指定的文件 filename。该选项可以多次出现
--weaken-symbols=filename
	将 --weaken-symbol 选项应用于指定的文件 filename。该选项可以多次出现
--alt-machine-code=index
	果输出体系结构具有备用机器代码，请使用 indexth 代码而不是默认代码
--add-gnu-debuglink=path-to-file 
    为输出文件创建一个.gnu_debuglink 段，该段包含对一个调试信息文件 path-to-file 的引用
--writable-text
	将输出文本标记为可写。此选项对所有目标文件格式都没有意义
--readonly-text
	将输出文本标记为只读。此选项对所有目标文件格式都没有意义
--pure
	将输出文件标记为按需分页。此选项对所有目标文件格式都没有意义
--impure
	将输出文件标记为不纯。此选项对所有对象文件格式都没有意义
--prefix-symbols=string
	在输出文件中使用指定的字符串作为符号的前缀
--prefix-sections=string
	在输出文件中使用指定的字符串作为所有段名的前缀
--prefix-alloc-sections=string
	在输出文件中使用指定的字符串作为所有分配的段名的前缀
--add-gnu-debuglink=path-to-file
	创建一个 .gnu-debuglink 段，该段包含一个特定路径的文件引用，并且把它添加到输出文件中
--only-keep-debug 
    对文件进行 strip，移走所有不会被 --strip-debug 移走的 section，并且保持调试相关的 section 原封不动
--strip-dwo
	删除所有 DWARF .dwo 段的内容，保留其余调试段和所有符号的完整性
--extract-dwo
	提取所有 DWARF .dwo 段的内容
--file-alignment num
	指定文件对齐方式。文件中的段始终相对于文件起始部分的偏移量是数值 num 的整数倍，默认值为512。此选项特定于 PE 文件
--heap reserve, --heap reserve,commit
	指定要保留的内存字节数，以用作此程序的堆。此选项特定于 PE 文件
--image-base value
	使用指定的值 value 作为程序或 dll 的基地址。这是加载程序或 dll 时使用的最低内存位置。为了减少重新定位进而提高 dll 性能，每个 dll 都应该有一个唯一的基地址，且不应与其他 dll 重叠。对于可执行文件，默认值为 0x400000，对于 dll，默认值为 0x10000000。此选项特定于 PE 文件
--section-alignment num
	设置段的对齐方式。段在内存中的起始地址是指定数值 num 的整数倍。num 默认为 0x1000。此选项特定于 PE 文件
--stack reserve, --stack reserve,commit
	指定要保留的内存字节数，以用作此程序的栈。此选项特定于 PE 文件
--subsystem which, --subsystem which:major, --subsystem which:major.minor
	指定程序执行的子系统。which 的合法值为 "native"、"windows"、"console"、"posix"、"efi-app"、"efi-bsd"、"efi-rtd"、"sal-rtd" 和 "xbox"。您也可以选择性地设置子系统版本。此选项特定于 PE 文件
--extract-symbol
	保留文件的段标志和符号，但删除段的数据
--compress-debug-sections
	使用 zlib 压缩 DWARF 调试部分
-V, --version
	显示版本
-v,--verbose
	冗余输出
--help
	显示帮助
--info
	显示所有可用架构和目标文件格式
@file
	从文件中读取命令行选项

4.常用示例

为了后面的示例，先看一下源码。

//
//@file: main.cpp
//

#include <iostream>
using namespace std;

void my_print() {
    cout<<"print"<<endl;
}    

int main(int argc, char *argv[]) {
    my_print();
    cout<<"hello"<<endl;
    return 0;
}

通过 g++ 分别生成带调试信息与不带调试信息的可执行文件 main.debug 和 main。

g++ -g -o main.debug main.cpp
g++ -o main main.cpp

（1）分离可执行文件中的调试信息后并将两者关联。

#1.生成调试信息文件，将其中的调试信息提取出来之后保存成一个文件
objcopy --only-keep-debug main.debug main.debuginfo

#2.将调试信息从可执行文件中剥离
objcopy --strip-debug main.debug main.stripdebug

#3.为不含调试信息的可执行文件添加调试信息
objcopy --add-gnu-debuglink=main.debuginfo main.stripdebug

（2）添加一个自定义的段到可执行文件，段的内容由一个文件指定。

objcopy --add-section mysection=text.txt main main.add

使用命令 readelf -S main.add 可以看到可执行文件 main.add 中多出来了一个段 mysection。

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Alig
  ...
  [27] mysection         PROGBITS         0000000000000000  00001088
       0000000000000006  0000000000000000           0     0     1
  ...

（3）将指定的段拷贝出来。这里拷贝出我们新增的段 mysetion。

objcopy --only-section=mysection main.add section_hello

（4）去掉指定名称的段。去掉我们新增的段 mysection。

objcopy -R mysection main.add main.remove

使用命令 readelf -S main.remove 可以看到可执行文件 main.remove 中的段 mysection 已经不见了。

●size 命令:
1.命令简介

size 用于查看目标文件、库或可执行文件中各段及其总和的大小，是 GNU 二进制工具集 GNU Binutils 的一员。
2.命令格式

size [-A|-B|--format=compatibility]
    [--help]
    [-d|-o|-x|--radix=number]
    [--common]
    [-t|--totals]
    [--target=bfdname] [-V|--version]
    [OBJFILE...]

其中 OBJFILE… 为待检测的文件列表，若未给定，则默认为 a.out。
3.选项说明

-A
-B
--format=compatibility
	控制输出格式。-A 或 --format=sysv 表示使用 System V size 风格，-B 或 --format=berkeley 表示使用 Berkeley size 风格。默认使用 Berkeley size 风格的输出。
	
	下面是 Berkeley 风格示例：
	$ size --format=Berkeley ranlib size
	text    data    bss     dec     hex     filename
	294880  81920   11592   388392  5ed28   ranlib
	294880  81920   11888   388688  5ee50   size

	下面是接近 System V 风格示例：
	$ size --format=SysV ranlib size
	ranlib  :
	section         size         addr
	.text         294880         8192
	.data          81920       303104
	.bss           11592       385024
	Total         388392

	size  :
	section         size         addr
	.text         294880         8192
	.data          81920       303104
	.bss           11888       385024
	Total         388688

--help
	显示帮助信息

-d
-o
-x
--radix=number
	控制大小输出的进制 -d 或 --radix=10 表示 10 进制，-o 或 --radix=8 表示八进制，-x 或 --radix=16 表示 16 进制

--common
	打印每个文件的 common symbols 大小

-t
--totals
	列出所有文件的总大小。注意，只能使用 Berkeley 风格输出

--target=bfdname
	指明目标文件的格式。该选项没有必要指定，因为 size 可自动推导
	
-V
--version
	显示版本
	
@file
	从指定的文件 file 读取命令行选项。文件中的选项由空白符（空格，TAB和回车）分隔。选项中可以包含空白字符，方法是将整个选项用单引号或双引号括起来。任何字符（包括反斜杠）可以通过添加前缀反斜杠来包含。文件本身可能包含额外的 @file 选项，该选项将以递归方式处理

4.常用示例

（1）查看指定程序各个段的大小。以 size 为例。

size /bin/size
text	   data	    bss	    dec	    hex	filename
22565	   1428	   1360	  25353	   6309	/bin/size

（2）查看静态库中的各个目标文件的段大小。以 libc.a 为例。

size /usr/lib64/libc.a

text	   data	    bss	    dec	    hex	filename
233	      4	      0	    237	     ed	init-first.o (ex /usr/lib64/libc.a)
1667	      0	      0	   1667	    683	libc-start.o (ex /usr/lib64/libc.a)
64	      0	      0	     64	     40	sysdep.o (ex /usr/lib64/libc.a)
953	      0	      0	    953	    3b9	version.o (ex /usr/lib64/libc.a)
395	      0	      0	    395	    18b	check_fds.o (ex /usr/lib64/libc.a)
852	      8	   2192	   3052	    bec	libc-tls.o (ex /usr/lib64/libc.a)
307	      0	      0	    307	    133	elf-init.o (ex /usr/lib64/libc.a)
8	      0	      0	      8	      8	dso_handle.o (ex /usr/lib64/libc.a)
0	      0	      4	      4	      4	errno.o (ex /usr/lib64/libc.a)
...

●ldconfig 命令:
1.简介

ldconfig 命令用于在默认搜寻目录 /lib 和 /usr/lib 以及动态库配置文件 /etc/ld.so.conf 内所列的目录下，搜索出可共享的动态链接库（格式如 lib*.so*），进而创建出动态链接器（ld.so 或 ld-linux.so）所需的缓存文件。缓存文件默认为 /etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表。为了让动态链接库为系统所共享，需运行动态链接库的管理命令 ldconfig 更新动态链接库的缓存文件。

ldconfig 位于 /sbin 目录下，通常在系统启动时运行，当用户安装了一个新的动态链接库时，需要手动运行这个命令。
2.命令格式

/sbin/ldconfig [ -nNvXV ] [ -f conf ] [ -C cache ] [ -r root ] directory ...
/sbin/ldconfig -l [ -v ] library ...
/sbin/ldconfig -p

3.参数说明

-v, --verbose
	用此选项时，ldconfig 将显示正在扫描的目录及搜索到的动态链接库，还有它所创建的链接的名字

-n
	ldconfig仅扫描命令行指定的目录，不扫描默认目录（/lib、/usr/lib），也不扫描配置文件 /etc/ld.so.conf 所列的目录。

-N
	ldconfig 不重建缓存文件（/etc/ld.so.cache），若未用 -X 选项，ldconfig 照常更新文件的链接

-X
	ldconfig 不更新文件的链接，若未用 -N 选项，则缓存文件照常重建

-f <conf >
	指定动态链接库的配置文件为 <conf > ，系统默认为 /etc/ld.so.conf

-C <cache>
	指定生成的缓存文件为 <cache>，系统默认的是 /etc/ld.so.cache，此文件存放已排好序的可共享的动态链接库的列表

-r <root>
	改变应用程序的根目录为 <root>（是调用 chroot 函数实现的）。选择此项时，系统默认的配置文件 /etc/ld.so.conf，实际对应的为 <root>/etc/ld.so.conf。如用 -r /usr/zzz时，打开配置文件 /etc/ld.so.conf 时，实际打开的是 /usr/zzz/etc/ld.so.conf 文件。用此选项，可以大大增加动态链接库管理的灵活性

-l
	通常情况下，ldconfig 搜索动态链接库时将自动建立动态链接库的链接，选择此项时，将进入专家模式，需要手工设置链接，一般用户不用此项

-p, --print-cache
	ldconfig 打印出当前缓存文件保存的所有共享库的名字

-c FORMAT 或 --format=FORMAT：此选项用于指定缓存文件所使用的格式，共有三种：old(老格式)，new(新格式)和compat（兼容格式，此为默认格式）。

-V
	打印出 ldconfig 的版本信息

-?, --help, --usage
	这三个选项作用相同，都是让ldconfig打印出其帮助信息

4.常用示例

（1）显示 ldconfig 帮助信息。

ldconfig -?

（2）显示 ldconfig 版本信息。

ldconfig -V

（3）刷新动态链接库缓存文件 /etc/ld.so.cache。

sudo ldconfig

5.注意事项

（1）往 /lib 和 /usr/lib 里面加动态链接库，是不用修改 /etc/ld.so.conf的，但是完了之后要调一下 ldconfig，不然这个 library 会找不到。

（2）想往上面两个目录以外加东西的时候，一定要修改 /etc/ld.so.conf，然后再调用 ldconfig，不然也会找不到。

比如安装了一个 mysql 到 /usr/local/mysql，mysql 有一大堆 library在 /usr/local/mysql/lib 下面，这时就需要在 /etc/ld.so.conf 里面加一行 /usr/local/mysql/lib，保存过后执行 ldconfig 更新一下动态链接库缓存 /etc/ld.so.cache，新的 library 才能在程序运行时被找到。

（3）如果想在 /lib 和 /usr/lib 这两个目录以外放 lib，并且又不想在 /etc/ld.so.conf 中加动态链接库的目录（或者是没有权限加）。那么可以 export 一个全局变量 LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找 library。一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。

（4）ldconfig 更新动态链接库的缓存文件只与程序运行时有关，跟编译时没有关系。编译时需要加 -L 就得加，不要混淆了。

（5）总之，就是不管做了什么关于 library 的变动后，最好都 ldconfig 一下，不然会出现一些意想不到的结果。不会花太多的时间，但是会省很多的事。

●ulimit 命令（builtin）:
1.命令简介

ulimit 属 Shell 内建命令，用于查看或设置 Shell 以及通过 Shell 启动的进程使用系统资源的上限。

限制分为软限制（当前限制）和硬限制，其中硬限制是软限制的上限值。如果应用程序在运行过程中使用的系统资源超过相应的软限制，将导致进程的终止。

由于系统资源有限，比如开启文件描述符的数量，进程堆栈的大小，CPU 时间，虚拟内存大小，等等，操作系统对每一个进程都有严格的限制。资源的合理限制和分配，不仅仅是保证系统可用性的必要条件，也与进程性能密不可分。这时，ulimit 可以起到很大的作用，它是一种简单并且有效的实现资源限制的方式。
2.命令格式

ulimit [-HSTabcdefilmnpqrstuvx <limit>]

其中，limit 是对指定类型资源的具体限制，如果不指定，打印资源软限制的当前值（不指定 -H 时）。参数 S 表示设置软限制，H 表示设置硬限制，当都不指定时，表示同时设置软限制和硬限制。
3.选项说明

-H
	设定资源的硬限制，只有 root 用户可以操作。
-S
	设置资源的软限制。
-a
	显示目前所有资源设定的限制。
-b
	socket 缓冲的最大值
-c
	core 文件的最大值，单位 blocks
-d
	进程数据段的最大值，单位 KB。
-e
	调度优先级上限，这里的优先级指 NICE 值。只针对普通用户进程有效
-f
	当前 Shell 可创建文件总大小的上限，单位 blocks
-i
	被挂起/阻塞的最大信号数量
-l
	可以锁住的物理内存的最大值，单位 KB
-m
	可以使用的常驻内存的最大值，单位 KB
-n
	每个进程可以同时打开的最大文件数
-p
	管道的最大值，单位 block，1 block = 512 bytes
-q
	POSIX 消息队列的最大值
-r
	限制程序实时优先级，只针对普通用户进程有效
-s
	进程栈最大值，单位 KB
-t
	最大 CPU 时间，单位 s
-u
	用户最多可启动的进程数目
-v
	当前 Shell 可使用的最大虚拟内存，单位 KB
-x
	文件锁的最大数量
-T
	线程的最大数量

4.常用示例

（1）查看现有系统资源限制。

ulimit -a

core file size          (blocks, -c) unlimited
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 255112
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 65536
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) unlimited
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited

（2）控制进程发生段错误（Segmentation Fault）时生成 coredump 文件。

ulimit -c unlimited

（3）设置进程的栈大小没有限制。

ulimit -s unlimited

●ps 命令:
1.命令简介

ps（Process Status）命令用于查看系统当前进程状态。ps 命令查看的进程信息是当前的一个快照，如果想实时动态地查看进程信息，可以使用 top 命令。

ps 命令是最基本同时也是非常强大的进程查看命令，使用该命令可以查看进程的属主、进程ID、父进程ID、启动时间、占用 CPU 时长、启动命令、当前运行的状态等等，总之大部分信息都是可以通过执行该命令得到。ps 命令可以搭配 kill 命令随时终止不必要的进程。

ps 命令可接收多种类型的命令选项，主要有：
（1）Unix 选项，可以分组，选项前面必须有一个连字符；
（2）BSD 选项，可以分组，不能与连字符一起使用；
（3）GNU long 选项，前面有两个连字符。

不同类型的选项可以自由混合，但可能会出现冲突。有一些同义的选项，它们在功能上是相同的。

默认情况下，ps 选择与当前用户具有相同有效用户 ID（EUID）且与调用者终端关联的所有进程。它显示进程 ID（PID）、与进程相关联的终端（TTY）、以 [DD-]hh:mm:ss 格式累积的 CPU 时间（TIME）和可执行文件名（CMD）。默认情况下输出不排序。
2.命令格式

ps [OPTIONS]

3.选项说明

简单的进程选择（SIMPLE PROCESS SELECTION）
a
	显示与终端关联的所有进程，包括其他用户的进程。一般与 x 选项联用，用于显示所有进程
-A
	选择所有进程，等同于 -e
-a
	选择除会话引导进程（参见 getsid（2））和与终端无关的进程之外的所有进程
-d
	选择除会话引导进程外的所有进程
--deselect
	选择除满足指定条件进程之外的所有进程。等同于 -N
-e
	选择所有进程，等同于 -A
-N
	选择除满足指定条件进程之外的所有进程。等同于 --deselect
T
	选择与当前终端关联的所有进程。等同于没有参数的选项 t
r
	只显示运行状态的进程
x
	显示 EUID（有效用户ID ）等同于 ps 命令的所有进程，包括与终端无关联的进程。一般与 a 选项联用，用于显示所有进程
	
通过参数列表选择进程（PROCESS SELECTION BY LIST）
-C cmdlist
	按照命名名称选择进程
<pid>
-<pid>
p pidlist
-p pidlist
--pid pidlist
	按照进程 ID 选择进程
--Group <grplist>
	按照实际用户组 ID（RGID，real group ID）或者用户组名称选择进程
--group <grplist>
	按照有效用户组 ID（EGID，effective group ID）或者有效用户组名称选择进程
--ppid pidlist
	按照父进程 ID 选择进程
q pidlist
-q pidlist
--quick-pid pidlist
	按进程 ID 以快速模式选择。比如不会选择父进程 ID 出现在 pidlist 的进程
-s sesslist
--sid sesslist
	按 session ID 选择
t ttylist
-t ttylist
	按终端名称选择
-U userlist
--User userlist
	按实际用户 ID（RUID，real user ID）选择
U userlist
-u userlist
--user userlist
	按有效用户 ID（EUID，effective user ID）选择

输出格式控制（OUTPUT FORMAT CONTROL）
-f
	以完整的格式输出，常与 -e 一起使用。此选项可以与许多其他 Unix 样式的选项组合，来添加其他列，比如与 -L 一起使用时，显示 LWP（线程 ID）和 NLWP（线程数）列。它还导致命令参数被打印
-F
	在 -f 选项的基础上，添加 SZ、RSS、PSR 列
o format
-o format
--format format
	用户自定义输出格式，以指定的宏选择需要输出的 UNIX or BSD 列
j
	以 BSD 任务控制格式输出
-j
	以任务格式输出
l
	以 BSD 长格式输出
-l
	以长格式输出，经常与 -y 选项一起使用
Z
-M
	添加一列安全数据。用于 SELinux
O format
-O format
	用户自定义输出格式，其中会预定义一些公共字段。等同于 -o pid,format,state,tname,time,command 或 -o pid,format,tname,time,cmd
s
	以程序信号的格式输出
u
	以用户为主的格式来输出，常与 ax 选项一起使用
v
	以虚拟内存的格式输出
X
	以寄存器格式输出
-y
	以 RSS 列代替 ADDR。此选项只能与 -l 一起使用
	
输出修饰符（OUTPUT MODIFIERS）
c
	列出命令一栏 CMD 时，显示命令的名称，而不包含路径、命令参数或修饰符。可以与 -f 选项联用，只显示命令的名称
--cols n
--columns n
	设置每列的最大字符数
S
--cumulative
	统计进程相关数据时，比如 CPU 使用率，包括已经死掉的进程
e
	在 COMMAND 列后输出环境变量
f
--forest
	用ASCII字符显示树状结构，表达程序间的相互关系
h
	不显示列名
-H
	显示树状结构，表示程序间的相互关系
--headers
	重复输出列名，每页输出一行列名
k spec
--sort spec
	指定排序规则。spec 语法是 [+|-]key[,[+|-]key[,...]]，其中 + 表示递增，- 表示递减，默认为递增。key 表示列名称，比如 pid（进程 ID）、ppid（父进程 ID）。如果以 pid 递减输出，可以指定 k -pid 或 --sort -pid
n
	以数字表示 USER 和 WCHAN 列，包括 UID 和 GID
-n namelist
N namelist
	设置查找内核函数名称的文件，用于正确地显示 WCHAN 列。默认搜索路径为：
	$PS_SYSMAP
	$PS_SYSTEM_MAP
	/proc/*/wchan
	/boot/System.map-$(uname -r)
	/boot/System.map
	/lib/modules/$(uname -r)/System.map
	/usr/src/linux/System.map
	/System.map
--no-headers
--no-heading
	不输出列名
O order
	按照指定的列进行排序，语法是 O[+|-]k1[,[+|-]k2[,...]]。其中 + 表示递增，- 表示递减，默认为递增。k1，k2... 表示列名称的一个字母简称，比如 p（进程 ID）、P 表示（父进程 ID）。如果以 pid 递减输出，可以指定 O -p。列名称的单个字母简称详见手册
--rows n
	设置每页显示的行数
w
-w
	采用宽格式输出
--width n
	每列字符数

线程展示（THREAD DISPLAY）
H
	将线程当做进程显示
-L
	显示线程，可能使用 LWP（线程 ID） 和 NLWP（线程数） 列
m
	在进程后显示线程
L
	列出所有输出格式说明符
V
-V
--version
	打印 procps-ng 软件包的版本。procps-ng 软件包包含了一系列查看和管理系统和进程的工具，比如 ps, top, vmstat, w, kill, free, slabtop, skill 等命令。

进程状态代号（PROCESS STATE CODES）取值如下，一般是 STAT 或者 S 列。

D	不可中断的睡眠状态，通常在等待 IO
R   运行或就绪状态
S   可中断的睡眠状态，比如正在等待某个事件的完成
T   被作业控制信号停止
t   在跟踪期间被调试器停止
W   分页中. 不适用于内核2.6.xx及以后的版本
X   死亡
Z   僵尸进程，已终止，但未被父进程回收

对于 BSD 风格的输出格式，进程状态 STAT 列可能会出现其它字符:

<    高优先级
N    低优先级
L    有些页被锁进内存
s    包含子进程
l    多线程
+    属前端进程组，与终端关联

其它概念，比如输出列的说明符、输出列的含义、影响 ps 的环境变量等，详见 ps 手册。
4.常用示例

（1）使用标准语法查看所有进程。

ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0  2018 ?        01:44:29 /usr/lib/systemd/systemd --system --deserialize 19
root         2     0  0  2018 ?        00:00:19 [kthreadd]
root         3     2  0  2018 ?        00:00:27 [ksoftirqd/0]
root         5     2  0  2018 ?        00:00:00 [kworker/0:0H]
root         7     2  0  2018 ?        00:01:03 [migration/0]
...

各列含义如下：

UID		启动进程的用户 ID
PID		进程 ID
PPID	父进程 ID
C		CPU 使用率，等于 CPU 所有核占用时间比上进程运行的总时间，多核的情况下可能会大于 100%。等同于列 %CPU
STIME	进程开始时间
TTY		启动进程的终端
TIME	占用 CPU 的累加时间
CMD		命令名称及参数

（2）使用 BSD 语法查看所有进程。

ps axu
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  45120  2708 ?        Ss    2018 104:29 /usr/lib/systemd/systemd --system --deserialize 19
root         2  0.0  0.0      0     0 ?        S     2018   0:19 [kthreadd]
root         3  0.0  0.0      0     0 ?        S     2018   0:27 [ksoftirqd/0]
root         5  0.0  0.0      0     0 ?        S<    2018   0:00 [kworker/0:0H]
root         7  0.0  0.0      0     0 ?        S     2018   1:03 [migration/0]
...

相对于ps -ef，多出了如下几列：

USER	启动进程的用户名称。等于 ps -ef 输出的 UID 列
%CPU	CPU 使用率。等于 ps -ef 输出的 C 列
%MEM	内存使用率
VSZ		虚拟内存大小，单位 KB
RSS		常驻物理内存大小，单位 KB
STAT	进程状态
COMMAND	命令名称及参数。等于 ps -ef 输出的 CMD 列

（3）以 PID 列按递减序输出。

ps -ef --sort -pid
UID        PID  PPID  C STIME TTY      STAT   TIME CMD
root     31806     1  0  2018 ?        Ss     0:00 /usr/sbin/sshd
root     30105     2  0 Sep19 ?        S      0:23 [kworker/u12:1]
root     27902     2  0  2018 ?        S<     0:00 [ext4-dio-unwrit]
root     27901     2  0  2018 ?        S      6:28 [jbd2/vda2-8]
...

（4）按照可执行文件名称查看进程信息。

ps -C sshd -f
UID        PID  PPID  C STIME TTY          TIME CMD
root       524     1  0  2018 ?        00:00:00 /usr/sbin/sshd -D -f /etc/ssh/sshd_config.l
root     23881 31806  0 Oct03 ?        00:00:11 sshd: root@pts/0,pts/1
root     31806     1  0  2018 ?        00:00:00 /usr/sbin/sshd

5.拓展知识
5.1 UID、RUID、EUID、SUID 的区别

RUID（Real User ID）即 UID，表示真实用户 ID。创建进程的用户 ID 即为 RUID。

EUID（Effective User ID）表示有效用户 ID，用于系统决定用户对文件的访问权限，也就是说当用户做任何一个操作时，最终看它有没有权限，都是判断有效用户 ID 是否有权限。一般情况下 EUID 等于 RUID。

SUID（Set User ID）用于权限的开放，具有 SUID 权限的文件会在其执行时，使调用者临时获得该文件拥有者的权限，即将调用者的 EUID 变为该文件拥有者的 UID。

比如存放用户名及密码的文件 /etc/shadow 权限如下：

ls -lh /etc/shadow
---------- 1 root root 853 Jan  4  2019 /etc/shadow

可见 shadow 文件的属主是 root，但是任何用户都可以使用 passwd 命令修改它。

ls -lh /usr/bin/passwd
-rwsr-xr-x 1 root root 28K Jun 10  2014 /usr/bin/passwd

注意属主的权限执行位是 s，表示 passwd 命令具有 SUID 权限，它使一般用户在执行 passwd 命令的时候，拥有了 root 的权限。

●top 命令:
1.命令简介

top 命令用于实时显示当前系统资源整体使用情况以及所有进程或线程的资源占用状况。

top 命令提供了交互式界面和丰富的配置功能，是一个综合了多方信息监测系统性能和运行信息的实用工具，类似于 Windows 的任务管理器。
2.命令格式

top -hv|-bcHiOSs -d secs -n max -u|U user -p pid -o fld -w [cols]

3.选项说明

-h
	显示帮助信息然后退出。
-v
	显示版本信息然后退出。
-b
	批处理模式。一般用于将 top 的输出结果重定向到另外的命令或者文件中。此模式下 top 不接受任何交互命令，运行由 -n 选项指定的轮数或者被 kill 后终止
-c
	显示完整的命令，包括命令的路径、名称以及参数
-d secs
	改变屏幕刷新间隔时间。top 运行过程中也可以使用交互式命令 d 或 s 重新设定
-H
	以线程模式执行 top，等同于交互式命令 H。默认情况下以进程模式执行 top，进程模式下，一个进程下的所有线程归总后显示一行
-i
	不显示任何闲置（idle）或无用（zombie）的进程
-n max
	指定更新的次数，完成后将会退出 top
-o fld
	指定排序的列。可以在列名前使用 + 表示由大到小逆序排列，- 表示由小到大正序排列
-O
	打印 -o 选项可用的列名，每行一个列名
-p pid
	只显示指定进程 ID 的进程信息。可以指定多个 PID，最多为 20 个，格式为 -p PID1,PID2,PID3...。特别地，pid 为 0 表示 top 命令本身。如果想显示所有进程信息，无需关闭 top 命令，只需要执行交互式命令 =、u 或 U 即可。
-s
	以安全模式启动 top，对于 root 用户也是如此。这种模式通过系统配置文件能得到更好的控制
-S
	进程 CPU 使用时间为进程本身和其已死亡的子进程的 CPU 使用时间之和
-u user
-U user
	指显示指定的 user id 或者 user name 所属的进程。可以在 user 前面加上感叹号 !，表示反向匹配，即不显示匹配的用户的进程
-w [cols]
	指定显示的宽度，默认为环境变量 COLUMNS 指定的宽度。cols 不能超过 512 或者终端的宽度

4.输出介绍

使用不带任何选项的 top 命令，有如下输出：

top - 16:07:48 up 442 days,  2:51,  3 users,  load average: 0.00, 0.01, 0.05
Tasks: 217 total,   1 running, 216 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.6 us,  0.3 sy,  0.0 ni, 99.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 15140452 total,   598296 free,   383764 used, 14158392 buff/cache
KiB Swap:  2104508 total,  1550372 free,   554136 used. 12974597 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+    COMMAND                                                                                                                                                                                                                             
29206 root      20   0  156868   2300   1528 R   0.3  0.0   0:00.17 top                                                                                                                     
    1 root      20   0   45120   2708   1308 S   0.0  0.0 107:09.19 systemd                                                                                                                 
    2 root      20   0       0      0      0 S   0.0  0.0   0:19.67 kthreadd                                                                                                                
    3 root      20   0       0      0      0 S   0.0  0.0   0:27.96 ksoftirqd/0                                                                                                             
    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H                                                                                                            
    7 root      rt   0       0      0      0 S   0.0  0.0   1:04.99 migration/0                                                                                                             
    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh                                                                                                                  
    9 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/0                                                                                                                 
   10 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcuob/1
...   

前五行是系统整体的统计信息，称为汇总区（Summary Area）。

第一行是时间相关和任务队列信息，同 uptime 命令的执行结果。

16:07:48						当前时间
up 442 days,  2:51				系统运行的总时长，单位分
3 users							当前登录用户数
load average: 0.00, 0.01, 0.05	系统负载，即任务队列的平均长度。三个数值分别为最近 1 分钟、5 分钟、15 分钟的平均值。

第二行是进程信息统计数据。

217 total		总的进程数
1 running		正在运行的进程数
216 sleeping	睡眠的进程数
0 stopped		停止的进程数
0 zombie		僵尸进程数

第三行是 CPU 统计数据。

0.6 us	用户空间占用CPU百分比
0.3 sy	内核空间占用CPU百分比
0.0 ni	用户进程空间内改变过优先级的进程占用CPU百分比
99.1 id	空闲CPU百分比
0.0 wa	等待输入输出的CPU时间百分比
0.0 hi	硬中断（Hardware IRQ）占用CPU百分比
0.0 si	软中断（Software IRQ）占用CPU百分比
0.0 st	虚拟机（虚拟化技术）占用百分比

第四行为物理内存的统计数据。

15140452 total		物理内存总量
598296 free			空闲内存总量
383764 used			已使用的物理内存总量
14158392 buff/cache	用作内核缓存的内存量

第五行为交换分区（即虚拟内存）的统计数据。

2104508 total		交换区总量
1550372 free		空闲交换区总量
554136 used			已使用的交换区总量
12974597 avail Mem	实际可用物理内存总量

这里要说明的是不能用 Windows 的内存概念来理解这些数据，如果按 Windows 的方式来理解，此服务器共只剩下 598MB 的内存，实际上系统可用的物理内存远不止这些。free 内存表示尚未被内核占用的空闲内存，但是被内核占用用于 buffer 和 cache 的内存，实际上是可以被进程使用的，内核并不把这些可被重新使用的内存算到 free 中，因此在 Linux 上 free 内存会越来越少，但不用为此担心。

第六行是空行。从第七行开始，显示了各个进程的状态信息，称为任务区（Task Area）。各列含义如下：

PID		进程id
USER	进程所有者
PR		进程优先级，范围为0-31，数值越低，优先级越高
NI		nice值。范围-20到+19，用于调整进程优先级，新的进程优先级 PR(new)=PR(old)+nice，所以nice负值表示高优先级，正值表示低优先级
VIRT	进程使用的虚拟内存总量，单位 KB
RES		Resident Memory Size，进程使用的、未被换出的物理内存大小，单位 KB
SHR		共享内存大小，单位 KB
S		进程状态。D(uninterruptible sleep)=不可中断的睡眠状态；R(Running)=运行；S(Sleeping)=睡眠；T(sTopped by job control signal)=停止；t(stopped by debugger during trace)=跟踪；Z(Zombie)=僵尸进程
%CPU	上次更新到现在的 CPU 时间占用百分比。注意，在多核或多 CPU 环境中，如果进程是多线程的，而 top 不是在线程模式下运行的，该值由多个核的值累加，可能会大于 100%
%MEM	进程使用的物理内存百分比
TIME+	进程使用的 CPU 时间总计，单位 1/100 秒
COMMAND	进程名称（命令名/命令行）

top 可输出的全部进程指标可以使用命令top -O查看，其它指标的介绍这里不再赘述，具体可参见 top manual。top -O 输出结果如下：

PID
PPID
UID
USER
RUID
RUSER
SUID
SUSER
GID
GROUP
PGRP
TTY
TPGID
SID
PR
NI
nTH
P
%CPU
TIME
TIME+
%MEM
VIRT
SWAP
RES
CODE
DATA
SHR
nMaj
nMin
nDRT
S
COMMAND
WCHAN
Flags
CGROUPS
SUPGIDS
SUPGRPS
TGID
ENVIRON
vMj
vMn
USED
nsIPC
nsMNT
nsNET
nsPID
nsUSER
nsUTS

5.交互式命令

执行 top 命令后，可以通过交互式命令与 top 进行交互，达到我们想要的输出效果。从使用角度来看，熟练地掌握这些命令比掌握选项还重要一些。这些命令都是单字母的，如果在命令行选项中使用了 -s 安全模式选项，则可能其中一些命令会被屏蔽掉。

按照交互式命令的作用划分，可分为如下四类：
（1）全局命令（Global Commands）；
（2）作用于前五行系统整体统计信息的汇总区命令（Summary Area Commands ）；
（3）作用于进程信息列表的任务区命令（Task Area Commands）；
（4）改变窗口的显示颜色（Color-Mapping）。

（1）全局命令（Global Commands）。
命令前有星号表示该命令在安全模式（Secure Mode）下不起作用。

<Ent/Sp>	
	刷新显示的信息
?/h			
	显示交互式命令的帮助（Help）信息		
=			
	显示所有进程信息。在使用 -p 选项只显示指定进程 ID 的进程信息时，可以使用 = 打破该限制以显示所有进程信息
0			
	在进程详情区显示或隐藏为 0 的字段数值。注意，有些字段如 UID, GID, NI, PR or P 不受此开关的影响
A			
	在 full-screen mode 与 alternate-display mode 间切换。top 默认为 full-screen mode
B			
	粗体显示汇总区（summary area）和任务区（task area）数值
* d/s		
	设定刷新间隔，单位秒。安全模式下不起作用
E			
	扩增（Extend）汇总区内存显示单位，从 KB、MB、GB、TB、PB 到 EB 循环切换
e			
	扩增（Extend）任务区内存显示单位，从 KB、MB、GB、TB、PB 到 EB 循环切换
g			
	选择要展示的字段组（group），取值为 1 到 4，top 默认为 1。这四组同时展示即为 alternate-display mode
H			
	以线程（tHread）模式展示任务区，每个线程单独显示一行。默认为进程模式，一个进程下的所有线程归总后显示一行	
I
	打开或关闭 Irix/Solaris-Mode。打开后，一个任务的 CPU 使用率将会被除以 CPU 核心数
* k			
	杀死（Kill）指定进程。需要手动输入 PID 以及需要发送给该进程的信号。默认信号为15（SIGTERM）。如果不能正常结束可以使用信号9（SIGKILL）强制结束该进程。安全模式下该命令不起作用
q
	退出
* r
	更新（Renice）任务的 nice 值。执行 r 后，将提示用户输入 PID 和相应的 nice 值。输入的 PID 如果为负数，表示第一个任务。如果 PID 为 0，表示 top 命令本身。一般情况下，普通用户只允许增大 nice 值，以降低进程的优先级
W			
	将当前 top 的选项、交互式命令开关、当前显示模式以及刷新间隔写到（Write）配置文件 ~/.toprc，以便下一次打开 top 时能够进入退出 top 前的状态
X			
	改变某些列的固定宽度（eXtra-Fixed-Width）。可改变的列如下：
    field  default    field  default    field  default
    GID       5       GROUP     8       WCHAN    10
    RUID      5       RUSER     8       nsIPC    10
    SUID      5       SUSER     8       nsMNT    10
    UID       5       USER      8       nsNET    10
                      TTY       8       nsPID    10
                                        nsUSER   10
                                        nsUTS    10
	如果输入的是 0，恢复到默认值，如果输入的是正数，则增加相应的宽度。如果输入的是负数，则 top 将自动增加列的宽度直到展示的数据没有被截断
Y
	键入交互式命令 Y 后，将提示输入目标 PID。会在一个单独的屏幕接受输入值或默认的结果，这个屏幕可以用于观察各种文件或管道命令的输出，此时 top 的视图是暂停更新的
Z
	进入颜色设置窗口

（2）汇总区命令（Summary Area Commands ）。

C
	在第六行显示或隐藏任务区坐标（Coordinates）原点位于第 x 列，第 y 行
l
	显示或隐藏系统启动时间信息和平均负载（Load-Average/Uptime）。即显示或隐藏第一行
t
	显示或隐藏任务与 CPU 信息（Task/Cpu-States），即第二行和第三行
m
	显示或隐藏内存信息（Memory/Swap-Usage），即第四行和第五行
1
	显示或隐藏每个 CPU 核心的使用信息，即影响第三行 CPU 信息显示方式
2
	显示或隐藏 NUMA 节点信息
3
	显示或隐藏 NUMA 节点信息，需要手动输入选择要展示的 NUMA 节点

（3）任务区命令（Task Area Commands）。
任务区命令在 full-screen mode 下都有效，在 alternate-display mode 下无效。按照功能又可细分为如下四类：

Appearance:  b, J, j, x, y, z
Content:     c, f, F, o, O, S, u, U, V
Size:        #, i, n
Sorting:     <, >, f, F, R

详解如下：

Appearance:
b
	当列和行进行高亮显示时，执行 b 命令可切换列和行背景是否高亮
J
	数值列调整（Justify），进行左对齐或右对齐。默认为右对齐
j
	字符串列调整（Justify），进行右对齐或左对齐。默认为左对齐
x
	高亮显示被选中的列
y
	高亮显示正在运行的任务
z
	切换到白字黑底或黑字白底的颜色模式

Content:
c
	切换显示命令名称和完整命令行
f/F
	进入字段（Field）管理窗口，选择显示或隐藏的列
o/O
	添加过滤条件，用于决定哪个任务显示在任务区
S
	切换到 CPU 时间为累计模式，每个进程的 CPU 时间包括其已死亡的子进程
u/U
	只展示制定 User ID 或 User Name 的任务
V
	按照父进程 ID 有小到大重新排序进程，使得子进程在父进程的下方
	
Size
i
	忽略闲置和僵尸进程
#/n
	设置任务区最多可显示的任务数

Sorting:
M
	按照列 %MEM 排序 
N
	按照列 PID 排序  
P
	按照列 %CPU 排序 
T
	按照列 TIME+ 排序
<
	小于号表示向左移动选择待排序的列
>
	大于号表示向右移动选择待排序的列
f/F
	进入字段管理窗口也可以指定待排序的列
R
	在正序与逆序间切换（Reverse）

（4）改变窗口的显示颜色（Color-Mapping）。
键入交互式命令 Z 将进入颜色设置窗口。

有四个大写字母用于选择作用的区域：
   S = Summary Data,  M = Messages/Prompts,
   H = Column Heads,  T = Task Information
   
有8个数字代表不同的颜色：
	0 = black,  1 = red,      2 = green,  3 = yellow,
	4 = blue,   5 = magenta,  6 = cyan,   7 = white

q
	放弃设定退出颜色设置窗口
a/w
	保存当前设置并进入下一项设置
<Enter>
	保存当前设置并退出颜色设置窗口

6.多窗口模式介绍（alternate display mode）
6.1 窗口总览（WINDOWS Overview）

top 默认进入 full-screen mode，只有一个任务区，可以键入交互式命令 A 进入拥有四个任务区的 alternate display mode。四个任务区编号为 1 到 4，full-screen mode 默认展示的是编号为 1 字段组。alternate display mode 视图如下：
在这里插入图片描述
在 alternate display mode 视图下，当前字段组，即当前窗口，是可以直接操作的窗口，交互式命令会在当前窗口产生作用。进入 alternate display mode 视图，默认的当前窗口是编号为 1 字段组。
6.2 窗口相关的交互式命令（COMMANDS for Windows）

在 full-screen mode 视图下，如果想展示其他字段组，可以键入交互式命令 g 后键入指定编号选择对应的字段组。比如我选择第 2 字段分组，视图如下：
在这里插入图片描述
在 alternate display mode 视图下，同样可以通过命令 g 来选择当前作用于哪个字段组，并且可以通过交互式命令 G 来改变当前字段组的名称。比如将编号为 1 的当前字段组的默认名称由 Def 改为 Fir。
在这里插入图片描述
在 alternate display mode 视图下，连字符 - 或者下划线 _ 可以隐藏或显示当前字段组。隐藏编号为 1 的当前字段组后的视图如下：
在这里插入图片描述
6.3 滚动窗口（SCROLLING a Window）

Up,PgUp
	向上滚动当前字段组的任务区
Down,PgDn
	向下滚动当前字段组的任务区
Left,Right
	向左或向右滚动当前字段组的任务区
Home
	跳转到当前字段组任务区的第一行
End
	跳转到当前字段组任务区的最后一行
C
	在第六行显示或隐藏任务区坐标（Coordinates）原点位于第 x 列，第 y 行

6.4 在窗口内搜索（SEARCHING in a Window）

（1）L
在当前窗口内，可以使用交互式命令 L 来定位到指定内容的任务行。键入 L 后，将会提示输入待查找的大小写敏感的字符串。比如查到 top 命令行。
在这里插入图片描述
当然，L 命令在全屏模式（full-screen mode）下也可以使用。

（2）&
如果 L 命令匹配了多行，使用 & 可以跳转到下一行。
6.5 在窗口内过滤（FILTERING in a Window）

使用交互式命令 o 或者 O 可以建立选择条件，用于确定哪些任务显示在当前窗口中。

建立筛选器至少需要输入三部分：
（1）字段名；
（2）运算符。可为 =、< 或 > ;
（3）选择值。

筛选条件书写格式如下：

[!]<字段名><运算符><选择值>

其中，感叹号表示反向过滤，即满足条件的行不展示在任务区。注意，筛选条件不能有空格。这个是 top 最复杂的用户输入需求，输入时多加小心。

如果想清除建立的过滤器，可以键入命令 = 清除当前窗口的过滤器。如果是在 alternate display mode 视图下，键入命令 + 将清除所有窗口的过滤器。

比如我们建立一个过滤器，规则为 %CPU 列数值大于 0.0 。那么在键入命令 o 或者 O 后，输入的过滤规则为%CPU>0.0。结果视图为：
在这里插入图片描述
7.配置文件

top 有两个级别的配置文件，一是系统配置文件，对所有用户有效，地址是/etc/toprc，并且只能有两行，示例内容如下：

s        # line 1: secure mode switch
5.0      # line 2: delay interval in seconds

另外一个是用户级配置文件，只对具体用户有效，地址是~/.toprc。使用交互式命令 W 会创建或更新改配置文件，其内容大致如下：

global   # line  1: the program name/alias notation
  "      # line  2: id,altscr,irixps,delay,curwin
per ea   # line  a: winname,fieldscur
window   # line  b: winflags,sortindx,maxtasks,graph modes
  "      # line  c: summclr,msgsclr,headclr,taskclr
global   # line 15: additional miscellaneous settings
  "      # any remaining lines are devoted to the
  "      # generalized inspect provisions
  "      # discussed below

8.常用示例

（1）按照 CPU 使用率 %CPU 排序进程。
运行 top 后键入交互式命令 P。效果如下：
在这里插入图片描述
（2）按照内存使用率 %MEM 排序进程。
运行 top 后键入交互式命令 M。效果如下：
在这里插入图片描述
（3）背景高亮显示任务区当前排序列和正在运行的进程。
运行 top 后键入交互式命令 x 和 y，然后再键入 b 进行背景高亮。效果如下：
在这里插入图片描述
并且可以使用大于号 > 向右选择排序列，使用小于号 < 向左选择排序列。

（4）监控各个逻辑 CPU 的使用状况
在 top 基本视图中，默认只会显示 CPU 总的使用情况。键入数字 1，可以查看每个逻辑 CPU 的使用情况。效果如下：
在这里插入图片描述

●uptime 命令:
1.命令简介

uptime 用于显示系统总共运行了多长时间和系统的平均负载。

无选项 uptime 命令会显示一行信息，依次为：当前时间、系统已经运行了多长时间、目前有多少用户登录、系统在过去的 1 分钟、5 分钟和 15 分钟内的平均负载。输出结果等同于 top 命令汇总区的第一行。
2.命令格式

uptime [options]

3.选项说明

-p, --pretty
	采用可读友好的格式输出系统已运行时长
-h, --help
	显示帮助信息
-s, --since
	以格式 yyyy-mm-dd HH:MM:SS format 输出系统启动时间
-V, --version
	显示版本信息

4.常用示例

（1）查看系统运行时长与平均负载。

uptime
22:54:55 up 445 days,  9:38,  5 users,  load average: 0.08, 0.08, 0.06

显示的信息依次为：当前时间（22:54:55）、系统已经运行了多长时间（up 445 days, 9:38，表示 445 天 9 时 38 分钟）、目前有多少登录用户（5 users）、系统在过去的 1 分钟、5 分钟和 15 分钟内的平均负载（load average: 0.08, 0.08, 0.06）。

（2）查看系统启动时间。

uptime -s
2018-07-20 13:16:21

（3）只输出系统运行时长。

uptime -p
up 1 year, 11 weeks, 4 days, 9 hours, 43 minutes

5.拓展知识
5.1 什么是系统平均负载

系统平均负载指单位时间内，系统中处于可运行状态和不可中断状态的进程数，也就是平均活跃进程数，他和 CPU 使用率没有直接关系。

可运行状态的进程指正在使用 CPU 或正在等待使用 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。

不可中断状态的进程指正在等待某些 I/O 的进程，即我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。例如等待磁盘 I/O，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。
5.2 系统平均负载多少时合理

uptime 命令给出的三个时间段的平均负载并不是标准化的，因为系统中 CPU 核心数量是不定的。所以平均负载为 1 意味着拥有一个 CPU 核心的系统一直在忙碌，而在一个拥有 4 个 CPU 核心的系统上，意味着系统 75% 的时间是空闲的。

所以，当系统平均负载除以 CPU 核心数小于等于 1 表示系统没有出现过载的情况。最理想的情况是每个CPU 上都刚好运行一个进程，这样 CPU 就得到了充分的利用。

三个时间段统计出的系统平均负载，我们以哪个数字为准？一分钟？五分钟？还是十五分钟？我们应该着眼于五分钟或者十五分钟的平均数值，如果前一分钟的负载情况是 1.00，那么仍可以说明认定服务器情况还是正常的，但是如果十五分钟的数值仍然保持在 1.00，那么就值得注意了。

另外，读取文件 /proc/loadavg 可直接查看系统平均负载。

cat /proc/loadavg
0.04 0.03 0.05 1/319 21900

除了前 3 个数字表示系统平均负载外，后面的一个分数，分母表示系统进程总数，分子表示正在运行的进程数；最后一个数字表示最近运行的进程 ID。
5.3 获取系统 CPU 核心数

使用 lscpu 命令查看。
在这里插入图片描述
或者直接访问文件 /proc/cpuinfo 获取 CPU 核心数。

grep 'model name'  /proc/cpuinfo | wc -l
6

5.4 平均负载与 CPU 使用率的关系

在日常使用中，我们经常容易把平均负载和CPU使用率混淆，这里我们做下区分。

平均负载是指单位时间内，系统中处于可运行状态和不可中断状态的进程数，所以，他不仅包扩了正在使用CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。

而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，和平均负载并不一定完全对应。比如：
（1）CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
（2）I/O 密集型进程， 等待 I/O 也会导致平均负载升高，但是 CPU 使用率不一定很高；
（3）存在大量等待 CPU 调用的进程也会导致平均负载升高，此时的 CPU 使用率也会比较高。

●kill 命令:
1.命令简介

kill 命令用于终止进程或向进程发送指定信号。

kill 命令可以发送指定的信号到相应的进程或进程组。不指定信号缺省发送 SIGTERM(15)来终止指定进程。如果想强制终止进程，可以显示指定 SIGKILL(9) 信号，因为该信号无法被进程捕获。

本文介绍的是符合 POSIX 标准的 kill 功能，不同 Linux 发行版对 kill 的实现有所不同，具体参见其对应的帮助手册。
2.命令格式

kill -l [SIGNAL]
kill [-s SIGNAL | -SIGNAL]  PID...

操作数 PID 有两种取值：
（1）进程 ID 或者进程组 ID;
（2）作业 ID，用于标识运行于后台的一组进程。
3.选项说明

-SIGNAL
-s SIGNAL
	指定信号名或信号值
-l [SIGNAL]
	指定信号名或信号值，转换信号名与信号值。如果不指定信号，则列出所有信号。信号的定义见 /usr/include/linux/signal.h

4.常用示例

（1）强制杀死当前 Shell 进程，退出当前会话。

echo $$
20174

kill -9 20174

（2）根据进程名称先查找出 PID 再强制杀死。

ps -ef | grep COMMADNAME | awk '{print $2;}' | xargs kill -9

也可以使用 killall 命令根据进程名称杀死进程。

killall -9 COMMADNAME 

（3）列出所有信号。

kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX

只有第信号 SIGKILL(9) 才可以无条件终止进程，其他信号进程都有权忽略，下面是常用的信号：

SIGHUP	1	终端断线
SIGINT	2	中断（同 Ctrl + C）
SIGQUIT	3	退出（同 Ctrl + \）
SIGABRT	6	中止
SIGKILL	9	强制终止
SIGTERM	15	终止
SIGCONT	18	继续（与 STOP 相反）
SIGSTOP	19	暂停（同 Ctrl + Z）

●killall 命令:
1.命令简介

killall 使用进程的名称来杀死进程，可以杀死一组同名进程。

我们可以使用 kill 命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用 ps 等命令再配合 grep 来查找进程，而 killall 把这两个过程合二为一，是一个很好用的命令。

使用 killall 需要注意如下几点：
（1）killall 可以发送一个信号给指定名称的所有进程，如果没有指定信号, 缺省发送 SIGTERM(15)，该信号的默认动作是终止进程；
（2）指定信号时可以使用信号名或者信号值，例如 -HUP、-SIGHUP 或 -1，也可以使用选项 -s；
（3）如果命令名不是以 -r 选项指定的正则表达式并且包括斜杠（/）, 那么执行该特定文件的进程将被杀掉, 这与进程名无关；
（4）killall 进程不会杀死自己，但是可以杀死其它 killall 进程。
2.命令格式

killall [OPTIONS] NAME...
killall -l | --list
killall -V | --version

3.选项说明

-e
--exact
	对于很长的名字, 要求准确匹配。如果一个命令名长于 15 个字符, 使用该选项则会忽略该进程，如果同时指定了 -v 选项, killall 会针对每个忽略的记录打印一条消息
-I
--ignore-case
	匹配进程名时忽略大小写
-g
--process-group
	杀死进程所属的进程组，如果有多个进程均属于同一个进程组，则只发送一次 KILL 信号到进程组
-i
--interactive
	杀死进程前交互式询问是否确定杀死
-l
--list
	列出所有已知信号名
-o TIME
--older-than TIME
	杀死启动时间比指定时间早的进程
-q
--quiet
	静默模式。如果没有杀死任何进程，不输出提示信息
-r
--regexp
	使用扩展正则表达式匹配进程名
-s SIGNAL
--signal SIGNAL
-SIGNAL
	指定信号替代默认的 SIGTERM
-u USER
--user USER
	只杀死指定用户的进程
-v
--verbose
	报告信号是否成功发送
-V
--version
	显示版本信息
-w
-–wait
	等待所有被终止的进程结束。killall 每秒检查一次，如果有任何被杀死的进程仍然存在，则不返回。注意，如果信号被忽略或者进程保持僵尸状态，killall 可能会永远等待
-y TIME
--younger-than TIME
	杀死启动时间比指定时间晚的进程。与选项 -o,--older-than 作用相反
-Z REGEXP
--context REGEXP
	（SELinux only）只杀死具有指定上下文的进程。必须在其他参数之前。命令名是可选的

4.常用示例

（1）杀死有所同名进程。

killall top

（2）列出 killall 支持的所有信号。

killall -l

HUP INT QUIT ILL TRAP ABRT IOT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM
STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH IO PWR SYS
UNUSED

●rmdir 命令:
1.命令简介

rmdir 命令用来删除一个或多个空目录。

注意，rmdir 命令无法删除非空目录，删除非空目录可以使用命令rm -r。
2.命令格式

rmdir [OPTION]... DIRECTORY...

3.选项说明

--ignore-fail-on-non-empty
	忽略由于删除非空目录时导致的错误信息
-p, --parents
	删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除
-v, -verboes
	显示命令的详细执行过程
--help
	显示命令的帮助信息
--version
	显示命令的版本信息

4.常用示例

（1）删除子目录 dir 后，如果父目录 bin 为空的话，一并删除。

rmdir -p bin/dir

（2）删除当前目录下所有隐藏的空目录。

rmdir .* 2>/dev/null

●pidof 命令:
1.命令简介

pidof 命令用于查找指定名称进程的进程ID，是命令 killall5 的一个软链接。

找出进程 ID 的目的通常是根据进程 ID 进一步确认进程的运行状态、杀掉进程或者发送一个信号给它。
2.命令格式

pidof [-s] [-c] [-n] [-x] [-m] [-o omitpid[,omitpid..]] [-o omitpid[,omitpid..]..]  program [program..]

3.选项说明

-s
	只返回一个 PID
-c
	只显示运行在 root 目录下的进程，这个选项只对 root 用户有效
-x
	显示指定脚本名称的进程
-o OMITPID
	指定不显示的进程ID。该选项可以出现多次
-m
	与 -o 选项一起使用，使得 argv[0] 与 argv[1] 和被忽略进程相同的进程同时被忽略。一般用于忽略由同名 Shell 脚本启动的进程，因为 argv[0] 为 Shell，一般为 /bin/bash，argv[1] 为脚本名称

4.常用示例

（1）查看程序名称为 sshd 的进程 ID。

pidof sshd
31806 21909 8607 524

（2）查看由 Shell 脚本启动的进程 ID。

pidof -x sleep.sh

sleep.sh 为自定义的脚本，睡眠一段时间，然后退出，内容如下：

#!/bin/bash

echo "begin sleep"
sleep 10000
echo "end sleep"

启动方式采用运行于后台的方式。

./sleep.sh &

●chown 命令:
1.命令简介

chown 命令用来改变某个文件或目录的属主（owner）和所属用户组（group）。仅限超级用户 root 使用。

该命令通过改变文件的属主或者所属用户组可以向某个用户授权。属主可以是用户名或用户 ID，用户组可以是组名或组 ID。文件名是由空格分隔的文件列表，在文件名中可以包含通配符。一般来说，这个指令仅限系统管理者（root）使用，普通用户没有权限改变文件属主及所属组。
2.命令格式

chown [OPTION]... [OWNER][:[GROUP]] FILE...
chown [OPTION]... --reference=RFILE FILE...

在指定属主与所属用户组时有如下几种情况：
（1）如果只指定了属主，则只改变每个给定文件的属主，不会更改文件的用户组；
（2）如果属主后面跟一个冒号和用户组，则文件所属的用户组也将被更改；
（3）如果用户名后面有冒号但没有组名，则该用户将成为文件的属主，并且文件属组将更改为该用户的登录组；
（4）如果给定冒号和组名，但省略了属主，则只更改所属组。这种情况，chown 的功能等同于 chgrp；
（5）如果只给定一个冒号，或者整个操作数为空，则属主和用户组都不会更改。

注意，OWNER 与 GROUP 之间的冒号可以使用点号替代。
3.选项说明

-c
--changes
	 输出效果类似 verbose 模式，但只在有更改生效时才显示
-f
--silent
--quiet
	忽略大部分错误信息
-v
--verbose
	显示指令详细的执行过程
--dereference
	修改符号链接指向的实际文件的属主和所属用户组，而不是符号链接文件本身。为默认选项
-h
--no-dereference
	修改符号链接文件本身的属主和所属用户组。作用与 --dereference 相反
--from=CURRENT_OWNER:CURRENT_GROUP
	只有当文件的属主和所属组符合选项所指定的才更改。CURRENT_OWNER 和 CURRENT_GROUP 可以省略，这时省略的属性就不需要进行匹配
--no-preserve-root
	不特殊对待根目录 /。为默认选项
--preserve-root
	不允许在根目录 /上递归操作
--reference=RFILE
	使用指定的文件 RFILE 的属主和所属用户组，而非指定值
-R
--recursive
	递归处理所有的文件及子目录
	
	以下三个选项 -H、-L 和 -P 与 -R 配合使用，用于递归操作时确定遍历的方式：
-H
	如果命令行参数是一个符号链接指向一个目录，则遍历它
-L
	遍历每一个符号链接指向的目录
-P
	不遍历任何符号链接。为默认选项
--help
	显示帮助信息
--version
	显示版本信息

4.常用示例

（1）只修改文件属主为 root。

chown root FILE

注意，指定的属主必须是系统合法用户，可以查看文件 /etc/passwd 确定当前系统有哪些用户。

（2）修改文件属主和用户组均为 root。

chown root:root FILE

（3）只修改文件所属组为 root。

chown :root FILE

（4）递归修改所有的文件及子目录属主和所属组为 root。

chown -R root:root /DIR

（5）显示修改的动作，使用 -v 冗余模式输出。

chown -vR root:root /DIR

5.拓展知识
5.1 用户与组相关配置文件

Linux 与用户和组的定义相关的配置文件有：

/etc/passwd 用户信息
/etc/shadow 用户口令及其相关属性
/etc/group 用户组信息
/etc/gshadow 用户组口令及其相关属性

5.1.1 /etc/passwd（7 列）

/etc/passwd 用来保存用户名称、ID、属组 ID、家目录等信息。

每行格式如下：

用户名:口令:用户标识号:组标识号:注释性描述:主目录:默认Shell

示例内容如下：

cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
...

在 passwd 文件中，第一行内容是超级用户 root 行，可以看到它的 uid 和 gid 都为 0。为了方便理解，下面给出各字段的描述：

字段1：用户名，这是用户登录时使用的账户名称，在系统中是唯一的，不能重名
字段2：密码占位符 x；早期的 Unix 系统中，该字段是存放账户密码的，由于安全原因，后来把这个密码字段内容移到 /etc/shadow 中了
字段3：UID；范围是 0-65535
字段4：用户主组的 ID，范围是 0-65535。当添加用户时，默认情况下会同时建立一个与用户同名且 GID 与 UID 相同的组。用户所属的其它用户组定义在文件 /etc/group
字段5：用户说明；这个字段是对这个账户的说明
字段6：宿主目录；用户登录后首先进入的目录，一般为 "/home/用户名" 这样的目录
字段7：登录 Shell   当前用户登录后所使用的 Shell，在 Centos/RHEL 系统中，默认的 Shell 是 Bash；如果不希望用户登登系统，可以通过 usermod 或者手动修改 passwd 设置，将该字段设置为 /sbin/nologin 即可。出于安全考虑，大多数内置系统账户都是 /sbin/nologin，表示禁止登录系统

5.1.2 /etc/shadow（9 列）

/etc/shadow 用于保存加密后的用户口令相关信息，只有 root 用户拥有读写权限。

每行格式如下：

用户名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:保留字段

示例内容如下：

root:$6$25KI3rub$BK5ef2iaxtl0Jn7lofKk9xZDrOU6aamefgIDKlHUycqUvU/lF1XdcQa4Bz53vGmnTh/kV/T1DLtdIRxxVKj8M.:17403:0:99999:7:::
bin:*:16973:0:99999:7:::
daemon:*:16973:0:99999:7:::
adm:*:16973:0:99999:7:::
...

下面是每个字段的详细含义：

第一列：用户名。与 /etc/passwd 文件中的用户名有相同的含义
第二列：加密口令。存放的是加密后的用户口令字串，如果此字段是“*”、“!”、“x”等字符，则对应的用户不能登录系统
第三列：最后一次修改时间。表示从某个时间起，到用户最近一次修改口令的间隔天数。可以通过 passwd 来修改用户的密码，然后查看 /etc/shadow 中此字段的变化
第四列：最小时间间隔。 表示两次修改密码之间的最小时间间隔。
第五列：最大时间间隔。表示两次修改密码之间的最大时间间隔，这个设置能增强管理员管理用户的时效性。
第六列：警告时间。表示从系统开始警告用户到密码正式失效之间的天数。
第七列：不活动时间。此字段表示用户口令作废多少天后，系统会禁用此用户，也就是说系统不再让此用户登录，也不会提示用户过期，是完全禁用。
第八列：失效时间。表示该用户的帐号生存期，超过这个设定时间，帐号失效，用户就无法登录系统了。如果这个字段的值为空，帐号永久可用。
第九列：保留字段： linux的保留字段，目前为空，以备linux日后发展之用。

5.1.3 /etc/group（4 列）

/etc/group 保存了用户组的相关信息。通过查询该文件，可查看某个用户属于哪些组。

每行格式如下：

组名:口令:组标识号:组内用户列表

示例内容如下：

root:x:0:
bin:x:1:
daemon:x:2:
...

每个字段的详细含义：

组名：用户组的名称，由字母或数字构成。与 /etc/passwd 中的用户名一样，组名不能重复。
口令：存放的是用户组加密后的口令字串，密码默认设置在 /etc/gshadow 文件中，而在这里用 “x” 代替，linux 系统下默认的用户组都没有口令，可以通过 gpasswd 来给用户组添加密码。
组标识号：即 GID，与 /etc/passwd 中的组标识号对应。
组内用户列表： 显示属于这个组的所有用户，多个用户之间用逗号分隔。

5.1.4 /etc/gshdow（4 列）

/etc/gshdow 保存了组密码及其相关属性。

每行格式如下：

群组名称：群组密码：组管理员列表：以当前组为附加组的用户列表

示例内容如下：

root:::
bin:::
daemon:::
tcpdump:!::
mysql:!::
...

各个字段详细含义如下：

组名称： 组名称，不能重复
组密码：为空，表示只有组内用户可以获取组权限。为 ! 或者 * 表示用户无法通过组密码获取组权限
组管理员列表： 组管理员的列表，能够更改组密码和成员
以当前组为附加组的用户列表： 以逗号分隔的用户名列表，如果为空，表示用户名与组名相同，即该组是同名用户的主组

●chmod 命令:
1.命令简介

chmod 命令用来变更文件或目录的访问权限。仅限文件属主和超级用户 root 使用。

Linux 文件与目录的权限有三种范围，属主（u，user）、属组（g，group）与其它（o，other），全部用户使用 a（all）表示。每个范围的权限由三个比特位表示，从左至右分别表示 r（read，读）、w（write，写）与 x（execute，可执行）。权限可以使用字符或八进制数字表示，r 对应数字 4，w 对应数字 2，x 对应数字 1。如果相应的权限位没有权限，使用ls -l命令查看时，显示为横杠-。如下图所示：
在这里插入图片描述
注意：
（1）当使用 chmod 改变符号链接的权限时，实际上改变的是目标文件的权限；chmod 无法更改其符号链接的权限，这不是一个 bug，因为符号链接的权限从未被使用过。
（2）chmod 在递归时，遇到符号链接则会忽略之。
2.命令格式

chmod [OPTION]... MODE[,MODE]... FILE...
chmod [OPTION]... OCTAL-MODE FILE...
chmod [OPTION]... --reference=RFILE FILE...

其中 MODE 使用字符形式表示文件权限，格式为 [ugoa…][[±=][perms…]…]。ugoa 任意字母组合指定权限范围，不指定默认为 a。±= 分别表示增加、去除与赋予相应权限。权限 perms 可以是零也可以是 rwxXst 中的多个字符的组合，或者是 ugo 中的某一个字符。MODE 可以出现多次，由逗号隔开。rwxXst 分别表示 r（读）、w（写）、x（可执行）、X（可执行，已经有可执行权限或者目标是目录时使用，以示区分）、s（文件的特殊权限 SETUID 或 SETGID）和 t（粘滞位）。

OCTAL-MODE 为八进制数字表示权限比特位组成的数值。可以指定 1 到 4 个八进制数字（0-7）。从右至左，四个数字分别表示其它 o、用户组 g、属主 u 和文件的特殊权限 SETUID（4）、SETGID（2）和
SBIT（1）。
3.选项说明

-c
--changes
	类似 --verbose，但只在有更改生效时才显示结果
-f
--silent
--quiet
  去除大部份的错误信息
-v
--verbose
	显示指令详细的执行过程
--no-preserve-root
	不特殊对待根目录（默认）
--preserve-root
	禁止对根目录进行递归操作
--reference=RFILE
	使用指定参考文件的权限，而非自行指定
-R
--recursive
	以递归方式更改所有文件及子目录
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）增加全部用户对文件 test.sh 的执行权限。

chmod +x test.sh

#或
chmod a+x test.sh

ll test.sh
-rwx-wx-wx 1 root root 0 Oct 30 20:13 test.sh

（2）减去全部用户对文件 test.sh 的执行权限。

chmod -x test.sh

#或
chmod a-x test.sh

ll test.sh
-rw--w--w- 1 root root 0 Oct 30 20:13 test.sh

（3）增加属主对文件 test.sh 的执行权限。

chmod u+x test.sh

ll test.sh
-rwx-w--w- 1 root root 0 Oct 30 20:13 test.sh

（4）分别使用符号方式和数字方式为文件 test.sh 设置新的权限为 rwxr–r--。

#符号方式
chmod a=rwx,g=r,o=r test.sh

#数字方式
chmod 0744 test.sh

#或
chmod 744 test.sh

ll test.sh
-rwxr--r-- 1 root root 0 Oct 30 20:13 test.sh

（5）递归地将 dir 目录及其下所有文件和子目录加上读权限。

chmod -R a+r dir

ll dir
total 4
drwxrwxrwx 2 root root 4096 Oct 30 20:29 newdir
-rw-rw-rw- 1 root root    0 Oct 30 20:13 test.sh
-rw-rw-rw- 1 root root    0 Oct 30 20:26 test.txt

（6）给文件 test.sh 增加 SETUID 权限。前提是属主对文件 test.sh 有执行权限。

chmod u+x test.sh

ll test.sh
-rwsr--r-- 1 root root 0 Oct 30 20:13 test.sh

5.拓展知识
5.1 文件的特殊权限
5.1.1 SETUID

SETUID 使用小写字母 s 表示，出现在属主可执行权限位，具有 SUID 权限的文件会在其执行时，使调用者的有效身份临时变为该文件的拥有者，用于临时提升权限，使调用者暂时获得该文件拥有者的权限。

例如命令 passwd 的权限：

ll /usr/bin/passwd
-rwsr-xr-x 1 root root 27832 Jun 10  2014 /usr/bin/passwd

在文件拥有者的执行位上出现 s 而不是 x，所以说 passwd 具有 SUID 权限。修改用户密码使用的是 passwd 这个命令，Linux 用户密码存储在文件 /etc/shadow 中。首先查看一下 /etc/shadow 文件的权限：

ll /etc/shadow
---------- 1 root root 853 Jan  4 14:56 /etc/shadow

可见 root 没有读写权限，但是为什么 root 实际上可以读取和修改 shadow 呢？因为 Linux 的权限管理机制不能够限制神一样的 root。从 shadow 的权限列表可以看出，root 组用户和其他用户对 shadow 没有读写权限的，也就是只有 root 才能进行强制的读写操作。但是实际上普通用户是可以自行修改自己的密码的，这就是为什么呢？因为 /usr/bin/passwd 的属主 root 对其权限是 rws，而且其他用户的使用权限为 r-x，也就是说，别人在执行 passwd 时会暂时获得 passwd 的属主即 root 的权限。这就是 Linux 特有的 SUID 权限机制。
5.1.2 SETGID

SETGID 与 SETUID类似，使用小写字母 s 表示，出现在用户组可执行权限位，具有 SETGID 权限的文件会在其执行时，使调用者的有效用户组临时变为该文件属主的用户组，用于临时提升权限，使调用者暂时获得该文件所属用户组的权限。

当 SGID 作用于可执行文件时，在执行该文件时，用户将获得该文件所属组的权限。

当 SGID 作用于目录时，当用户对某一目录有写和执行权限时，该用户可以在该目录下建立文件，如果该目录具有 SGID 权限，则该用户在该目录下建立的文件都属于这个目录所属的组。
5.1.3 SBIT

SBIT（Sticky Bit）称为粘滞位，它出现在其他用户权限的执行位上，只能用来修饰一个目录，用于限制文件的删除。

当某一个目录拥有 SBIT 权限时，则任何一个能够在这个目录下建立文件的用户，该用户在这个目录下所建立的文件，只有该用户自己和 root 可以删除，其他用户均不可以。例如目录 /tmp 的权限如下：

ll -d /tmp
drwxrwxrwt 14 root root 147456 2月  14 16:01 /tmp

注意，如果目录的其他用户的权限执行位是 T，则表示 SBIT 权限无效。发生的情况是权限的执行位不是 x。
5.2 Linux 文件分类

Linux 中一切皆文件，文件一般分为如下几种类型：

- 普通文件
d 目录
b 块设备
c 字符设备
p 命名管道
l 符号链接
s 套接字

如果文件是目录，其 rwx 权限的作用如下：
（1）目录读权限位意味着可以列出其中的内容；
（2）目录写权限位意味着可以在该目录中创建、删除、更名或移动文件，前提是目录需要有执行权限；
（3）目录执行权限位则意味着可以进入该目录进行搜索。因此在创建目录的时候一般都具有可执行权限。

●chgrp 命令:
1.命令简介

chgrp（change group）命令，用来改变指定文件或目录所属的用户组。仅限文件属主与 root 使用。

指定组名时可以是用户组名称也可以是用户组 ID。文件名可以是由空格分隔的文件列表，也可以是由通配符描述的文件集合。
2.命令格式

chgrp [OPTION]... GROUP FILE...
chgrp [OPTION]... --reference=RFILE FILE...

3.选项说明

-c, --changes
	类似 --verbose，但只在有变更时才显示结果
-f, --silent, --quiet
	去除大部份的错误信息
-v, --verbose
	显示指令详细的执行过程
--dereference
	修改符号链接指向的实际文件的属组，而不是符号链接文件本身（默认选项）
-h, --no-dereference
	修改符号链接文件本身的属组。作用与 --dereference 相反
--no-preserve-root
	不特殊对待根目录 /。为默认选项
--preserve-root
	不允许在根目录 /上递归操作
--reference=RFILE
	使用指定的文件 RFILE 的属主和所属用户组，而非指定值
-R, --recursive
	递归处理所有的文件及子目录
	
	以下三个选项 -H、-L 和 -P 与 -R 配合使用，用于递归操作时确定遍历的方式：
-H
	如果命令行参数是一个符号链接指向一个目录，则遍历它
-L
	遍历每一个符号链接指向的目录
-P
	不遍历任何符号链接（默认选项）
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）修改文件 test.sh 所属组为 bin。

chgrp bin test.sh

ll test.sh
-rwxr----- 1 root bin     0 Oct 30 20:13 test.sh

（2）通过组 ID 修改文件 test.sh 所属组为 root。

chgrp 0 test.sh

chgrp 0 test.sh
-rwxr----- 1 root root 0 Oct 30 20:13 test.sh

用户组 root 的 GID 可以通过查看文件 /etc/group 获得，组 root 的 GID 为 0。

head -n1 /etc/group
root:x:0:

第一列为组名，第三列为组 ID。

（3）递归修改指定目录下所有的文件和目录的所属组。

chgrp -R bin dir

ll dir
drwxrwxrwx 2 root bin 4096 Oct 30 20:29 newdir
-rwxr----- 1 root bin    0 Oct 30 20:13 test.sh
-rw-rw-rw- 1 root bin    0 Oct 30 20:26 test.txt

●groups 命令:
1.命令简介

groups 命令用于查询用户所在的组。
2.命令格式

groups [OPTION]... [USERNAME]...

显示每个输入的用户名所在的全部组，如果没有指定用户名则默认为当前进程用户（当用户组数据库发生变更时可能导致差异）。
3.选项说明

--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）显示当前用户所属的组。

groups
root

当前用户为 root，且只有一个主用户组 root。

（2）查看用户 root 所属的组。

groups root
root : root

5.拓展知识

除了使用 grpups 命令查看用户属于哪些组，还可以使用如下几种方法。
（1）查看 /etc/group。
/etc/group 是用户组配置文件，可以查看此文件通过 grep 命令查询某个用户所在的用户组。例如查看 root 所在的用户组

grep root /etc/group
root:x:0:

可见 root 只属于同名的主组 root，不属于其它的任何组。

（2）通过 id 命令。

id root
uid=0(root) gid=0(root) groups=0(root)

第三列表示用户所属的用户组列表，同时输出组的 ID。

●id 命令:
1.命令简介

id 命令用于查看真实有效的用户 ID（UID）和组 ID（GID）。
2.命令格式

id [OPTION]... [USER]

OPTION 和 USER 都是可选的，如果不提供 USER，则打印当前用户的 ID 信息。
3.选项说明

-a
	忽略, 仅为与其他版本相兼容而设计
-Z, --context
	显示当前用户的安全环境（仅当系统支持 SELinux 时可用）
-g, --group
	仅显示用户所属的主组
-G, --groups
	显示用户所有的属组，包括附属组
-n, --name
	对于 -ugG 显示名称而不是替数字 ID
-r, --real
	 对于 -ugG 显示真实 ID 而不是有效 ID
-u, --user
	只显示有效用户 ID
-z, --zero
	使用 NUL 字符分隔条目而不是空格符。默认输出格式不支持该选项
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）查看当前用户 root 与属组的信息。

id
uid=0(root) gid=0(root) groups=0(root)

输出结果中，uid 表用用户 ID，gid 表示用户主组 ID，groups 表示用户所有的属组。从 groups 可以看出，当前用户 root 只属于主用户组 root，没有附属组。

（2）查看当前用户 root 的主组 ID。

id -g
0

0 表示用户组 root 的组 ID。

（3）查看当前用户主组的名称。

id -gn
root

●md5sum 命令:
1.命令简介

md5sum 命令用于产生或校验 MD5 消息摘要（128位）。

MD5 全称是消息摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为 128 位（十六进制长度为 32 位）的散列值，不同的文件产生相同的消息摘要的可能性是非常非常之小的。MD5 常常被用来验证网络文件传输的完整性，防止文件被人篡改。
2.命令格式

md5sum [OPTION]... [FILE]...

FILE 可指定多个，以空格分隔。当不提供 FILE 或者 FILE 为 -，从标准输入读取文件名。
3.选项说明

-b, --binary
	以二进制模式读取
-c, --check
	检验文件的 MD5 值。给定的文件中每一行的内容是 md5sum 的输出结果，即 md5-value  filename（文本输入模式）或 md5-value *filename（二进制输入模式）
--tag
	创建 BSD 风格的 md5 输出行
-t, --text
	以文本模式读取（默认）。注意，在 GNU 系统中，-b 与 -t 选项在读取时没有差别。在输出时，文本输入模式在文件名前是两个空格，二进制输入模式在文件名前是一个空格和星号

以下选项只在校验 md5 值时有效
--quiet
	校验成功的文件不打印 OK
--status
	不输出任何校验成功与失败的信息，使用命令返回码来表示是否校验成功，0 成功，非 0 失败
--strict
	遇到非法格式的校验行，命令返回非 0 状态码
-w, --warn
	遇到非法格式的校验行发出告警

4.常用示例

（1）生成文件的 md5 值，以文件 /etc/passwd 为例。

md5sum /etc/passwd

33c5d3c6b45034fe92c4aa65cfdcaba4  /etc/passwd

（2）生成文件的 md5 值到输出文件 passwd.md5。

md5sum /etc/passwd > passwd.md5

（3）校验文件的 md5 值。使用上面第二步生成的校验行文件。

md5sum -c passwd.md5

/etc/passwd: OK

从输出结果看出，文件的 md5 值校验成功。

（4）从标准输出读取文件。

md5sum

随后输入文件名，然后回车，最后以 Ctrl + D 结束输入。

●head 命令:
1.命令简介

head 命令用于显示文件开头的内容。默认情况下，显示文件的头 10 行内容。
2.命令格式

head [OPTION]... [FILE]...

可以指定多个文件 FILE，以空格分隔，此种情况下，输出的内容前会列出所属文件名。如果未给定 FILE 或者 FILE 是 -，则从标准输入读取。
3.选项说明

-c, --bytes=[-]K
	显示每个文件的前 K 字节内容；如果附加 - 参数，则显示每个文件最后 K 字节外的所有内容
-n, --lines=[-]K
	显示每个文件的前 K 行内容；如果附加 - 参数，则显示每个文件最后 K 行外的所有内容
-q, --quiet, --silent
	多个文件时输出的内容前隐藏文件名
-v, --verbose
	多个文件时输出的内容前显示文件名（默认）
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

注意，长选项的强制参数对于短选项也是强制的。
4.常用示例

（1）显示文件 /etc/passwd 的前 10 行。

head /etc/passwd

root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin

（2）显示文件 /etc/passwd 的前 3 行。

head -n3 /etc/passwd

root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

（3）同时显示多个文件的前 3 行，默认会显示文件名。以 /etc/passwd 和 /etc/group 为例。

head -n3 /etc/passwd /etc/group

==> /etc/passwd <==
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

==> /etc/group <==
root:x:0:
bin:x:1:
daemon:x:2:

●tail 命令:
1.命令简介

tail 命令用于显示文件尾部内容，与命令 head 作用相反。默认情况下，显示文件的末尾 10 行内容。
2.命令格式

tail [OPTION]... [FILE]...

可以指定多个文件 FILE，种情况下，输出的内容前会列出所属文件名。如果未给定 FILE 或者 FILE 是 -，则从标准输入读取。
3.选项说明

-c, --bytes=K
    输出最后 K 个字节；或者使用 +K 表示从文件的第 K 个字节开始到最后
--retry
   不停地尝试打开不可访问的文件。只与 -f 联用时有用
-f, --follow[={name|descriptor}]
    按照指定时间间隔输出文件追加的内容; -f, --follow 以及 --follow=descriptor 作用相同。--follow=name 表示根据文件名检测而不是文件描述符，默认 5 次检测后文件未发生改变则重新打开文件
-n, --lines=N
    输出最后 N 行，而非默认的最后 10 行
--max-unchanged-stats=N
    与选项 --follow=name 联用，N 次检测后如果文件未发生变化，则重新打开文件。此选项不常用，一般文件链接被重定向或者日志滚动时导致文件名发生变化时才使用该选项
--pid=PID
    与 -f 联用，表示在进程 ID 死掉之后结束 tail
-q, --quiet, --silent
    多个文件时输出的内容前隐藏文件名
-s, --sleep-interval=S
    与 -f 联用，表示检测文件变化的间隔，默认 1s
-v, --verbose
    多个文件时输出的内容前显示文件名（默认）
--help
    显示帮助信息后退出
--version
    输出版本信息后退出

注意：
（1）长选项的强制参数对于短选项也是强制的；
（2）K 字节后可以有一个倍数后缀：b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024, GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y；
（3）使用 -f, --follow 时，tail 默认后接文件描述符, 这意味着即使 tail 跟踪的文件改名了，tail 仍然可以显示其末尾部分。如果希望查询文件的实际名称而非文件描述符（例如日志滚动时）, 应使用 --follow=name，tail 将周期性地重新打开所指定的文件。
4.常用示例

（1）显示文件 /etc/passwd 的末尾 10 行。

tail /etc/passwd

rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
nfsnobody:x:65534:65534:Anonymous NFS User:/var/lib/nfs:/sbin/nologin
saslauth:x:996:76:Saslauthd user:/run/saslauthd:/sbin/nologin
avahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin
uucp:x:10:14:Uucp user:/var/spool/uucp:/sbin/nologin
nslcd:x:65:55:LDAP Client User:/:/sbin/nologin
arpwatch:x:77:77::/var/lib/arpwatch:/sbin/nologin
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
mysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologin

（2）显示文件 /etc/passwd 的末尾 3 行。

tail -n3 /etc/passwd

sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
tcpdump:x:72:72::/:/sbin/nologin
mysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologin

（3）从第 N 行开始显示文件的内容，以 /etc/passwd 为例，这里的 N 等于 30。

tail -n+30 /etc/passwd

tcpdump:x:72:72::/:/sbin/nologin
mysql:x:27:27:MariaDB Server:/var/lib/mysql:/sbin/nologin

（4）当文件增长时，动态查看文件追加的内容。假设文件 my.log 是滚动的服务日志，每到指定大小将被重命名，这里始终跟踪最新的日志文件。

tail --follow=name my.log

（5）显示多个文件的最后 3 行，并且默认会显示文件名。

tail -n3 /etc/passwd /etc/group

==> /etc/passwd <==
mqq:x:500:501::/usr/local/app:/bin/bash
dev_mqq:x:501:501::/usr/local/dev:/bin/bash
dev:x:502:501::/home/dev:/bin/bash

==> /etc/group <==
screen:x:84:
admin:x:500:
mqq:x:501:

●more 命令:
1.命令简介

more 命令是常用的文本文件阅读工具，类似于 cat，不过以一页一页的形式显示，更方便使用者逐页阅读。一般文件过大时使用 more 浏览，文件较小时使用 cat。

more 命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–(XX%)，可以使用交互式命令进行交互。最常用交互式的指令有：
（1）回车键向下滚动一行；
（2）空格键（Space）显示下一页；
（3）b 键（back）回显上一页；
（4）斜杠 / 后跟待搜索的正则表达式进行查找；
（5）h 或 ? 键显示帮助信息；
（6）q 或 Q 键退出。

注意，more 命令实际使用过程中会有很多不足之处，使用起来着实揪心，建议使用 less 命令。
（1）无法显示行数；
（2）搜索时无法高亮匹配的内容；
（3）搜索时从屏幕末行的下一行开始搜索，不搜索屏幕内的内容，使用不便；
（4）无法向后跳转至匹配项；
（5）无法快速跳转至首行与末行等。
2.命令格式

more [OPTIONS] FILE [...]

3.选项说明

-NUM
	指定每屏显示的行数为 NUM
-d
	在屏幕下方给用户显示提示信息"[Press space to continue, 'q' to quit.]"。当用户按下其非法按键时，显示"[Press 'h' for instructions.]"，而不是告警声音
-l
	抑制特殊字符换页符（Form Feed）造成的暂停
-f
	计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）
-p
	不以滚动的方式显示每一页，而是先清除屏幕后再显示内容
-c
	与 -p 相似，不同的是先显示内容再清除其他旧的内容
-s
	将多个空行压缩成一行显示
-u
	不显示文本底部的下划线
+/STRING
	从匹配搜索字符串 STRING 所在行的前两行开始显示
+NUM
	从文件第 NUM 行开始显示
--help
	显示帮助信息并退出
-V, --version
	显示版本信息并退出

4.交互式命令

more 的交互式命令基于 Vi，有些命令前面可能有一个十进制数，在下面的描述中称为 k。^X 表示 control-X

h, ?
	显示交互式命令的帮助摘要
SPACE
	显示下一页内容
z
	向下滚动 k 行，k 缺省值是当前的屏幕大小。可在键入命令前输入指定数值取代缺省值
RETURN
	回车键，向下滚动 k，默认为 1 行。可在键入命令前输入指定数值替代缺省值
d, ^D
	向下滚动 k 行，k 缺省值是当前的屏幕大小的一半，可在键入命令前输入指定数值替代缺省值
q, Q, INTERRUPT
	退出 more 命令
s
	显示下一页文本时跳过 k 行文本，缺省值是 1，可在键入命令前输入指定数值替代缺省值
f
	显示下一页文本时跳过 k 屏文本，缺省值是 1，可在键入命令前输入指定数值替代缺省值
b, ^B
	向后回显第 k 屏文本，缺省值是 1，可在键入命令前输入指定数值替代缺省值
'
	单引号，跳到上一次搜索开始的地方
=
	显示当前行号
/PATTERN
	从当前屏幕最后一行的下一行开始搜索符合正则表达式的第 k 个文本。k 默认为 1，可在键入命令前输入指定数值替代缺省值
n
	跳转到下 k 个匹配的文本，k 默认为 1，可在键入命令前输入指定数值替代缺省值
!command, :!command
	在子 Shell 中执行命令 command
v
	启动环境变量 VISUAL 定义的文本编译器，如果 VISUAL 未定义则使用 EDITOR，如果 EDITOR 未定义，则使用默认的 /usr/bin/vi，指向当前行
^L
	刷新屏幕
:n
	跳到后面第 k 个文件，缺省值是 1。可在键入命令前输入指定数值替代缺省值
:p
	跳到前面第 k 个文件，缺省值是 1。可在键入命令前输入指定数值替代缺省值
:f
	显示当前文件名和行号
.
	重复上次命令

5.环境变量

more 命令使用的相关环境变量有：

MORE
	设置 more 的选项
SHELL
	用户使用的 Shell，Linux 系统一般为 /bin/bash
TERM
	指定终端类型, more 用它来获取操作屏幕所需的终端特性
VISUAL
	用户首选的编辑器，在用户键入 v 命令时使用
EDITOR
	如果 VISUAL，则使用 EDITOR

6.常用示例

（1）查看文件内容, 按下回车逐行向下浏览。

more /etc/passwd

    1

（2）指定每屏显示行数，使用选项 -NUM，这里指定显示 5 行。

more -5 /etc/passwd

root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

（3）从文件第 NUM 行开始显示，使用选项 +NUM，这里从第 3 行开始显示。

more -5 +3 /etc/passwd

daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown

（4）从匹配搜索字符串 STRING 的文件位置开始显示。比如从 /etc/passwd 中搜索 adm 所在行的前两行开始显示。

more -5 +/adm /etc/passwd

...skipping
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync

（5）与管道组合使用。一个命令输出内容之后，如果内容过多，可以用 more 来分页显示，需要和管道 | 结合起来。

ps -ef | more -5

UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0  2018 ?        01:56:14 /usr/lib/systemd/systemd --system --deserialize 19
root         2     0  0  2018 ?        00:00:20 [kthreadd]
root         3     2  0  2018 ?        00:00:30 [ksoftirqd/0]
root         5     2  0  2018 ?        00:00:00 [kworker/0:0H]

●less 命令:
1.命令简介

less 命令是常用的文本文件阅读工具，类似于 more 但更强大。

less 主要用于浏览大文件，加载文件时不会读取整个文件，相比于 vim 或 nano 等文本编辑器，启动会更快。
2.命令格式

ps [OPTIONS] [FILE]...

3.选项说明

使用 less 命令选项需要注意以下几点：
（1）长命令选项可以简写，比如 --quit-at-eof 可以写作 --quit，但不能写作 --qui，因为与 --quiet 选项存在二义性；
（2）大写的长命令选项与与同名的小写的长命令选项作用不同，–QUIT-AT-EOF 不等于 --quit-at-eof；
（3）大写的长命令选项书写时可以只将首字母大写，其余小写，比如 --QUIT-AT-EOF 可以写作 --Quit-at-eof。

-?, --help
	显示帮助信息，等于交互式命令 h
-a, --search-skip-screen
	向前搜索默认从当前屏幕的首行开始，向后搜索默认从当前屏幕的末行开始。该选项使得向前搜索从屏幕末行的下一行开始，向后搜索从当前屏幕首行的前一行开始，即跳过屏幕内容。重复搜索命令 n 或 N 不受该选项影响
-A, --SEARCH-SKIP-SCREEN
	向前搜索跳过屏幕首行到目标行，向后搜索跳过屏幕末行到目标行。重复搜索命令 n 或 N 受该选项影响
-bN, --buffers=N
	设置缓冲区的大小为 N，单位 KB。如果 N 为 -1，表示缓冲区大小没有限制
-B, --auto-buffers
	默认情况下，如果数据是从管道读取，缓存大小按照所需数据大小自动分配，如果管道数据较大，会导致大量内存被占用。-B 选项将关闭缓存的自动分配，采用 64K 或者 -b 选项指定的大小。警告：使用 -B 可能会导致错误的显示，因为只有最近查看的管道数据部分保留在内存中；任何以前的数据都会丢失
-d, --dumb
	如果终端是哑终端（dumb terminal），则抑制错误消息的正常显示
-e, --quit-at-eof
	当 less 第二次到达文件末尾时，自动退出。默认情况需要 q 命令
-E, --QUIT-AT-EOF
	当 less 第已次到达文件末尾时，自动退出。默认情况需要 q 命令
-f, --force
	强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-F, --quit-if-one-screen
	如果文件全部内容可以在一个屏幕内显示，less 自动退出
-g, --hilite-search
	不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度
-G, --HILITE-SEARCH
	不加亮显示搜索到的关键词，当前显示的关键字也不加亮
--old-bot
	恢复到旧的屏幕底部。如果长行在到达终端边界时没有正确换行时可能需要该选项
-hN, --max-back-scroll=N
	指定向后滚动的行数为 N
-i, --ignore-case
	搜索时忽略大小写。如果正则表达式中包含大写字母则不忽略
-I, --IGNORE-CASE
	搜索时忽略大小写。如果正则表达式中包含大写字母也忽略
-jN, --jump-target=n
	指定屏幕中搜索的开始行。N 可以是正数（1 屏幕的第一行，2 屏幕的第二行），也可以是负数（-1 屏幕的倒数第一行，-2 屏幕的倒数第二行），还可以是分数（.5 屏幕的中间行，.3 屏幕的十分之三行）
-kFILE or --lesskey-file=FILE
	将指定的文件作为 lesskey 文件。-k 选项可以出现多次
-K, --quit-on-intr
	使 less 遇到 SIGINT 信号（Ctrl + C）时以状态码 2 立即退出
-L, --no-lessopen
	忽略环境变量 LESSOPEN
-m, --long-prompt
	显示类似 more 命令的百分比
-M, --LONG-PROMPT
	显示类似 more 命令的百分比，此外还显示屏幕内容的行范围
-n, --line-numbers
	不使用行号，以提高效率（缺省行为）。
-N, --LINE-NUMBERS
	显示行号
-oFILE, --log-file=FILE
	将输入的数据拷贝至指定的文件。一般输入的文件是个管道时使用该选项。如果指定的文件已经存在，则覆盖写入前请求二次确认
-OFILE, --LOG-FILE=FILE
	类似于 -o 选项，不同的是覆盖写入已经存在的文件前不请求二次确认
-pPATTERN or --pattern=PATTERN
	搜索符合指定模式的内容，等同于选项 +/PATTERN
-PPROMPT, --prompt=PROMPT
	更改提示的内容为指定的内容。这个选项通常放在 LESS 环境变量中，而不是出现在命令行选项。该选项必须是 LESS 变量的最后一个选项，或者以美元符号终止。比如 -Ps 后面跟一个字符串会将默认（简短）提示符更改为该字符串。-Pm 改变选项 -m 的提示。-PM 更改 -M 的提示。-Ph 改变帮助内容的提示。-P= 更改由 = 命令打印的消息。-Pw 更改在等待数据时打印的消息（在 F 命令中）
-q, --quiet, --silent
	导致适度的“静音”操作。比如如果试图滚动到文件末尾之后或文件开头之前，则不响终端铃
-Q, --QUIET, --SILENT
	完全静音，终端铃永远不会响
-r, --raw-control-chars
	显示原始的控制字符。比如 ^@ 表示空字符，^A 表示字符SOH（start of headline）。警告：使用该选项后不能保证终端能够正常的显示文件内容，因为终端依赖控制字符来格式化文件内容
-R, --RAW-CONTROL-CHARS
	与 -r 类似，但只有 ANSI颜色转义序列以原始形式输出。与 -r 不同的是，屏幕外观在大多数情况下都得到了正确的维护
-s, --squeeze-blank-lines
	显示连续空行为一行
-S, --chop-long-lines
	显示长行时进行截断（chop）而不是换行（wrap）
-tTAG, --tag=TAG
	指明标签
-TTAGSFILE or --tag-file=TAGSFILE
	指明标签文件
-u, --underline-special
	退格与回车作为可打印字符对待
-U, --UNDERLINE-SPECIAL
	退格与回车作为控制字符对待
-V, --version
	显示版本信息并退出
-w, --hilite-unread
	临时高亮显示下一页的第一个新行
-W, --HILITE-UNREAD
	类似于 -w，但在任何大于一行的向前移动命令之后，临时高亮显示第一个新行
-xN,... or --tabs=N,...
	设置 tab 的位置
-X, --no-init
	禁止向终端发送 termcap 初始化和去初始化字符串。如果删除初始化字符串做了一些不必要的事情，比如清除屏幕，这有时是可取的
-yN, --max-forw-scroll=N
	指定向前滚动的最大行数
-[z]N, --window=N
	指定滚动一屏所能的滚动的行数。如果 N 是负数，表示全屏能够显示的行数减去 N
-"CC, --quotes=CC
	更改文件名引用字符。如果您试图命名一个包含空格和引号字符的文件，这可能是必要的
-~, --tilde
	文件结束后的行通常显示为单个波浪线(~)。此选项使文件结束后的行显示为空行
-#, --shift
	指定要在 RIGHTARROW 和 LEFTARROW 命令中水平滚动的默认位置数。如果指定的数字为零，则将默认位置数设置为屏幕宽度的一半。或者，可以将数字指定为屏幕宽度的分数，以小数点开始:.5是屏幕宽度的一半，.3是屏幕宽度的三分之三，以此类推。如果将数字指定为分数，则在调整终端窗口的大小时将重新计算滚动条位置的实际数量，从而使实际滚动条保持在屏幕宽度的指定分数
--follow-name
	通常，如果在执行 F 命令时重命名输入文件，less 将继续显示原始文件的内容，尽管它的名称发生了更改。如果指定了——following -name，那么在F命令期间less将定期尝试按名称重新打开文件。如果重新打开成功，并且文件与原始文件不同(这意味着创建的新文件与原始文件(现在重命名)同名)，less将显示新文件的内容
--no-keypad
	禁止向终端发送键盘初始化和反初始化字符串。如果小键盘字符串使数字小键盘的行为不受欢迎，这有时是有用的
--use-backslash
	这个选项改变了后面选项的解释。在 --use-backslash 选项之后，删除选项字符串中的任何反斜杠，并按字面意思处理后面的字符。这允许在选项字符串中包含美元符号
--
	该选项标识命令行选项的结束，之后的参数被解释为文件名，当在文件名的首字符是 - 或这 + 时需要使用该选项
+
	如果命令行选项以 + 开头，则将该选项的其余部分视为初始命令。比如 +G 表示跳转至文件末尾，+/XYZ 表示跳转至匹配 XYZ 的第一行，+NUM 表示从文件第 NUM 行开始显示；如果选项以 ++ 开头，则初始命令将应用于所查看的每个文件，而不仅仅是第一个文件

实际上，less 的命令行选项很少使用，浏览文件时常用的是交互式命令。
4.交互式命令

以下描述中，^X 表示 control-X，ESC 表示退出键，比如 ESC-v 表示两个字符序列，先是 ESC，然后是 v。如果忘记命令，可以键入 h 或 H 查看命令的帮助信息。

SPACE, ^V, f, ^F
	向前滚动 N 行，N 默认等于窗口大小。可以使用 -z 选项指定 N 的大小，生效多次；也可以在键入前输入数值 N，生效一次
z
	类似于 SPACE。可以使用 -z 选项指定 N 的大小，生效多次；也可以在键入前输入数值 N，生效多次
ESC-SPACE
	先键入 ESC，再键入 SPACE，表示即使到达文件尾部仍然向前滚动一页
ENTER, RETURN, ^N, e, ^E, j, ^J
	向前滚动 N 行，默认为 1。键入前可先输入数值 N，只对当前动作有效
d, ^D
	向前滚动 N 行，默认为屏幕一半。键入前可先输入数值 N，对当前与后续的 d 或 u 命令均有效，生效多次
b, ^B, ESC-v
	向后滚动 N 行，默认为屏幕大小，可以使用 -z 选项指定 N 的大小，生效多次；也可以在键入前输入数值 N，生效一次
w
	类似于 ESC-v。键入前输入数值 N，生效多次
y, ^Y, ^P, k, ^K
	向后滚动 N 行，默认为 1。键入前可先输入数值 N，只对当前动作有效
u, ^U
	向后滚动 N 行，默认为屏幕一半。键入前可先输入数值 N，对当前与后续的 d 或 u 命令均有效，生效多次
ESC-), RIGHTARROW
	向右滚动 N 个字符，N 默认等于屏幕宽度的一半。键入前可先输入数值 N，对当前与后续的 RIGHTARROW 命令均有效，生效多次
ESC-(, LEFTARROW
	向右滚动 N 个字符，N 默认等于屏幕宽度的一半。键入前可先输入数值 N，对当前与后续的 LEFTARROW 命令均有效，生效多次
r, ^R, ^L
	刷新屏幕
R
	刷新屏幕，放弃缓存内容。在文件被修改时有用
F
	向前滚动，即使到达了文章尾部。当文件不断增长时该命令可以查看新增的内容，类似于 tail -f 命令
ESC-F
	与 F 类似，但是一旦找到与最后一个搜索模式匹配的行，就会按下终端铃并停止向前滚动
g, <, ESC-<
	跳转到第 N 行，默认为文件首行。键入前可先输入数值 N，生效一次
G, >, ESC->
	跳转到第 N 行，默认为文件末行。键入前可先输入数值 N，生效一次
p, %
	跳转到文件的位置 N% 处。N 应该在 0 到 100 之间，可能包含一个小数点
P
	跳转到文件中字节偏移为 N 所在的行
{
	如果屏幕的顶行出现左花括号，{ 命令将转到匹配的右花括号。匹配的右花括号将位于屏幕的末行。如果在顶行上有多个左花括号，则可以使用数字 N 来指定该行上的第 N 个括号
}
	如果屏幕的末行出现右花括号，} 命令将转到匹配的左花括号。匹配的左花括号将位于屏幕的顶部。如果在末行上有多个右花括号，则可以使用数字 N 来指定该行上的第 N 个括号
(
	类似 { 命令，但它适用于圆括号而不是花括号
)
	类似 } 命令，但它适用于圆括号而不是花括号
[
	类似 { 命令，但它适用于方括号而不是花括号
]
	类似 } 命令，但它适用于方括号而不是花括号
ESC-^F
	后跟两个字符，作用类似于 {，但分别使用这两个字符作为开括号和闭括号。例如，ESC-^F < > 可用于向前移动到与顶行的 < 匹配的 >
ESC-^B
	后跟两个字符，作用类似于 }，但分别使用这两个字符作为开括号和闭括号。例如，ESC-^B < > 可用于向后移动到与末行的 < 匹配的 <
m
	后跟任意小写字母，用该字母标记当前位置
'
	(单引号)。后跟任何小写字母，返回到先前用该字母标记的位置。后跟另一个单引号，返回执行最后一个移动命令的位置。后面跟着 ^ 或 $，分别跳转到文件的开头和结尾。在检查新文件时，将保留标记，因此 ' 命令可用于在输入文件之间切换
^X^X
	等于 ' 命令
/PATTERN
	向前搜索包含指定模式的第 N 行，N 默认为 1。从屏幕首行开始搜索。在 PATTERN 前输入指定特殊字符可以控制搜索的行为。主要有：
	^N 或 ! 搜索不包含 PATTERN 的行
	^E 或 * 搜索多个文件。如果当前文件没有匹配的行，搜索 less 命令行指定的下一个文件
	^F 或 @ 命令行列表中第一个文件的第一行开始搜索，不管当前屏幕上显示的是什么，也不管 -a 或 -j 选项的设置是什么
	^K 突出显示与当前屏幕上的模式匹配的任何文本，但不要移动到第一个匹配项（保持当前位置）
	^R 不要解释正则表达式元字符;也就是说，做一个简单的文本比较
?PATTERN
	向后搜索包含模式的第 N 行，N 默认为 1。从屏幕首行的前一行开始搜索。在 PATTERN 前输入指定特殊字符可以控制搜索的行为。主要有：
	^N 或 ! 搜索不包含 PATTERN 的行
	^E 或 * 搜索多个文件。如果搜索到达当前文件的开头，但没有找到匹配项，那么搜索将继续在命令行列表中的前一个文件中进行
	^F 或 @ 从命令行列表中最后一个文件的最后一行开始搜索，不管当前屏幕上显示的是什么，也不管 -a 或 -j 选项的设置是什么
	^K  等于前向搜索
	^R  等于前向搜索
ESC-/PATTERN
	等于 /*
ESC-?PATTERN
	等于 ?*
n
	跳转到下一个匹配项
N
	跳转到前一个匹配项
&pattern
	只显示符合模式的行，与模式不匹配的行将不显示
:e [filename]
	打开另一个文件
^X^V, E
	等同于 :e
:n
	检查下 N 个文件（从命令行中给定的文件列表）；N 默认为 1，可以在键入命令前输入 N
:p
	检查前 N 个文件（从命令行中给定的文件列表）；N 默认为 1，可以在键入命令前输入 N
:x
	检查第 N 个文件（从命令行中给定的文件列表）；N 默认为 1，可以在键入命令前输入 N
:d
	从文件列表中删除当前文件
t
	跳到下一个标签
T
	跳到上一个标签
=, ^G, :f
	打印有关正在查看的文件的一些信息，包括它的名称、行号和显示底线的字节偏移量。如果可能的话，打印文件的长度、文件中的行数和最后显示行至首行占文件的百分比
-
	后跟命令行选项字母，这将更改该选项的设置并打印一条描述新设置的消息
--
	类似于命令 -，但是后跟长选项的名称
-+
	后面跟着一个命令行选项字母，这将把选项重置为默认设置，并打印一条描述新设置的消息
--+
	类似于命令 -+，但是后跟长选项的名称
-!
	后面跟着一个命令行选项字母，这将把选项重置为其默认设置的“反面”，并打印一条描述新设置的消息。这不适用于数值或字符串值选项
--!
	类似于命令 -!，但是后跟长选项的名称
_
	下划线，后跟命令行选项字母后，将打印一条描述该选项当前设置的消息。选项的设置没有改变
__
	两个下划线，类似于命令 _，但是后跟长选项的名称
+CMD
	使指定的命令 CMD 在每次检查新文件时执行
V
	显示 less 的版本号
q, Q, :q, :Q, ZZ
	退出
v
	启动编辑器编辑当前文件，默认为 vim。可通过环境变量 VISUAL 或 EDITOR 指定
! shell-command
	执行 Shell 命令
| <m> shell-command
	将当前屏幕的第一行到 <m> 指定的位置作为管道的内容传送给 Shell 命令。m 可以是 ^（文件开始位置）、$（文件结束位置）、点号 . 或换行（当前屏幕的内容）
s FILENAME
	将输入保存到文件中。这只在输入是管道而不是普通文件时才有效

如此繁多的交互式命令，常用的并不多，符合二八定律，记住下面这些命令足以应对日常浏览需求。

ENTER 向前滚动一行
y 向后滚动一行

d 向前滚动半屏
u 向后滚动半屏

f 向前滚动一屏
b 向后滚动一屏

g 跳转到文件首行
G 跳转到文件末行

/PATTERN 向前搜索指定内容
n 跳转到下一个匹配项
N 跳转到前一个匹配项

h 显示帮助信息
q 退出

注意，如果环境变量 LESSSECURE 设置为 1，表示 less 运行在安全模式下，某些特性无法使用：

! 执行 Shell 命令
| 管道命令
:e 打开新文件命令
v 编辑命令
s 保存命令
-k 使用 lesskey 文件
文件名中包含星号
文件名自动补全

5.常用示例

（1）查看文件，同时显示行号。

less -N /etc/passwd

1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
...

（2）执行命令，然后分页显示。

ps -ef | less -N

（3）浏览多个文件。

less a.txt b.txt

在浏览 a.txt 时，输入 :n 后，切换到 b.txt，输入 :p 后，切换回 a.txt。也可以使用 :e 命令打开另一个文件。

（4）从首行开始向前搜索。

g : 跳转到首行
/ : 使用模式进行搜索，并跳转到下一个匹配文本行
n : 向前跳转到下一个匹配文本行
N : 向后跳转到下一个匹配文本行

# 或者。无需事先跳转到文件首行
/@PATTERN：先输入 /，再输入 @，后输入搜索模式，最后回车

（5）从末行开始向后搜索。

G : 跳转到末行
? : 使用一个模式进行搜索，并跳转到下一个匹配文本行
n : 向后跳转到下一个匹配文本行
N : 向前跳转到下一个匹配文本行

# 或者。无需事先跳转到文件末行
?@PATTERN：先输入 ?，再输入 @，后输入搜索模式，最后回车

（6）打开文件时跳转到指定行 NUM。

less -N +NUM FILE

（7）查看 less 帮助信息。

less -?

●whereis 命令：
1.命令简介

whereis 命令用于查找命令的二进制程序、源代码文件和 man 手册等相关文件的路径，如果仅显示命令的绝对路径，可使用 which 命令，其他普通文件的查找需使用 locate 或 find 命令。

whereis 默认的搜索路径是从硬编码路径中查找文件，硬编码路径是用 glob patterns 定义的，以及环境变量 PATH 和 MANPATH 定义的路径。要知道使用了哪些路径，最简单的方法是使用 -l 选项来查看。
2.命令格式

whereis [OPTIONS] [-BMS DIRECTORY... -f] NAME...

whereis 会将提供的文件名前面的路径与后面的扩展名去掉，并找出与之相匹配的特殊文件。
3.选项说明

-b
	只搜索二进制文件
-m
	只搜索 man 手册
-s
	只搜索源代码
-u
	只展示有相关特殊文件（二进制程序、源代码文件、man 手册）的命令名称
-B LIST
	指定二进制文件查找目录，使用空格分隔
-M LIST
	指定 man 手册查找目录，使用空格分隔
-S LIST
	指定源代码文件查找目录，使用空格分隔
-f
	在使用 -S 、–M、-B 选项时，必须使用这个选项，用于表示目录的结束，命令名的开始
-l
	输出正在使用的有效查找路径

4.常用示例

（1）查看命令 which 的二进制文件与帮助手册的路径。

whereis which
which: /usr/bin/which /usr/share/man/man1/which.1.gz

（2）只搜索二进制文件 which 的路径。

whereis -b which
which: /usr/bin/which

（3）只搜索命令 which 帮助手册的路径。

whereis -m which

（4）搜索当前目录下所有文件时，只展示具有相关特殊文件的文件名。

# 当前目录下的文件
ll
-rwxr-xr-x 1 root root 21915 May 25 10:03 a.out
-rw-r--r-- 1 root root   351 May 25 10:03 main.cpp
-rw-r--r-- 1 root root   965 Nov  7 18:20 moretest.txt
-rw--w--w- 1 root root   316 Nov  5 15:33 passwd.md5

# 使用选项 -u 的结果
whereis -u *
passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz

# 不使用选项 -u 的结果
whereis *
a:main:moretest:passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz

（5）指定查找命令 passwd 的目录为 /usr/bin。

whereis -b -B /usr/bin -f passwd
passwd: /usr/bin/passwd

（6）查看 whereis 默认的搜索路径。

whereis -l
bin: /usr/bin
bin: /usr/sbin
bin: /usr/lib
bin: /usr/lib64
...

●which 命令：
1.命令简介

which 命令用于查看给定命令的绝对路径，从环境变量 PATH 指定的目录进行搜索。
2.命令格式

which [options] [--] COMMAND [...]

which 可以有多个 COMMAND ，对于每个参数，它都将输出可执行程序的完整路径
3.选项说明

--all, -a
	打印出所有在 PATH 中匹配的可执行程序，而不仅仅是第一个匹配的可执行程序
--read-alias, -i
	从 stdin 中读取别名列表
--skip-alias
	忽略选项 --read-alias
--read-functions
	从 stdin 读取 Shell 函数的定义，并打印匹配的函数
--skip-functions
	忽略选项 --read-functions
--skip-dot
	跳过环境变量 PATH 中以点开头的目录
--skip-tilde
	跳过环境变量 PATH 中以波浪号开头的目录和主目录中的可执行文件
--show-dot
	如果环境变量 PATH 中一个目录以一个点开始，并且在该目录下找到了一个匹配的可执行文件，那么打印 ./COMMAND 而不是完整的路径
--show-tilde
	为 HOME 目录输出波浪符。如果是 root 用户则忽略该选项
--tty-only
	如果不在 tty 上，停止处理右边的选项
--version, -v, -V
	显示版本信息并退出
--help
	显示帮助信息

4.常用示例

（1）查找命令所在路径。

which passwd

/usr/bin/passwd

（2）一般情况下，which 是一个别称，可以查看 which 的详细定义。

which which

alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
	/usr/bin/alias
	/usr/bin/which

也可以跳过别名，直接查看命令 which 的所在路径。

which --skip-alias which

/usr/bin/which

（3）打印帮助信息。

which --help

●locate 命令：
1.命令简介

locate 命令用于查看文件。

如果没有指定 ——regex，匹配模式可以包含通配符（globbing characters）。如果模式不包含通配符，则模式等价于 *PATTERN*。

作用类似于 find 命令，但是比 find 要快，因为 locate 不像 find 那样全磁盘搜索，而是从由 updatedb 命令维护的数据库（一般为 /var/lib/mlocate/mlocate.db）中进行查找。默认情况下，locate 不会检查从数据库中找到的文件是否仍然存在，也无法找到在数据库最近更新之后创建的文件，因为数据库的更新有时延。为了避免这种情况，可以在使用 locate 之前，先使用 updatedb 命令手动更新数据库。
2.命令格式

locate [OPTION]... PATTERN...

3.选项说明

-A, --all
	只显示匹配所有模式的条目
-b, --basename
	只匹配文件的基本名。作用与选项 --wholename 相反
-c, --count
	只输出符合匹配模式的文件的数量
-d, --database DBPATH
	将默认数据库替换为 DBPATH。该选项可出现多次
-e, --existing
	只打印当前存在的文件
-L, --follow
	当检查文件是否存在时（如果选项 --existing 指定时），检查符号链接的目标文件（默认，相反的选项是 --nofollow）
-h, --help
	显示帮助信息并退出
-i, --ignore-case
	比较时忽略大小写
-l, --limit, -n LIMIT
	限制成功匹配的文件数为 LIMIT
-P, --nofollow, -H
	当检查文件是否存在时（如果选项 --existing 指定时），不检查符号链接的目标文件。作用与 --follow 相反
-0, --null
	在输出时使用 ASCII NUL 字符分隔条目，而不是将每个条目写在单独的行上。此选项是为了与 GNU xargs（1）的 --null 选项配合使用而设计的
-S, --statistics
	不搜索文件，而是显示每个数据库的统计信息
-q, --quiet
	不报告关于读取和处理数据库时遇到的错误的消息
-r, --regexp REGEXP
	使用正则表达式 REGEXP 进行搜索。该选项可出现多次
--regex
	将所有模式解释为扩展的正则表达式
-V, --version
	输出 locate 的版本和许可信息并退出
-w, --wholename
	仅将整个路径名与指定的模式匹配（默认）。如果只匹配文件基本名，可使用选项 --basename

4.常用示例

（1）查找文件名为 NAME 的文件。

locate -b '\NAME'

反斜杠 \ 阻止了隐式地将 NAME 转为 NAME。

（2）查找文件名包含某个字符串的相关文件。

locate -b
/usr/sbin/ifconfig
/usr/share/man/de/man8/ifconfig.8.gz
/usr/share/man/fr/man8/ifconfig.8.gz
/usr/share/man/man8/ifconfig.8.gz
/usr/share/man/man8/ifconfig_selinux.8.gz
/usr/share/man/pt/man8/ifconfig.8.gz
/usr/share/selinux/devel/html/ifconfig.html
/usr/share/zsh/5.0.2/functions/_ifconfig

（3）查找配置文件 mlocate.db。

locate mlocate.db
/usr/share/man/man5/mlocate.db.5.gz
/var/lib/mlocate/mlocate.db

（4）显示数据库的统计信息。

locate -S
Database /var/lib/mlocate/mlocate.db:
	21,626 directories
	230,452 files
	15,475,136 bytes in file names
	5,711,659 bytes used to store database

（5）搜索基本正则表达式 REGEXP 来代替模式。查找名称以 mlocate 开头，以 db 结尾的文件。

locate -b -r ^mlocate.*db$
/var/lib/mlocate/mlocate.db

（6）查找最近变动的文件。使用 locate 命令查不到最近变动过的文件。为了避免这种情况，可以在使用 locate 之前，先使用 updatedb 命令，手动更新数据库。

# 无法找到新建的文件
touch new_file
locate new_file

# 手动更新数据库后可以查到新建的文件
updatedb
locate new_file
/root/new_file

●updatedb 命令：
1.命令简介

updatedb 命令用于更新 locate 命令使用的数据库。本文介绍的是 GNU 版本的 updatedb，其它版本的选项会有所不同。

updatedb 作用的数据库名称由配置文件（一般为 /etc/updatedb.conf）或命令行参数确定（一般为 /var/lib/mlocate/mlocate.db），由系统每日执行 updatedb 更新一次，更新脚本一般为 /etc/cron.daily/mlocate，在配置文件 /etc/anacrontab 中被调用，由 anacron 每天运行一次。

anacron 是如何被启动的呢？守护进程 cron 会运行 /etc/cron.d/0hourly，在 /etc/cron.d/0hourly 文件里，有一条 cron 任务是这样的：

01 * * * * root run-parts /etc/cron.hourly

这条 cron 任务会运行 /etc/cron.hourly 目录下的所有脚本，其中有一个名为 0anacron 的脚本，该脚本则会在合适的时间运行 anacron，anacron 则会检查 /etc/anacrontab，在合适的时间分别运行 /etc/cron.daily，/etc/cron.weekly，/etc/cron.monthly 目录下的脚本。
2.命令格式

updatedb [OPTIONS]

3.选项说明

--localpaths='PATH1 PATH2...'
	将本地目录而非网络目录放入数据库。默认为 /
--netpaths='PATH1 PATH2...'
	将网络（NFS、AFS、RFS 等）目录放入数据库。环境变量 NETPATHS 也设置这个值。默认是没有的
--prunepaths='PATH1 PATH2...'
	指定不加入数据库的目录。可以由环境变量 PRUNEPATHS 指定，默认为 /tmp /usr/tmp /var/tmp /afs
--prunefs='PATH...'
	指定不能放到数据库中的文件系统。环境变量 PRUNEFS 也设置这个值。默认是 nfs NFS proc
--output=DBFILE
	指定输出的数据库
--localuser=USER
	指定搜索非网络目录的用户，默认为当前用户。可以使用环境变量 LOCALUSER 来设置
--netuser=USER
	指定搜索网络用户的用户，默认为 daemon。 可以使用环境变量 NETUSER 来设置
--dbformat=F
	指定数据库的格式，默认为 LOCATE02。另外，还支持 slocate 格式。当使用slocate格式时，生成的数据库被标记为安全级别 1。如果你想建一个系统范围的 slocate 数据库，以 root 运行 updatedb
--version
	显示版本信息并退出
--help
	显示帮助信息并退出

4.常用示例

（1）更新默认数据库。

updatedb

（2）指定目录生成数据库。

updatedb --localpaths='/root' --output=homelocate.db

注意，第一次运行 updatedb 时，由于新创建目录下所有文件的信息的数据会比较慢。第二次使用 updatedb 时，仅执行数据库的更新操作，会比较快。

●env 命令：
1.命令简介

env 命令用于显示系统中已存在的环境变量，以及在定义的环境中执行指令。若没有设置任何选项和参数时，则直接显示当前系统的环境变量。本文介绍的是 GNU 版本的 env，其它版本（如 POSIX 版）的实现可能会有所不同。
2.命令格式

env [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]

3.选项说明

-, -i, --ignore-environment
	忽略环境变量
-0, --null
	输出环境变量时以空字符（NUL）替代换行符
-u, --unset=NAME
	从当前环境中删除指定的变量
--help
    显示帮助并退出 
--version
    输出版本信息并退出 

4.常用示例

（1）显示所有的环境变量。

env
XDG_SESSION_ID=2216652
HOSTNAME=TENCENT64.site
TERM=xterm
SHELL=/bin/bash
...

（2）临时更改环境变量，使得程序在新的环境变量下运行。例如，使用 C 程序 a.out 用于获取环境变量 PAHT。实现如下：

// main.c

#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    char *pathvar;
    pathvar = getenv("PATH");
    printf("PATH=%s\n",pathvar);
    return 0;
}

编译生成 a.out，并执行查看环境变量 PATH。

gcc main.c
a.out
PATH=/usr/lib64/ccache:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

临时改变环境变量 PATH 后执行 a.out。

env PATH=test ./a.out
PATH=test

（3）查看 env 版本。

env --version
env (GNU coreutils) 8.22
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Richard Mlynarik and David MacKenzie.

●test 命令：
1.命令简介

test 用于检查某个条件是否成立，它可以进行数值、字符串和文件三个方面的测试。本文介绍的是 GNU 版本的 test，其它版本（如 POSIX 版）的实现可能会有所不同。
2.命令格式

test
test EXPRESSION

省略表达式 EXPRESSION 默认为 false。[] 实际上是 Bash 中 test 命令的简写，即所有的 test EXPRESSION 等于 [ EXPRESSION ]。
3.选项说明

--help
	显示帮助信息并退出
--version
	显示版本信息并退出

# 1.逻辑运算
! EXPRESSION
	逻辑非，EXPRESSION 为 false 返回 true
EXPRESSION1 -a EXPRESSION2
	逻辑与，两个表达式均为 true 返回 true
EXPRESSION1 -o EXPRESSION2
	逻辑或，两个表达式只要有一个为 true 返回 true

# 2.数值间的比较
INTEGER1 -eq INTEGER2
	两整数是否相等
INTEGER1 -ne INTEGER2
	整数 INTEGER1 是否不等于 INTEGER2
INTEGER1 -gt INTEGER2
	整数 INTEGER1 是否大于 INTEGER2
INTEGER1 -ge INTEGER2
	整数 INTEGER1 是否大于等于 INTEGER2
INTEGER1 -lt INTEGER2
	整数 INTEGER1 是否小于 INTEGER2
INTEGER1 -le INTEGER2
	整数 INTEGER1 是否小于等于 INTEGER2

# 3.字符串的比较
-n STRING
	字符串不为空返回 true
-z STRING
	字符串为空返回 true
STRING1 = STRING2
	字符串相等返回 true
STRING1 != STRING2
	字符串不相等返回 true

# 4.文件的比较与类型判断
FILE1 -ef FILE2
	两个文件是否为同一个文件。主要看文件设备号与 inode 是否一致
FILE1 -nt FILE2
	文件 FILE1 是否比 FILE2 新（修改时间新）
FILE1 -ot FILE2
	文件 FILE1 是否比 FILE2 旧（修改时间旧）
-b FILE
	文件存在且是块（block）设备文件
-c FILE
	文件存在且是字符（character）设备文件
-d FILE
	文件存在且是目录（directory）
-e FILE
	文件存在（exist）返回 true
-f FILE
	文件存在且是普通文件
-g FILE
	文件存在且设置了 SGID
-G FILE
	文件存在且属于有效组ID
-h FILE
	文件存在且是软链接。同 -L
-k FILE
	文件存在且设置了粘着位（Sticky Bit）
-L FILE
	文件存在且是软链接。同 -h
-O FILE
	文件存在且属于有效用户ID
-p FILE
	文件存在且属于命名管道
-r FILE
	文件存在且可读
-s FILE
	文件存在且内容不为空
-S FILE
	文件存在且是一个套接字（socket）
-t FD
	文件描述符是在一个终端打开的
-u FILE
	文件存在且设置了 SUID 位
-w FILE
	文件存在且且可写
-x FILE
	文件存在且可执行

注意：
（1）test 拥有选项 --help 与 --version，但无法使用。test 将这两个选项当做非空的普通字符串进行处理，并返回 true；
（2）文件的比较与类型判断，除了 -h 与 -L，其它所有的选项都对软链接进行解引用。
4.常用示例

（1）判断数值是否相等。

test 0 -eq 0; echo $?
0

test 退出状态码等于 0 表示条件成立。

（2）判断文件是否存在。

test -e /etc/passwd; echo $?
0

test 退出状态码等于 0 表示文件存在。

（3）判断文件是否是同一个文件。

test /etc/passwd -ef /etc/shadow; echo $?
1

test 退出状态码等于 1 表示不是同一个文件。

●ln 命令:
1.命令简介

ln 命令用来为文件创建链接，分为硬链接（hard link）和软链接（符号链接，symbolic link）两种，默认创建硬链接，如果要创建软链接须使用 -s 选项。本文介绍的是 GNU 版本的实现，其它版本（如 POSIX 版）实现会所有不同。

注意：
（1）硬链接不是一个独立的文件，只是一个文件名。一个文件可以有多个文件名，只有将最后一个文件名从磁盘上删除，才能把这个文件删掉；
（2）软链接可以跨文件系统，但硬链接不能跨文件系统，因为硬链接只是文件的别名，而非独立的文件；
（3）不能给目录建立硬链接，因为硬链接连接到目录可会导致目录的 inode 与实体 block 形成环状。此时，如果删除目录，会导致目录实体 block 无法被系统访问，产生孤立的目录（从根目录无法再访问）；
（4）创建硬链接时，每个目标必须存在。创建软链接时，目标文件可以不存在；
（5）软链接是一个包含了路径信息的独立文件，类似于 Windows 的快捷方式，它的许多属性依赖于原文件，所以给软链接文件设置权限是没有意义的。
2.命令格式

ln [OPTION]... [-T] TARGET LINK_NAME   (1st form)
ln [OPTION]... TARGET                  (2nd form)
ln [OPTION]... TARGET... DIRECTORY     (3rd form)
ln [OPTION]... -t DIRECTORY TARGET...  (4th form)

第一种格式，为指定的目标文件建立指定名称的链接，-T 选项可省略，LINK_NAME 为目录时可省略链接名称，此时链接与目标文件同名。该格式最为常用；
第二种格式，为指定的目标文件建立在当前目录建立同名的链接；
第三和第四格式，分别为每一个目标文件在指定的目录下建立同名的链接。
3.选项说明

长选项的强制参数对于短选项也是强制的。

--backup[=CONTROL]
	备份每一个存在的目标文件
-b
	类似于 --backup，但不接受参数
-d, -F, --directory
	允许超级用户尝试为目录建立硬链接（注意：由于系统限制，即使超级用户也可能失败）
-f, ——force
	强行建立文件或目录的链接，与链接同名的文件或目录将被覆盖
-i, ——interactive
	覆盖既有文件之前先询问用户
-L, --logical
	建立硬链接时，当目标文件是软链接时，进行解引用，指向软链接的目标文件
-n, --no-dereference
	把软链接视为一般文件，不进行解引用
-P, --physical
	建立硬链接时，直接指向软链接本身，而不是指向软链接的目标文件（默认）
-r, --relative
	创建相对于链接位置的符号链接
-s, --symbolic
	建立软连接，而非硬连接
-S, --suffix=SUFFIX
	修改备份文件后缀。用 -b 参数备份目标文件后，备份文件后缀默认为 ~
-t, --target-directory=DIRECTORY
	指定链接文件存放于哪个目录
-T, --no-target-directory
	将 LINK_NAME 视为链接文件而非存放链接文件的目录
-v, ——verbose
	显示指令执行过程
--help
	显示帮助并退出
--version
	显示版本并退出

选项 --backup 的参数 CONTROL 控制文件备份后的版本生成方式，可取值如下：

none, nil
	不进行备份
numbered, t
	使用数字后缀进行滚动。备份文件名后缀依序递增 ~1~、
existing, nil
	如果有使用数字后缀则使用数字，否则使用简单的备份方式，即只备份一次
simple, never
	只使用简单的备份方式

使用选项 -s 生成软链接时，将忽略选项 -L、-P，建立硬链接，默认使用 -P 选项，将硬链接指向软链接本身，相当于给软链接起了个别名。
4.常用示例

（1）给文件 /etc/passwd 建立软链接。

ln -s /etc/passwd passwdSoftLink

ll passwdSoftLink
lrwxrwxrwx  1 root root   11 Nov 13 22:21 passwdSoftLink -> /etc/passwd

（2）给文件 /etc/passwd 多次建立软链接，软链接的名称相同，采用数字表示备份文件的版本号。多次备份，版本号将依序递增。

ln -s --backup=numbered /etc/passwd passwdSoftLink

ll passwdSoftLink*
lrwxrwxrwx  1 root root   11 Nov 14 10:36 passwdSoftLink -> /etc/passwd
lrwxrwxrwx  1 root root   11 Nov 14 10:36 passwdSoftLink.~1~ -> /etc/passwd

（3）给不存在的文件建立软链接。

ln -s nofile nofileSoftLink

使用 ll 命令查看软链接时，软链接名为红色，且不存在的目标文件名以红底白字在不停地闪烁。在这里插入图片描述
向软链接 nofileSoftLink 写入内容后保存，将会生成文件 nofile。

（4）给 /etc/passwd 建立硬链接。

ln /etc/passwd passwdHardLink

ll -i /etc/passwd passwdHardLink
787795 -rw-r--r-- 2 root root 1552 Jan  4  2019 /etc/passwd
787795 -rw-r--r-- 2 root root 1552 Jan  4  2019 passwdHardLink

使用 ll 命令查看两个文件时，第一列 inode 号相同，且第三列硬链接数为 2，表示有两个文件名指向文件的数据实体。

（5）给 /etc/passwd 建立同名的软链接且软链接放在当前目录。即使用第三和第四种命令格式为文件建立链接。

ln -s /etc/passwd .

# 或
ln -s -t . /etc/passwd

# 查看
ll passwd
lrwxrwxrwx  1 root root   11 Nov 14 10:43 passwd -> /etc/passwd

注意，书写目标文件时，路径要相对于目标目录，或者使用绝对路径，不然软链接无法指向目标文件。

（6）创建的链接文件有同名的文件时，强制覆盖，不进行备份。

ln -sf /etc/passwd passwdSoftLink

（7）修改软链接指向新的目标文件。将软链接 passwdSoftLink 指向 /usr/bin/passwd，重新建立软链接，强制覆盖原有的软链接 passwdSoftLink 即可。

ln -sf /usr/bin/passwd passwdSoftLink

ll passwdSoftLink
lrwxrwxrwx 1 root root 15 Nov 14 10:52 passwdSoftLink -> /usr/bin/passwd

●info 命令:
1.命令简介

info 命令用于阅读 Linux 下 info 格式的帮助文档。

就内容来说，info 页面比 man page 编写得要更好、更容易理解，但 man page 阅读起来更加方便。一个 man 手册只有一级标题，而 info 页面将内容组织成多级标题，每个标题称为节点，每个标题下可能存在子标题（称为子节点）。要理解 info 命令，不仅要学习如何在单个节点中浏览，还要学习如何在节点和子节点之间切换。

就便捷而言，建议使用 man 而不是 info。
2.命令格式

info [OPTION]... [MENU-ITEM...]

指定需要获得帮助的主题 MENU-ITEM，可以是命令、函数以及配置文件。
3.选项说明

-k, --apropos=STRING
	在所有手册的所有索引中查找 STRING
-d, --directory=DIR
	添加包含 info 格式帮助文档的目录
--dribble=FILENAME
	将用户按键记录在指定的文件
-f, --file=FILENAME
	指定要读取的info格式的帮助文档
-h, --help
	显示帮助信息并退出
--index-search=STRING
	转到由索引项 STRING 指向的节点
-n, --node=NODENAME
	指定首先访问的 info 帮助文件的节点
-o, --output=FILENAME
	输出被选择的节点内容到指定的文件
-R, --raw-escapes
	输出原始 ANSI 转义字符(默认)
--no-raw-escapes
	转义字符输出为文本
--restore=FILENAME
	从文件 FILENAME 中读取初始击键
-O, --show-options, --usage
	转到命令行选项节点
--strict-node-location
	(用于调试)按原样使用 info 文件指针
--subnodes
	递归输出菜单项
--vi-keys
	使用类 vi 和类 less 的绑定键
--version
	显示版本并退出
-w, --where, --location
	显示 info 文件路径

4.交互式命令

info 有自己的交互式命令，不同于 man 使用的 less 的交互式命令，主要有：

?
	显示帮助窗口
x
	关闭帮助窗口
q
	关闭整个 Info
Up
	向上键，向上移动一行
Down
	向下键，向下移动一行
Space, PageDown
	翻滚到下一页，当前页的最后两行保留为下一页的起始两行
Del, PageUp
	翻滚到上一页，当前页的起始两行保留为上一页的最后两行
b, t, Home
	跳转到文档的开始
e, End
	跳转到文档的末尾
[
	转到文档中的上一个节点
]
	转到文档中的下一个节点
n
	转到与当前 Node 同等级的下一个 Node
p
	转到与当前 Node 同等级的前一个 Node
u
	转到与当前 Node 关联的上一级 Node
l
	回到上一次访问的 Node
m, g
	输入指定菜单的名字后按回车，跳转到指定的菜单项（Node 的名字）

5.常用示例

（1）查看 info 命令的 info 格式的帮助文档。

info info

（2）查看 info 命令的 info 格式的帮助文档地址。

info -w info
/usr/share/info/info.info.gz

●basename 命令:
1.命令简介

basename 命令从文件路径中剥离目录和后缀，以获取文件的基本名称。与 dirname 命令作用相反，dirname 用于获取目录部分。
2.命令格式

basename NAME [SUFFIX]
basename OPTION... NAME...

3.选项说明

长选项的强制参数对于短选项也是强制的。

-a, --multiple
	支持多个文件名称参数，将每一个参数当做文件名对待
-s, --suffix=SUFFIX
	移除后缀
-z, --zero
	以空字符 NUL 分隔输出而不是换行符
--help
	显示帮助并退出
--version
	显示版本并退出

4.常用示例

（1）获取文件名，不包含目录。

basename /root/go/src/main.go
main.go

（2）获取文件名，不包含目录与后缀。

basename /root/go/src/main.go .go
main

（3）同时获取多个文件名，不包含目录与后缀。

basename -a -s .go /root/go/src/main.go /root/go/src/util.go
main
util

（4）如果路径最后一个是目录，那么急脾气最后一个目录的名字。

basename /root/go/src/
src

●dirname 命令:
1.命令简介

dirname 命令从文件路径中获取文件目录。作用与 basename 命令相反，basename 用于获取文件名。

如果文件路径中不包含 /，那么输出 . 表示当前目录。如果文件路径最后一个字符是 /，那么剥离倒数第二个 / 及其后的内容。
2.命令格式

dirname [OPTION] NAME...

3.选项说明

-z, --zero
	用空字符 NUL 而不是换行符分隔输出
--help
	显示帮助并退出
--version
	显示版本并退出

4.常用示例

（1）获取目录部分，剥掉文件名。

dirname /root/go/src/main.go
/root/go/src

（2）获取目录部分，剥掉文件名，后跟多个文件路径。

dirname /root/go/src/main.go /root/go/src/util.go
/root/go/src
/root/go/src

（3）获取目录的目录。即如果文件路径最后一个字符是 /，那么剥离倒数第二个 / 及其后的内容。

dirname /usr/bin/
/usr

（4）如果文件路径中不包含 /，那么输出 . 表示当前目录。

dirname stdio.h
.

（5）路径是根目录的特殊情况。不剥除任何内容，输出 /。

dirname /
/

●expr 命令:
1.命令简介

expr（expression） 命令用于计算表达式的值。支持关系运算、算数运算、字符串匹配、截取、获取长度等相关运算。只支持整数和字符串，不支持浮点数。若涉及浮点数的运算，可使用 bc 命令。
2.命令格式

expr EXPRESSION
expr OPTION

3.选项说明

--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.表达式说明

ARG1 | ARG2
	若 ARG1 的值不为 0 或者不为空，则返回 ARG1，否则返回 ARG2
ARG1 & ARG2
	若两边的值都不为 0 或都不为空，则返回 ARG1，否则返回 0
ARG1 < ARG2
	ARG1 小于 ARG2 返回 1 否则返回 0
ARG1 <= ARG2
	ARG1 小于或等于 ARG2 返回 1 否则返回 0
ARG1 = ARG2
	ARG1 等于 ARG2 返回 1 否则返回 0
ARG1 != ARG2
	ARG1 不等于 ARG2 返回 1 否则返回 0
ARG1 >= ARG2
	ARG1 大于或等于 ARG2 返回 1 否则返回 0
ARG1 > ARG2
	ARG1 大于 ARG2 返回 1 否则返回 0
ARG1 + ARG2
	计算 ARG1 与 ARG2 相加之和
ARG1 - ARG2
	计算 ARG1 与ARG2 相减之差
ARG1 * ARG2
	计算 ARG1 与ARG2 相乘之积
ARG1 / ARG2
	计算 ARG1 与 ARG2 相除之商，向下转换成整数
ARG1 % ARG2
	计算 ARG1 与ARG2 相除取余
STRING : REGEXP
	 执行模式匹配。两端参数会转换为字符串格式，且第二个参数被视为正则表达式(GNU基本正则)，它默认会隐含前缀"^"。随后将第一个参数和正则模式做匹配。如果匹配成功，且 REGEX 使用了 \( 和 \)，则返回匹配到的内容，如果未使用 \( 和 \)，则返回匹配的字符数。否则返回为 0
match STRING REGEXP
	等于 STRING : REGEXP
substr STRING POS LENGTH
	返回 STRING 中从 POS（从 1 开始） 开始长度最大为 LENGTH 的子串。如果 POS 或 LENGTH 为负数、0 或非数值，则返回空字符串
index STRING CHARS
	CHARS 中任意单个字符在 STRING 中最前面的字符位置。如果在 STRING 中完全不存在 CHARS 中的字符，则返回 0
length STRING
	字符串的长度
+ TOKEN
	将 TOKEN 解析为普通字符串，即使 TOKEN 是像 match 或操作符 / 一样的关键字
( EXPRESSION )
	表达式可以使用一对小括号括起来。注意表达式与括号间需要空格

注意：
（1）很多操作符需要进行转义，比如大于号在 Shell 中用于重定向，使用大于号时需要转义 >；
（2）如果两个参数都是数字，那么比较就是算术运算，否则就是字典序。
4.常用示例

（1）整数的算数运算。

expr 1 + 1
2

expr 1 - 1
0

expr 1 * 1
1

expr 1 / 2
0

expr 1 % 2
1

（2）整数的关系运算。

expr 1 \< 1
0

expr 1 \<= 1
1

expr 1 \> 1
0

expr 1 \>= 1
1

expr 1 = 1
1

expr 1 != 1

（3）字符串的关系运算。

expr "abc" \< "acb"
1

（4）执行模式匹配，获取匹配正则的字符串或其长度。

expr "abcd" : "\(.bc\)"
abc

# 不使用小括号获取匹配正则的字符串的长度
expr "abcd" : ".bc"
3

（5）截取子串。

expr substr "abcd" 1 3
abc

（6）获取字符串长度。

expr length "abcd"
4

（7）将 expr 中具有特殊意义的关键字强制解析为普通字符串并获取其长度。

expr length + "length"
6

（8）使用小括号，使得 expr 支持多个表达式。

expr 1 + \( 1 + 1 \)
3

●bc 命令:
1.命令简介

bc（Binary Calculator）命令用于任意精度的计算，语法类似于 C 语言。Bash 内置了对整数四则运算的支持，但是并不支持浮点运算，而 bc 命令可以很方便地进行浮点运算和整数运算。

本文描述的 GNU 版本超出了传统 bc 的实现和 POSIX 标准。在使用扩展功能时，可以使用命令行选项打印警告或拒绝使用。
2.命令格式

bc [-hlwsqv] [long-options] [<file>...]

3.选项说明

-h, --help
	显示帮助信息并退出
-i, --interactive
	强制进入交互式模式
-l, --mathlib
	定义使用的标准数学库
-w, --warn
	对 POSIX bc 的扩展给出警告信息
-s, --standard
	完全使用 POSIX 版本的 bc 功能
-q, --quiet
	不打印正常的 GNU bc 环境信息
-v, --version
	打印 bc 版本与版权后退出

4.特殊变量

bc 在运算过程中将数值存储在两种类型的变量中，简单变量和数组。两种变量均使用字母开头后跟字母、数字或下划线的命名方式且全部小写。其中有四个特殊变量：

scale	定义某些操作如何使用小数点后的数字，默认值为 0
ibase	定义输入数的基数，默认为十进制数
obase	定义输出数的基数，默认为十进制数
last	表示最后的输出值

5.注释

bc 中的块注释使用/* */，行注释使用 #。
6.表达式

表达式的输入值可以是 2 到 16 进制的数值，数值的基数由特殊变量 ibase 决定。如果数值中包含字符 A-F，则必须使用大写，因为小写表示变量名。

在下面表达式的描述中，EXPR 指完整表达式，VAR 指简单变量或数组变量。简单变量只是一个名称，数组变量被指定为 NAME[EXPR]。

除非特别提到，结果的精度是表达式中最大的精度。

基本运算：
- EXPR
	相反数
++ VAR
	自增 1
-- VAR
	自减 1
VAR ++
	表达式的结果是变量的值，然后变量自增 1
VAR --
	表达式的结果是变量的值，然后变量自增 1
EXPR + EXPR
	两个表达式相加
EXPR - EXPR
	两个表达式相减
EXPR * EXPR
	两个表达式相乘
EXPR / EXPR
	两个表达式相除。结果的精度由特殊变量 scale 确定
EXPR % EXPR
	两个表达式取余
EXPR ^ EXPR
	取幂。第二个表达式 EXPR 必须是整数
( EXPR )
	这将更改标准优先级以强制执行表达式的计算
VAR = EXPR
	将表达式的结果赋给变量 VAR
VAR <OP>= EXPR
	这相当于 var = var EXPR

关系运算：
EXPR1 < EXPR2
EXPR1 <= EXPR2
EXPR1 > EXPR2
EXPR1 >= EXPR2
EXPR1 == EXPR2
EXPR1 != EXPR2

逻辑运算：
!EXPR
EXPR && EXPR
EXPR || EXPR

以上表达式涉及的运算符优先级由低到高依次为：

||			左结合
&&			左结合
!			非结合的
关系运算符	左结合
赋值运算符	由结合
+, -		左结合
*, /, %		左结合
^			右结合
取反运算符	非结合的
++, --		非结合的

以上运算符优先级与 C 语言有些出入，使用时需要注意。比如表达式 a = 3 < 5 在 C 语言中 a 的值为 0，在 bc 中，因为 = 的优先级高于 <，所以 a 的值为 3。

bc 中提供了一些特殊的表达式，这些与用户定义的函数和标准函数有关，下文函数一节将会详述。
7.语句

bc 的语句使用分号和换行符进行分隔，下面将介绍 bc 中常用的语句。注意，中括号 [] 中的内容是可选的。

EXPRESSION
	表达式分为赋值表达式与非赋值表达式，如果表达式不是赋值语句，则计算表达式并将其结果打印到输出
STRING
	使用双引号包围的内容被视为字符串。字符串可以包含特殊字符，使用反斜杠表示，\a 响铃，\b 退格，\f 换页，\n 换行，\r 回车，\q 双引号，\t 制表符，\\ 反斜杠
print LIST
	使用 print 语句进行输出。LIST 是逗号分隔的字符串或者表达式
{ STATEMENT_LIST }
	这是个复合语句，它允许将多个语句组合在一起执行
if ( EXPRESSION ) STATEMENT1 [else STATEMENT2]
	if 条件语句。如果表达式 EXPRESSION 结果非 0，则执行语句 STATEMENT1，否则执行 STATEMENT2
while ( EXPRESSION ) STATEMENT
	while 循环语句。如果表达式 EXPRESSION 结果非 0，则循环执行语句
for ( [EXPRESSION1] ; [EXPRESSION2] ; [EXPRESSION3] ) STATEMENT
	for 循环语句
break
	用于退出最近一层的 while 或 for 循环
continue
	用于最近一层的 while 或 for 循环提前进入下一轮循环
halt
	结束 bc
return
	从函数中返回 0
return ( EXPRESSION )
	从函数返回表达式 EXPRESSION 的值
limits
	打印 bc 的限制
quit
	结束 bc
warranty
	打印授权注意事项

8.函数

bc 支持函数，定义形式如下：

define [void] NAME ( PARAMETERS ) {
	AUTO_LIST   STATEMENT_LIST }

其中 关键字 void 表示函数无返回值，NAME 为函数名，PARAMETERS 为函数参数，AUTO_LIST 为函数内部使用 auto 关键字申明的局部变量，STATEMENT_LIST 为函数 bc 语句。

函数调用形式：

NAME(PARAMETERS)

常用的内置函数有：

length ( EXPRESSION )
	数值的有效数字的个数
read ()
	从标准输入读取输入
scale ( EXPRESSION )
	数值小数点后的数字的个数
sqrt ( EXPRESSION )
	求平方根。如果 EXPRESSION 是一个负数，则引发运行时错误

如果使用 -l 选项调用 bc，则会预加载一个数学库，并将默认精度设置为 20。数学库定义了以下函数：

s (x)
	求正弦值 sin(x)，x 的单位是弧度
c (x)
	求余弦值 cos()，x 的单位是弧度
a (x)
	x 的反正切，反正切返回弧度
l (x)
	x 的自然对数
e (x)
	指数函数，求自然 e 的 x 次幂
j (n,x)
	x 的整数阶 n 的贝塞尔函数

9.常用示例

（1）执行浮点运算。

echo "3.141592653 * 3" | bc
9.424777959

（2）指定计算结果的精度。

echo "scale = 2; 3.0/8" | bc
.37

# 输出小数点前的 0
echo 'scale = 2; a = 3.0/8; if (length(a) == scale(a)) print 0; print a,"\n"' | bc
0.37

（3）进制转换。如将二进制转换为十进制。

echo "obase=10;ibase=2;00001111" | bc
15

（4）幂运算。

echo "9^2" | bc
81

（5）调用内置函数 sqrt() 计算平方根。

echo "sqrt(16)" | bc
4

（6）交互式进行数学运算。

bc
9+9
18
9*9
81
sqrt(81)
9
quit

●zip 命令:
1.命令简介

zip 命令是一个应用广泛的跨平台的打包和压缩工具，使用 Deflate（LZ77 + 哈夫曼编码）无损压缩算法将文件压缩为后缀为 .zip 的 zip 文件。其配套的命令为 unzip，用于解压 zip 文件。
2.命令格式

zip [OPTIONS] [ZIPFILE [FILE...]]

选项与文件列表均是可选的，单独执行 zip 则打印简要的帮助信息。
3.选项说明

下面主要介绍了通用选项和 Linux 平台的选项，其它平台（VMS、MS-DOS、MacOS 等）的专有选项参见 zip(1) 手册。

长选项的强制参数对于短选项也是强制的。

-a, --ascii
	将文件转换为 ASCII 格式
-A, --adjust-sfx
	调整自解压可执行归档文件。通过将 SFX 存根添加到现有存档中首部，可以创建自解压缩的可执行存档
-b, --temp-path PATH
	指定暂时 zip 文件的目录
-c, --entry-comments
	为每一个被压缩的文件加上一行注释说明
-d, --delete
	删除压缩文件内指定的文件。例如 zip -d foo foo/tom/junk foo/harry/\* \*.o，将移除文件 foo/tom/junk以及所有以 foo/harry/ 开头的文件以及后缀为 .o 的文件
-db, --display-bytes
	显示已处理的字节和剩余的字节
-dc, --display-counts
	显示已压缩的条目数和剩余条目数
-dd, --display-dots
	压缩每个条目时显示进度条。进度条使用点表示，默认每个点表示压缩了 10MB
-dg, --display-globaldots
	显示整体压缩的进度条，而不是每个文件的进度条。默认每个点表示压缩了 10MB
-ds, --dot-size SIZE
	设置进度条中每个点表示已处理的文件大小，默认为 10MB。如果设置为 0 表示关闭进度条
-du, --display-usize
	显示每个条目未压缩的大小
-dv, --display-volume
	显示每个条目的卷(磁盘)号
-D, --no-dir-entries
	忽略目录
-DF, --difference-archive
	增量压缩，即压缩新增或更新的文件到旧的压缩归档中。应该从运行原始 zip 命令的相同目录运行，因为存储在 zip 归档中的文件路径信息会被保留
-e, --encrypt
	压缩时进行加密，输入的密码不会被打印出来
-f, --freshen
	增量压缩，只压缩更新的文件。应该从运行原始 zip 命令的相同目录运行，因为存储在 zip 归档中的文件路径信息会被保留
-F, --fix, -FF, --fixfix
	修复已损失的压缩文件。如果压缩文件的某些部分丢失，则可以使用 -F 选项来修复，但需要一个相当完整的中心目录。如果压缩文件损坏严重或者被截断，则需要 -FF 来修复
-FS, --filesync
	将存档的内容与操作系统上的文件进行同步。如果归档中的条目与操作系统上的文件不匹配，则删除该条目
-g, --grow
	向已存在的 zip 归档文件追加内容。如果此操作失败，zip 将尝试还原存档文件到其原始状态。如果恢复失败，则存档文件可能会被损坏
-h, -?, --help
	相识帮助信息并退出。当 zip 无参数运行时，等同于使用该选项，显示帮助信息
-h2, --more-help
	显示扩展的帮助信息，包括更多关于命令行格式、模式匹配和更多少用的选项
-i, --include FILES
	指定被压缩的文件
-j, --junk-paths
	不保留被压缩的文件的目录信息，只保留文件名
-J, --junk-sfx
	从存档中删除所有前置追加的数据(例如 SFX 存根)
-k, --DOS-names
	尝试转换名称和路径以符合 MSDOS，只存储 MSDOS 属性将条目标记为 MSDOS 下的条目
-l, --to-crlf
	将 Unix 的行尾字符 LF 转换成 MSDOS 约定的 CR LF。此选项不应用于二进制文件
la, --log-append
	附加到现有日志文件。默认是覆盖
-lf, --logfile-path LOGFILEPATH
	打开指定的日志文件
-li, --log-info
	在日志中包含更多信息，例如被压缩的文件名。默认情况下只包含命令行、警告和错误以及最终状态
-ll, --from-crlf
	作用于 -l 选项相反。将 MSDOS 的结束行 CR LF 转换为 Unix 的 LF。此选项不应用于二进制文件
-L, --license
	显示 zip 许可证
-m, --move
	将指定的文件移动到 zip 归档文件中。目标文件会被删除，如果目标文件所在的目录变成空目录，也会被删除
-MM, --must-match
	所有输入的模式至少匹配一个文件，且所有输入的文件必须可读，否则 zip 将返回 OPEN 错误并退出
-n, --suffixes SUFFIXES
	不要尝试压缩指定后缀的文件。这些文件只是简单地存储在输出 zip 中(0%压缩)
-nw, --no-wild
	不执行内部通配符的处理。注意 Shell 仍然会执行通配符的处理，除非对通配符使用了转义
-o, --latest-time
	将 zip 文件的最后修改时间更改为其所有条目中最近修改时间中最近的时间
-O, --output-file OUTPUT-FILE
	不更改现有 zip 文件，指定新输出的 zip 文件
-p, --paths
	在 zip 文件中存储文件的路径信息。该选项为默认选项，可以使用 -j 选项只存储文件名
-P, --password PASSWORD
	使用指定密码加密 zip 中的条目。注意，该操作不安全，因为密码可能会被其他用户通过查看历史命令窥探到，安全的做法是通过交互式输入不可打印的密码完成加密
-q, --quiet
	静默模式。消除各种消息和提示
-r, --recurse-paths
	递归压缩指定目录
-R, --recurse-patterns
	递归遍历当前目录
-s, --split-size SPLITSIZE
	指定 zip 归档文件被拆分的大小
-sb, --split-bell
	zip 暂停分隔归档文件时响铃提示
-sc, --show-command
	在 zip 启动和结束时，显示命令行
-sf, --show-files
	显示将要操作的文件，然后退出。例如，如果创建一个新的存档，它将列出将要添加的文件。如果该选项后跟 -，即 -sf-，仅输出到打开的日志文件。对于大列表，不建议使用屏幕显示
-so, --show-options
	显示 zip 所有可用的选项
-sp, --split-pause
	如果使用 -s 启用分割，则启用分割暂停模式
-su, --show-unicode
	类似于选项 -sf，但是如果存在 Unicode 版本的路径则显示
-sU, --show-just-unicode
	如果存在，只显示 Unicode 版本的路径，否则显示该路径的标准版本
-sv, --split-verbose
	输出拆分时的各种详细消息，显示如何进行拆分
-t, --from-date MMDDYYYY
	不对最后修改时间早于指定日期的文件进行操作。其中 MM 表示月（00-12），DD 表示每个月的日（01-31），YYYY 表示年
-T, --test
	检查新 zip 文件的完整性，如果检查失败，那么旧的 zip 文件不会被改变，且输入的文件不会被删除（如果使用 -m 选项）
-TT, --unzip-command CMD
	当使用选项 -T 时，使用指定的命令对 zip 归档文件进行检测，而不是使用默认的命令 unzip -tqq
-u, --update
	更新 zip 归档文件中被更新的条目
-U, --copy-entries
	将条目从一个 zip 存档复制到另一个存档。需要 --out 选项来指定与输入存档不同的输出文件
-UN, --unicode V
	确定 zip 如何处理 Unicode 文件名。V 可取值有：q 如果路径不匹配，则退出；w 警告，继续使用标准路径；i 忽略 继续使用标准路径；n 不使用 Unicode 路径
-v, --verbose
	详细模式或打印诊断与版本信息
-ws, --wild-stop-dirs
	通配符 * 只用于替换文件而不包含目录。如 /foo/bar/* 只会匹配 /foo/bar/file2.c，不会匹配 /foo/bar/dir/file1.c
-x, --exclude FILES
	显式排除指定的文件，如 zip -r foo foo -x \*.o，将排除目录 foo 下所有以 .o 结尾的文件。注意，星号需要转义，以免被 Shell 替换
-X, --no-extra
	不保存额外的文件属性
-y, --symlinks
	压缩存储符号链接本身而不是目标文件
-z, --archive-comment
	提示为整个 zip 归档文件输入多行注释。注释以仅包含一个点号的行结束或者输入 ^D。也可以从文件中获取注释，如 zip -z foo < foowhat
-Z, --compression-method CM
	设置默认的压缩算法。目前 zip 支持的主要算法是 store、deflate 和 bzip2
-#(-0, -1, -2, -3, -4, -5, -6, -7, -8, -9)
	使用指定的数字 # 调节压缩速度，其中 -0 表 示没有压缩，仅打包所有文件；-1 表示最快的压缩速度，压缩率较低；-9表示最慢的压缩速度，最佳的压缩效果；默认压缩级别为 -6
-@, --names-stdin
	从标准输入获取输入文件列表，每行一个文件

4.常用示例

（1）压缩指定文件。

zip passwd.zip /etc/passwd
adding: etc/passwd (deflated 58%)

输出中 deflated 58% 表示压缩率为 58%，即压缩后的文件大小是原文件的 42%。

（2）压缩文件时进行加密。

zip -e passwd.zip /etc/passwd
Enter password: 
Verify password: 
  adding: etc/passwd (deflated 58%)

（3）使用 -r 选项递归压缩指定目录。

zip -r shell.zip shell
adding: shell/ (stored 0%)
adding: shell/sleepParent.sh (stored 0%)
adding: shell/sleep.sh (deflated 22%)
adding: shell/dir/ (stored 0%)
adding: shell/dir/test.sh (stored 0%)

（4）使用 -r 和 -0 选项只打包不压缩指定目录。

zip -r -0 shell.zip shell

（5）静默模式执行 zip，不显示 zip 命令执行过程。

zip -rq shell.zip shell

（6）向压缩文件追加文件。比如向上面生成的 shell.zip 追加文件 /etc/passwd。

zip -g shell.zip /etc/passwd
adding: etc/passwd (deflated 58%)

（7）查看 zip 文件中包含的文件。需要使用 unzip -l 命令只查看不解压。

unzip -l shell.zip
Archive:  shell.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
        0  11-24-2019 22:20   shell/
       24  10-27-2019 21:46   shell/sleepParent.sh
       58  10-30-2019 18:32   shell/sleep.sh
        0  10-30-2019 20:29   shell/dir/
        0  10-30-2019 20:13   shell/dir/test.sh
     1552  01-04-2019 14:56   etc/passwd
---------                     -------
     1668                     6 files

（8）从 zip 压缩文件中删除指定文件。

zip -d shell.zip /etc/passwd
deleting: etc/passwd

（9）压缩文件时显示已压缩的条目数和剩余条目数。

zip -dg -r shell.zip shell
0/  5	adding: shell/ (stored 0%)
1/  4	adding: shell/sleepParent.sh (stored 0%)
2/  3	adding: shell/sleep.sh (deflated 22%)
3/  2	adding: shell/dir/ (stored 0%)
4/  1	adding: shell/dir/test.sh (stored 0%)

第一列表示已压缩的条目数，第二列表示剩余条目数。如果想显示已处理的字节和剩余的字节数，可以使用 -db 选项。

●unzip 命令：
1.命令简介

unzip 命令用于列出、测试和提取 ZIP 存档中的压缩文件。如果 unzip 不跟任何选项（默认行为），会将指定的 ZIP 存档文件解压到当前目录。
2.命令格式

unzip [-Z] [OPTIONS] [ZIP_FILE...] [FILE...]  [-x FILE...] [-d EXDIR]

[ZIP_FILE…] 表示 ZIP 存档文件，[FILE…] 表示待处理的 ZIP 存档文件中的文件列表，[-x FILE…] 表示不处理的文件列表，[-d EXDIR] 表示解压缩后的文件存放的目录。文件名均可使用通配符表示。

注意，unzip 可以不跟任何选项和参数，单独执行 unzip 将打印简要帮助信息。
3.选项说明

长选项的强制参数对于短选项也是强制的。下面主要介绍了通用选项和 Linux 平台的选项，其它平台（VMS、MS-DOS、MacOS 等）的专用选项参见 unzip(1) 手册。

-Z
	等于执行 zipinfo(1) 命令，用于查看 zip 文件的整体信息
-c
	将解压缩后的文件内容输出到标准输出（屏幕），并对字符做适当的转换。类似于 -p 选项，但是 -c 会输出文件名
-f
	更新现有的文件，即只提取那些已经存在于磁盘上且比磁盘副本更新的文件
-l
	只显示压缩文件内所包含的文件不解压
-p
	与 -c 选项类似，以二进制模式解压文件，不会执行任何的转换，并将文件内容输出到标准输出（屏幕）
-t
	对文件进行 CRC 校验检查压缩文件是否正确
-u
	与 -f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压出来
-v
	执行时显示详细的信息
-z
	仅显示压缩文件的备注信息
-a
	对文本文件进行必要的字符转换
-b
	将所有文件视为二进制文件，不对文本文件进行字符转换
-B
	对本地即将被覆盖的文件进行备份
-C
	匹配命令行指定的待提取的文件列表时不区分大小写
-D
	不还原提取项的时间戳。正常情况，unzip 会恢复提取项的时间信息（Access Time、Modify Time 和 Change Time）
-j
	不生成提取项的目录，即所有提取项均放到同级目录下
-L
	将压缩文件中的全部文件名改为小写
-M
	将所有输出通过 unzip 内部的类似于 more(1) 的浏览工具进行浏览
-n
	永远不要覆盖现有文件。如果文件已经存在，则跳过该文件的提取而不提示。默认情况下，unzip 会进行询问是否提取、覆盖或重命名
-o
	覆盖现有文件而不提示
-P PASSWORD
	使用密码解密 zip 文件
-q
	执行时不显示任何信息
-s
	将文件名中的空白字符转换为下划线
-U	
	修改或禁用UTF-8处理。当 UNICODE_SUPPORT 可用时，选项 -U 强制 unzip 将 UTF-8 编码的文件名中的所有非 ASCII 字符转义为 #uxxx（对于UCS-2字符，或者对于需要 3 个字节的 UNICODE 码点转为 #Lxxxxxx）。此选项主要用于在怀疑提取 UTF-8 编码文件名时会失败而进行的调试行为
-W
	修改通配符 ?（单字符统配符）与 *（多字符通配符） 的匹配行为，使得 ? 与 * 不能匹配目录的分隔符 /。如 "*.c" 匹配 "foo.c"，但不能匹配 "mydir/foo.c"
-X
	解压缩时同时恢复文件原来的 UID/GID
-:
	允许创建提取项的父目录 ../，默认情况下为了安全起见是不允许的。使用该选项应格外小心
-^
	允许在提取的 ZIP 存档项的名称中使用控制字符

4.常用示例

首先使用 zip 命令对文件 /etc/passwd 和 /etc/group 进行压缩生成 test.zip 文件，同时使用 -z 选项为 zip 文件添加注释说明。

zip test.zip /etc/passwd /etc/group
  adding: etc/passwd (deflated 58%)
  adding: etc/group (deflated 45%)
enter new zip file comment (end with .):
this is test.zip's comment
.

（1）使用 -Z 选项查看 ZIP 归档文件 test.zip 的整体信息。

unzip -Z test.zip
Archive:  test.zip
Zip file size: 1321 bytes, number of entries: 2
-rw-r--r--  3.0 unx     1552 tx defN 19-Jan-04 14:56 etc/passwd
-rw-r--r--  3.0 unx      642 tx defN 19-Jan-04 14:56 etc/group
2 files, 2194 bytes uncompressed, 1005 bytes compressed:  54.2%

（2）将压缩文件解压缩至当前目录。

unzip test.zip

（3）如果当前目录存在同名的文件，解压缩时不覆盖原有文件。

unzip -n test.zip

（4）解压缩时覆盖原有文件，不进行询问。

unzip -o test.zip

（5）将压缩文件解压缩至指定目录。

mkdir dir
unzip test.zip -d dir

（6）仅显示 zip 文件的注释说明，不解压。

unzip -z test.zip
Archive:  test.zip
this is test.zip's comment

（7）仅查看 zip 文件中的文件列表，不解压。

unzip -l test.zip
Archive:  test.zip
this is test.zip's comment
  Length      Date    Time    Name
---------  ---------- -----   ----
     1552  01-04-2019 14:56   etc/passwd
      642  01-04-2019 14:56   etc/group
---------                     -------
     2194                     2 files

●crontab 命令
1.命令简介

crontab（cron table） 命令被用管理用户的需要周期性执行的任务，与 Windows 下的计划任务类似，当安装完操作系统后，默认会安装此服务工具，并且会自动启动 crond 进程，crond 进程每分钟会检查是否有要执行的任务，如果有则执行该任务。

Linux 下的任务调度分为两类，系统任务调度和用户任务调度。

系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。/etc/crontab 文件是系统任务调度的配置文件。

用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的 crontab 文件都被保存在 /var/spool/cron 目录中，其文件名与用户名一致。

系统管理员可以通过/etc/cron.deny 和 /etc/cron.allow 这两个文件来禁止或允许用户拥有自己的 crontab 文件。
2.命令格式

crontab [-u USER] FILE
crontab [-u USER] [-l | -r | -e] [-i] [-s]
crontab -n [ HOSTNAME ]
crontab -c

3.选项说明

-u
	指定要设置定时任务的用户名
-l
	列出当前的定时任务
-r
	删除定时任务
-e
	编辑用户的定时任务。任务保存在 /var/spool/cron 目录下与用户名同名的文件中
-i
	在删除定时任务前询问用户是否确定删除
-s
	在进行编辑/替换之前，将当前的 SELinux 安全上下文字符串作为 MLS_LEVEL 附加到 crontab 文件
-n [HOSTNAME]
	此选项只有当 cron(8) 使用 -c 选项启动以支持集群环境时才使用，用于指定集群中哪个主机执行定时 crontab 文件中的定时任务。如果省略了主机名，则使用 gethostname(2) 返回的本地主机名
-c
	此选项只有当 cron(8) 使用 -c 选项启动以支持集群环境时才使用，用于查询集群中当前哪个主机执行定时 crontab 文件中的定时任务

4.用户配置文件

crontab 文件保存了用户的定时任务，以特定格式保存在 /var/spool/cron 目录下与用户名同名的文件中。例如如果是 root 用户，那么添加任务时，会在该路径下有一个 root 文件。Linux 的 cron 服务会每隔一分钟去读取一次 /var/spool/cron 目录下面所有的内容。

crontab 文件每一行代表一项任务，每项任务分为六个字段，前五个字段是时间字段，第六个字段是要执行的命令，格式如下：

minute hour day month week command

minute 分钟，取值范围 0 到 59；
hour 小时，取值范围 0 到 23；
day 日期，取值范围 1 到 31；
month 月份，取值范围 1 到 12，或 jan,feb,mar,apr…；
week 星期，取值范围 0 到 7，或 sun,mon,tue,wed,thu,fri,sat。注意 0 和 7 均代表星期日；
command 要执行的命令，可以是系统命令，也可以是自己编写的脚本文件；

在以上各个时间字段中，还可以使用以下特殊字符：

* 表示所有可能的值，例如 minute 是 *，表示每分钟都执行命令
, 可以用逗号隔开的值指定一个列表，例如，1,2,5,7,8,9
- 可以用整数之间的横杠表示一个范围，例如 2-6 表示 2,3,4,5,6 
/ 可以用斜杠指定时间的间隔频率，例如 minute 为 */2 表示每两分钟执行一次命令

注意，crontab 文件注释符号为 #。
5.系统配置文件

除了用户的 crontab 文件，与定时任务相关的系统配置文件有：

/etc/crontab		系统定时任务配置文件
/etc/cron.d			自动定期需要做的任务
/etc/cron.hourly	每小时执行一次的任务
/etc/cron.daily		每天执行一次的任务
/etc/cron.weekly	每周执行一次的任务
/etc/cron.monthly	每月执行一次的任务
/etc/cron.allow    	该文件中所列用户允许执行定时任务
/etc/cron.deny    	该文件中所列用户不允许执行定时任务
/var/log/cron		crontab 的日志文件

Linux 的 cron 服务会每隔一分钟去读取一次 /etc/crontab 文件和 /etc/cron.d 目录下面所有的内容。/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly 和 /etc/cron.monthly 下的任务也会间接按照相应的周期被调用。
6.常用示例

（1）添加定时任务。

crontab -e
* * * * * command			# 每分钟执行一次 command
3,15 * * * * command		# 每小时的第 3 和第 15 分钟执行
3,15 8-11 * * * command		# 上午 8 点到 11点每小时第 3 和第 15 分钟执行
3,15 8-11 * * 1 command		# 每个星期一的上午 8 点到 11 点的第 3 和第 15 分钟执行
3,15 8-11 1 * * command		# 每个月一号上午 8 点到 11 点的第 3 和第 15 分钟执行
3,15 8-11 1 1 * command		# 每年一月一号上午 8 点到 11 点的第 3 和第 15 分钟执行
0 */2 * * * /sbin/service httpd restart	# 每隔两个小时在第 0 分时候重启一次 httpd

（2）查看定时任务。

crontab -l

（3）删除定时任务，即清除 /var/spool/cron 目录下 crontab 文件。危险动作，请注意备份。

crontab -r

（4）将指定的 crontab 文件还原到 /var/spool/cron 目录下。

crontab FILE

●service 命令:
1.命令简介

service 命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、重新加载配置（reload）、查看状态（status）等。不同的 Linux 发行版一般均会带有此命令，比如 RHEL、CentOS、SUSE、Ubuntu、Fedora 等。

service 命令是系统管理员命令，需要管理员权限才可以执行。service 命令本质上是一个 Shell 脚本，地址一般为 /sbin/service。
2.命令格式

service SCRIPT COMMAND [OPTIONS]
service --status-all
service --help | -h | --version

SCRIPT 表示管理服务的脚本，存放在 /etc/init.d/SCRIPT。COMMAND 和 [OPTIONS] 是传递给 SCRIPT 的参数。服务脚本 SCRIPT 应该至少支持 start 命令和 stop 命令。如果 COMMAND 是 --full-restart，则服务脚本将运行两次，首先使用 stop 命令，然后使用 start 命令。
3.选项说明

--status-all
	按字母顺序执行所有初始化脚本并传递 status 命令，显示所有的服务状态
-h, --help
	显示帮助信息
--version
	显示版本信息

4.常用示例

（1）查看所有服务当前的运行状态。

service --status-all

（2）将 MySQL 注册为系统服务，使用 service 命令管理。需要将 MySQL 的管理脚本 mysql.server 更名为 mysqld 放在 /etc/init.d/ 目录。

# 开启
service mysqld start

# 关闭
service mysqld stop

# 重启
service mysqld restart

● chkconfig 命令:
1.命令简介

chkconfig 命令用于更新和查询系统服务的运行等级信息。它可查询操作系统在每一个运行等级中会自动执行哪些系统服务，包括各类常驻服务，比如 httpd、sshd、mysqld 等。

chkconfig 实际上是通过改变七个不同运行等级目录 /etc/rc[0-6].d 中服务脚本的符号链接，来设置操作系统在每一个运行等级中会执行哪些系统服务。chkconfig 不是用于立即启动或停止某一个服务，这一点与 service 不同。

chkconfig 有五个功能：
（1）添加新的服务供 chkconfig 管理；
（2）从 chkconfig 管理服务列表中删除服务；
（3）列出 chkconfig 管理的所有服务的当前启动信息；
（4）更改服务的启动信息；
（5）检查特定服务的启动状态。
2.命令格式

chkconfig
service [OPTIONS] SERVICENAME

没有任何选项的 chkconfig 或跟选项 --list 将显示所有服务及其当前配置的列表。

当 chkconfig 后只跟服务名时，会检查服务是否配置为在当前运行级别自启动，如果是，则 chkconfig 返回 true，否则返回 false。–level 选项可用于让 chkconfig 查询其它运行级别而不是当前运行级别下的配置。

如果在服务名称之后指定了 on、off、reset 或 resetpriorities 之一，chkconfig 将更改指定服务的启动信息。on 和 off 标志分别导致服务在正在更改的运行级别中设置为启动或停止。reset 标志将服务的所有运行级别的开关状态重置为相关 init 脚本中指定的值，而 resetpriorities 标志将服务的启动/停止优先级重置为 init 脚本中指定的值。默认情况下，on 和 off 选项仅影响运行级别 2、3、4 和 5，而 reset 和 resetpriorities 影响所有运行级别。--level 选项可用于指定受影响的运行级别。
3.选项说明

--level LEVELS
	指定操作应属于的运行级别。0 到 6 组成的数字串。例如，-level 35 指定运行级别 3 和 5
--no-redirect
	如果系统使用 systemd 作为系统的启动进程，chkconfig 将命令转发给 systemd。此选项将关闭到 systemd 的重定向，并且仅在 /etc/rc[0-6].d 中的符号链接上操作。此选项仅在 on、off 或没有向服务传递命令（检查启用）时有效
--add SERVICENAME
	添加一个新服务供 chkconfig 管理
--del SERVICENAME
	将从 chkconfig 管理中删除该服务，并删除 /etc/rc[0-6].d 中与其相关的任何符号链接
--override SERVICENAME
	更改服务配置
--list [SERVICENAME]
	列出 chkconfig 所知的所有服务在不同运行等级下的启动状态。如果指定 SERVICENAME，则只列出具体的服务的启动状态

4.常用示例

（1）列出所有的系统服务。

chkconfig
Note: This output shows SysV services only and does not include native
      systemd services. SysV configuration data might be overridden by native
      systemd configuration.

      If you want to list systemd services use 'systemctl list-unit-files'.
      To see services enabled on particular target use
      'systemctl list-dependencies [target]'.

bootlocal      	0:off	1:off	2:off	3:on	4:off	5:off	6:off
irqaffinity    	0:off	1:off	2:on	3:on	4:on	5:on	6:off
netconsole     	0:off	1:off	2:off	3:off	4:off	5:off	6:off
network        	0:off	1:off	2:on	3:on	4:on	5:on	6:off
qemu-ga        	0:off	1:off	2:on	3:on	4:on	5:on	6:off
rename_netifs  	0:off	1:off	2:off	3:on	4:off	5:off	6:off

（2）将 Apache Web 服务器配置为在每次系统启动时启动。

chkconfig httpd on

当您成功地使用 chkconfig 启用服务时，该命令不提供任何确认消息。

（3）设置 network 在运行级别为 2、3、4、5 的情况下都是关闭状态，即不启动。

chkconfig network off

# 或
chkconfig --level 2345 network off

（4）查看 network 服务的自启动状态。

chkconfig --list network
Note: This output shows SysV services only and does not include native
      systemd services. SysV configuration data might be overridden by native
      systemd configuration.

      If you want to list systemd services use 'systemctl list-unit-files'.
      To see services enabled on particular target use
      'systemctl list-dependencies [target]'.

network        	0:off	1:off	2:off	3:off	4:off	5:off	6:off

5.拓展知识
5.1 注册服务到 chkconfig

每个被 chkconfig 管理的服务需要在对应的 /etc/rc.d/init.d 下的管理脚本加上两行或者更多行的注释。第一行告诉 chkconfig 缺省启动的运行级以及启动和停止的优先级。如果某服务不在任何运行级启动，那么使用 - 代替运行级。第二行对服务进行描述，可以用 \ 跨行注释。例如 /etc/rc.d/init.d/network 中的注释：

# chkconfig: 2345 10 90
# description: Activates/Deactivates all network interfaces configured to \
#              start at boot time.

其中第一行表示运行等级在 2、3、4 和 5，启动优先级为 10，停止优先级为 90。第二行和第三行为服务 network 的描述。
5.2 Linux 系统的 7 个运行级别

运行级别是操作系统当前正在运行的功能级别，它让一些程序在一个级别启动，而在另外一个级别的时候不启动。Linux 系统一般使用 7 个级别。

0 停机状态。系统默认运行级别不能设为 0，否则不能正常启动
1 单用户模式，root权限，用于系统维护，禁止远程登陆
2 无网络的多用户模式
3 有网络的多用户模式
4 系统未使用，保留
5 图形化界面
6 系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动

默认的运行级别可以在文件 /etc/inittab 查看。一般自用的 Linux 默认登录等级为 5，即开机进入图形用户界面，远程登录的运行等级为 3，即进入命令行交互界面。

运行级别的原理：
（1）在目录 /etc/rc.d/init.d 下有许多服务管理脚本，每个服务被称为 service；
（2）在 /etc/rc.d 下有 7 个名为 rcN.d 的目录，对应系统的 7 个运行级别；
（3）rcN.d 目录下都是一些符号链接文件，这些链接文件都指向 init.d 目录下的 service 脚本文件，命名规则为K+nn+服务名或S+nn+服务名，其中 nn 为两位数字。
（4）系统会根据指定的运行级别进入对应的 rcN.d 目录，并按照文件名顺序检索目录下的链接文件：

对于以 K 开头的文件，系统将终止对应的服务
对于以 S 开头的文件，系统将启动对应的服务

（5）查看运行级别用：runlevel；
（6）进入其它运行级别用：(sudo) init N；
（7）另外 init 0 为关机，init 6 为重启系统。

另外，当使用 runlevel 查看运行级别时，结果会显示前一次的运行级别和现在的运行级别，如果前次的运行级别为 N，那么说明前次没有运行级别（可能刚刚 power on）。

●systemctl 命令:
1.命令简介

systemctl 命令是操作系统和服务的管理命令，是与 systemd 交互的主要工具，其实现的功能包含了 service 和 chkconfig 这两个命令的功能。

systemd（system daemon）是操作系统的服务的管理器，用于取代 system V 和 BSD 风格的 init 程序，是一号进程，掌管整个系统的其他进程，用于集中管理和配置类 UNIX 系统。每个服务都有一个启动文件，描述 systemd 应该如何启动自己。
2.命令格式

systemctl [OPTIONS...] COMMAND [NAME...]

3.选项说明

-t, --type=[help, UNITTYPE...]
	指明单元类型，使用逗号分隔。如果是 help，则列出所有可用的 unit type
--state=UNITSTATE...
	指明单元的状态，使用逗号分隔。例如使用 --state=failed，则在输出单元列表时只展示状态为 failed 的单元
-p, --property=PROPERTY...
	使用 show 命令显示 unit/job/manager 属性时，将显示限制为参数中指定的属性，使用逗号分隔，例如属性 MainPID
-a, --all
	列出单元时，显示所有加载的单元，无论其状态如何，包括非活动单元。显示 unit/job/manager 属性时，显示所有属性，无论它们是否已设置
-r, --recursive
	列出单元时，还显示本地容器的单元。本地容器的单元将以容器名称作为前缀，并用单个冒号字符分隔
--reverse
	与命令 list-dependencies 一起使用，显示单元之间的反向依赖项
--after
	与命令 list-dependencies 一起使用，显示指定单元前面的单元
--before
	与命令 list-dependencies 一起使用，显示指定单元后面的单元
-l, --full
	不要省略单元名称、进程树条目、日志输出，也不要截断状态、单元列表、作业列表和计时器列表输出中的单元描述
--show-types
	显示套接字时，显示套接字的类型
--job-mode=MODE
	在对新作业排队时，此选项控制如何处理已排队的作业。可取值 fail、replace、replace_irreversibly、isolate、ignore-dependencies、ignore-requirements 或 flush 之一。默认为 replace，除非使用了表示隔离作业模式的 isolate 命令
-i, --ignore-inhibitors
	当系统关闭或睡眠请求时，忽略约束锁，否则系统关闭或睡眠请求会失败。应用程序可以建立约束锁，以避免某些重要操作（如CD刻录或类似操作）被系统关闭或睡眠状态中断
-q, --quiet
	静默模式，抑制 snapshot, is-active, is-failed, is-enabled, is-system-running, enable 和 disable 命令的标准输出
--no-block
	不同步等待请求的操作完成。如果未指定该选项，验证完作业并排队，systemctl 将等待作业完成
--system
	与服务管理器（service manager）交互。为缺省选项
--no-wall
	在 halt, power-off, reboot 操作前不发出警告
--no-reload
	当与命令 enable 和 disable 一起使用时，不隐式重新加载守护程序的配置
--no-ask-password
	当与 start 和相关命令一起使用时，禁止请求密码
--kill-who=WHO
	与命令 kill 一起使用时，选择向哪个进程发送信号。必须是 main、control 或 all 中的一个，分别选择杀死主进程、控制进程还是单元的所有进程
-s, --signal=SIGNAL
	与命令 kill 一起使用，选择向进程发送的信号。缺省为 SIGTERM
-f, --force
	与 enable 一起使用时，覆盖任何现有冲突的符号链接。与 halt、poweroff、reboot 或 kexec 一起使用时，在不关闭所有单元的情况下执行所选操作
--now
	当与 enable 一起使用时，单元也将启动。当与 disable 或 mask 一起使用时，单元也将停止
--root=PATH
	当与 enable/disable/is-enabled（等相关命令）一起使用时，在查找单元文件时使用指定的根路径
--runtime
	当与 enable、disable、edit（等相关命令）一起使用时，只需临时进行更改，以便在下次系统重新启动时丢失这些更改
--preset-mode=MODE
	与命令 preset 或 preset-all 一起使用时，预设模式为 full（缺省）、enable-only 或 disable-only 三者之一
-n, --lines=NUM
	与命令 status 一起使用时，控制日志文件显示的行数。默认为 10
-o, --output=FORMAT
	与命令 status 一起使用时，控制日志条目的显示格式，默认为 short。其它取值可参考明林 journalctl(1)
--plain
	当与命令 list-dependencies 一起使用时，输出将打印为列表而不是树
-H, --host=HOST
	指定远程主机名，或用户名@主机名进行远程操作。机名可以选择用一个容器名作为后缀，用 : 分隔
-M, --machine=MACHINE
	指定本地容器名
--no-pager
	不将管道输出送到分页浏览工具
--no-legend
	不打印列头和列脚
-h, --help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.命令说明

实际上 systemctl 子命令的使用频率会比选项更加频繁，主要有单元命令（Unit Commands）、单元文件命令（Unit File Commands）、容器命令（Machine Commands）、作业命令（Job Commands）、快照命令（Snapshot Commands）、环境命令（Environment Commands）、管理器生命周期命令（Manager Lifecycle Commands）、系统命令（System Commands）
4.1 单元命令（Unit Commands）

list-units [PATTERN...]
	列出所有已启动的单元。如果指定一个或多个匹配模式，则只显示符合某个模式的单元。该命令为默认命令
list-sockets [PATTERN...]
	列出套接字单元，按照监听的地址排列输出。如果指定一个或多个匹配模式，则只显示符合某个模式的单元
list-timers [PATTERN...]
	列出按时间顺序排列的计时器单元。如果指定一个或多个匹配模式，则只显示符合某个模式的单元
start PATTERN...
	启动指定的单元
stop PATTERN...
	停止指定的单元
reload PATTERN...
	重新加载指定单元服务的配置文件。注意，是重新加载服务的配置，而不是 systemd 的单元配置文件。如果希望 systemd 重新加载单元的配置文件，请使用 daemon-reload 命令。换句话说：对于 Apache 的示例，这将在 web 服务器中重新加载 Apache 的 httpd.conf，而不是 apache.service systemd 单元文件
restart PATTERN...
	重启指定的单元
try-restart PATTERN...
	尝试重启指定的单元。如果单元不处于运行状态，则不进行重启
reload-or-restart PATTERN...
	重新加载指定单元服务的配置文件。如果失败则重启服务
reload-or-try-restart PATTERN...
	重新加载指定单元服务的配置文件。如果失败则尝试重启服务。如果单元不处于运行状态，则不进行重启
isolate NAME
	启动命令行中指定的单元及其依赖项，并停止所有其他的单元
kill PATTERN...
	向单元的一个或多个进程发送信号。使用 --kill who= 选择要终止的进程。使用 --signal= 选择要发送的信号
is-active PATTERN...
	检查指定单元是否处于 active 状态。如果至少一个是活动的，则返回退出代码 0，否则为非零
is-failed PATTERN...
	检查指定单元是否处于 failed 状态。如果至少一个是失败的，则返回退出代码 0，否则为非零
status [PATTERN...|PID...]
	显示一个或多个单元的简要运行时状态信息，然后是日志中的最新日志数据。如果未指定单位，则显示系统状态。如果与 --all 结合使用，还将显示所有单元的状态。如果给定 PID，则显示进程所属单元的信息
show [PATTERN...|JOB...]
	显示一个或多个单元、作业或管理器本身的属性。如果未指定参数，则将显示管理器的属性
cat PATTERN...
	显示一个或多个单元的配置文件
set-property NAME ASSIGNMENT...
	在运行时设置指定的单元属性。如果同时使用 --runtime 选项，则下一次系统重启属性将失效
help PATTERN...|PID...
	显示一个或多个单元的手册页（如果可用）。如果给定了PID，则显示该进程所属单元的手册页
reset-failed [PATTERN...]
	重置指定单元的 failed 状态，如果未指定单元名称，则重置所有单元的 failed 状态
list-dependencies [NAME]
	显示指定单元所依赖的单元。它递归地列出 Requires=、RequiresOverridable=、Requisite=、RequisiteOverridable=、Wants=、BindsTo= 依赖项之后的单元。如果未指定单位，缺省为 default.target

4.2 单元文件命令（Unit File Commands）

list-unit-files [PATTERN...]
	列出已安装的单元文件及其启用状态
enable NAME...
	启用一个或多个单元文件或单元文件实例。这将创建一些符号链接，记录在单元文件的 Install 部分。创建符号链接后，将重新加载 systemd 配置以确保立即生效
disable NAME...
	禁用一个或多个单元。这将从单元配置目录中删除指向指定单元文件的所有符号链接，从而撤消由 enable 所做的更改。移除符号链接后，将重新加载 systemd 配置以确保立即生效。注意，此命令不会隐式停止正在禁用的单元。如果需要的话，使用 --now 选项，要么在之后执行一个附加的 stop 命令
reenable NAME...
	重新启用一个或多个单元文件。这是 disable 和 enable 的组合，用于将启用单元的符号链接重置为单元文件 Install 部分中配置的值
preset NAME...
	重置指定单元文件的 disable/enable 状态为预设策略文件中配置的值。可以与选项 --preset-mode 联用选择重置的结果状态。关于预设策略格式的详细信息，参见 systemd.preset(5)
preset-all
	将所有已安装的单元文件重置为预设策略文件中配置的默认值。可以与选项 --preset-mode 联用选择重置的结果状态
is-enabled NAME...
	检查是否启用了指定的单元文件
mask NAME...
	屏蔽一个或多个单元文件，把这些单元链接到 /dev/null，使它们无法启动
unmask NAME...
	反屏蔽一个或多个单元文件
link FILENAME...
	将不在单元文件搜索路径中的单元文件链接到单元文件搜索路径中，这需要单元文件的绝对路径
add-wants TARGET NAME..., add-requires TARGET NAME...
	给指定单元添加依赖
edit NAME...
	编辑插入片段或使用选项 --full 表示替换整个文件，以扩展或重写指定的单元
get-default
	返回别名为 default.target 的单元
set-default NAME
	设置默认的单元，使 default.target 软链接到目标单元

4.3 容器命令（Machine Commands）

list-machines [PATTERN...]
	列出主机和所有正在运行的本地容器及其状态。如果指定了一个或多个模式，则只显示与其中一个模式匹配的容器

4.4 作业命令（Job Commands）

list-jobs [PATTERN...]
	
cancel JOB...
	列出正在进行的作业。如果指定了一个或多个模式，则只显示与其中一个模式匹配的单元的作业
cancel JOB...
	取消一个或多个指定作业 ID 的作业。如果未指定作业 ID，则取消所有挂起的作业

4.5 快照命令（Snapshot Commands）

snapshot [NAME]
	创建指定名称的快照。如果未指定快照名则自动生成。快照指的是 systemd 管理器的保存状态。它被实现为一个使用此命令动态生成的单元，并且依赖于当时活动的所有单元。稍后，用户可以使用快照单元上的 isolate 命令返回到该状态
delete PATTERN...
	删除快照

4.6 环境命令（Environment Commands）

show-environment
	显示 systemd manager 使用的环境变量
set-environment VARIABLE=VALUE...
	设置 systemd manager 使用的环境变量
unset-environment VARIABLE...
	取消一个或多个 systemd manager 的环境变量
import-environment [VARIABLE...]
	将客户端上设置的一个或多个环境变量导入 systemd manager 环境块。如果未传递参数，则导入整个环境块

4.7 管理器生命周期命令（Manager Lifecycle Commands）

daemon-reload
	重新加载 systemd 管理器配置。这将重新运行所有生成器（请参阅 systemd.generator（7）），重新加载所有单元文件，并重新创建整个依赖关系树。在重新加载守护进程时，所有 systemd 监听的代表用户配置的 sockets，保持可访问状态
daemon-reexec
	重新执行 systemd 管理器

4.8 系统命令（System Commands）

is-system-running
	检查系统是否正在运并返回当前的系统状态，状态有 initializing，starting，running，degraded，maintenance，stopping
default
	进入默认模式，等同于子命令 isolate default.target
rescue
	进入救援模式。等同于子命令 isolate rescue.target，会向所有用户打印警告消息
emergency
	进入紧急模式。等同于子命令 isolate emergency.target，会向所有用户打警告消息
halt
	关闭并停止系统。等同于子命令 start halt.target --irreversible
poweroff
	关闭并关闭系统电源。等同于子命令 start poweroff.target --irreversible，会向所有用户打印警告消息
reboot [arg]
	关闭并重新启动系统。等同于子命令 start reboot.target --irreversible，会向所有用户打印警告消息
kexec
	通过 kexec 关闭并重新启动系统。等同于子命令 start kexec.target --irreversible，会向所有用户打印警告消息
switch-root ROOT [INIT]
	切换到不同的根目录并在其下执行新的系统管理器进程
suspend
	暂停系统
hibernate
	使系统休眠。这将激活特殊的 hibernate.target 目标
hybrid-sleep
	休眠并挂起系统。这将激活特殊的 hybrid-sleep.target 目标

实际上，systemctl 常用的子命令并不多，主要有：

start	启动服务
stop	停止服务
restart	重启服务
enable	使某服务开机自启
disable	关闭某服务开机自启
status	查看服务状态
list-units -–type=service 列举所有已启动服务

5.常用示例

（1）使用 systemctl 管理系统。

# 重启系统
systemctl reboot

# 关闭系统，切断电源
systemctl poweroff

# CPU停止工作
systemctl halt

# 暂停系统
systemctl suspend

# 让系统进入冬眠状态
systemctl hibernate

# 让系统进入交互式休眠状态
systemctl hybrid-sleep

# 启动进入救援状态（单用户状态）
systemctl rescue

（2）使用 systemctl list-units 查看系统的单元。

# 列出正在运行的 unit
systemctl
# 或
systemctl list-units

# 列出所有 unit，包括没有运行的 unit
systemctl list-units --all

# 列出所有没有运行的 unit
systemctl list-units --all --state=inactive

# 列出所有加载失败的 unit
systemctl list-units --failed

# 列出所有正在运行的、类型为 service 的 unit
systemctl list-units --type=service

（3）使用 systemctl status 查看系统状态和单个 unit 的状态。

# 显示系统状态
systemctl status

# 显示单个 unit 的状态
sysystemctl status sshd.service

# 显示远程主机的某个 unit 的状态
systemctl -H root@rhel7.example.com status httpd.service

（4）服务管理。

# 启动一个服务
systemctl start apache.service

# 停止一个服务
systemctl stop apache.service

# 重启一个服务
systemctl restart apache.service

# 杀死一个服务的所有子进程
systemctl kill apache.service

# 重新加载一个服务的配置文件
systemctl reload apache.service

# 重新加载 systemd 管理器配置
systemctl daemon-reload

# 显示某个 unit 的所有底层参数
systemctl show httpd.service

# 显示某个 unit 的指定属性的值
systemctl show -p CPUShares httpd.service

# 设置某个 unit 的指定属性
systemctl set-property httpd.service CPUShares=500

（5）查看 unit 之间的依赖关系。
A 依赖于 B，意味着 systemd 在启动 A 的时候，同时会去启动 B。

# 列出一个 Unit 的所有依赖
$ systemctl list-dependencies nginx.service

上面命令的输出结果之中，有些依赖是 Target 类型，默认不会展开显示。如果要展开 Target，就需要使用 --all 参数。

systemctl list-dependencies --all nginx.service

（6）设置服务开机启动。
systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。systemctl enable命令用于在上面两个目录之间，建立符号链接关系。

systemctl enable sshd.service
# 等同于
ln -s /usr/lib/systemd/system/sshd.service /etc/systemd/system/multi-user.target.wants/sshd.service'

如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。与之对应的，systemctl disable 命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。

systemctl disable sshd.service

配置文件的后缀名，就是该 unit 的种类，比如 sshd.socket。如果省略，systemd 默认后缀名为 .service，所以 sshd 会被理解成 sshd.service。
6.拓展知识
6.1 Unit
6.1.1 配置文件的格式

systemd 可以管理所有系统资源，不同的资源统称为单元（unit）。unit 一共分成 12 种。

Service unit：系统服务
Target unit：多个 Unit 构成的一个组
Device Unit：硬件设备
Mount Unit：文件系统的挂载点
Automount Unit：自动挂载点
Path Unit：文件或路径
Scope Unit：不是由 Systemd 启动的外部进程
Slice Unit：进程组
Snapshot Unit：Systemd 快照，可以切回某个快照
Socket Unit：进程间通信的 socket
Swap Unit：swap 文件
Timer Unit：定时器

每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。配置文件就是普通的文本文件，可以用文本编辑器打开，也可以使用 systemctl cat 命令查看配置文件的内容。

systemctl cat sshd.service

# /usr/lib/systemd/system/sshd.service
[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service

[Service]
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target

从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。每个区块内部是一些等号连接的键值对。注意，键值对的等号两侧不能有空格。
6.1.2 配置文件的区块

[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。

Description：简短描述
Documentation：文档地址
Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败
Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败
BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行
Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动
After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动
Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行
Condition...：当前 Unit 运行必须满足的条件，否则不会运行
Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败

[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。

Type：定义启动时的进程行为。它有以下几种值。
Type=simple：默认值，执行ExecStart指定的命令，启动主进程
Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出
Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行
Type=dbus：当前服务通过D-Bus启动
Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行
Type=idle：若有其他任务执行完毕，当前服务才会运行
ExecStart：启动当前服务的命令
ExecStartPre：启动当前服务之前执行的命令
ExecStartPost：启动当前服务之后执行的命令
ExecReload：重启当前服务时执行的命令
ExecStop：停止当前服务时执行的命令
ExecStopPost：停止当其服务之后执行的命令
RestartSec：自动重启当前服务间隔的秒数
Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog
TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数
Environment：指定环境变量

[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。

WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中
RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中
Alias：当前 Unit 可用于启动的别名
Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit

6.1.3 配置文件的状态

systemctl list-unit-files 命令用于列出所有配置文件。

# 列出所有配置文件
$ systemctl list-unit-files

# 列出指定类型的配置文件
$ systemctl list-unit-files --type=service

这个命令会输出一个列表。

systemctl list-unit-files

UNIT FILE              STATE
chronyd.service        enabled
clamd@.service         static
clamd@scan.service     disabled

这个列表显示每个配置文件的状态，一共有四种。

enabled：已建立启动链接
disabled：没建立启动链接
static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖
masked：该配置文件被禁止建立启动链接

注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的 systemctl status 命令。

systemctl status sshd.service

一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。

systemctl daemon-reload
systemctl restart httpd.service

6.2 Target

启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。

简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于"状态点"，启动某个 Target 就好比启动到某种状态。

传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。

# 查看当前系统的所有 Target
systemctl list-unit-files --type=target

# 查看一个 Target 包含的所有 Unit
systemctl list-dependencies multi-user.target

# 查看启动时的默认 Target
systemctl get-default

# 设置启动时的默认 Target
systemctl set-default multi-user.target

# 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程
systemctl isolate multi-user.target

Target 与 传统 RunLevel 的对应关系如下。

Traditional runlevel      New target name     Symbolically linked to...

Runlevel 0           |    runlevel0.target -> poweroff.target
Runlevel 1           |    runlevel1.target -> rescue.target
Runlevel 2           |    runlevel2.target -> multi-user.target
Runlevel 3           |    runlevel3.target -> multi-user.target
Runlevel 4           |    runlevel4.target -> multi-user.target
Runlevel 5           |    runlevel5.target -> graphical.target
Runlevel 6           |    runlevel6.target -> reboot.target

它与init进程的主要差别如下。

（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到 graphical.target（图形界面）或者multi-user.target（多用户命令行）。

（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。

（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。
6.3 日志管理

Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是 /etc/systemd/journald.conf。

journalctl 功能强大，用法非常多。

# 查看所有日志（默认情况下，只保存本次启动的日志）
journalctl

# 查看内核日志（不显示应用日志）
journalctl -k

# 查看系统本次启动的日志
journalctl -b
journalctl -b -0

# 查看上一次启动的日志（需更改设置）
journalctl -b -1

# 查看指定时间的日志
journalctl --since="2012-10-30 18:17:16"
journalctl --since "20 min ago"
journalctl --since yesterday
journalctl --since "2015-01-10" --until "2015-01-11 03:00"
journalctl --since 09:00 --until "1 hour ago"

# 显示尾部的最新10行日志
journalctl -n

# 显示尾部指定行数的日志
journalctl -n 20

# 实时滚动显示最新日志
journalctl -f

# 查看指定服务的日志
journalctl /usr/lib/systemd/systemd

# 查看指定进程的日志
journalctl _PID=1

# 查看某个路径的脚本的日志
$ sudo journalctl /usr/bin/bash

# 查看指定用户的日志
journalctl _UID=33 --since today

# 查看某个 Unit 的日志
journalctl -u nginx.service
journalctl -u nginx.service --since today

# 实时滚动显示某个 Unit 的最新日志
journalctl -u nginx.service -f

# 合并显示多个 Unit 的日志
$ journalctl -u nginx.service -u php-fpm.service --since today

# 查看指定优先级（及其以上级别）的日志，共有 8 级
# 0: emerg
# 1: alert
# 2: crit
# 3: err
# 4: warning
# 5: notice
# 6: info
# 7: debug

journalctl -p err -b

# 日志默认分页输出，--no-pager 改为正常的标准输出
journalctl --no-pager

# 以 JSON 格式（单行）输出
journalctl -b -u nginx.service -o json

# 以 JSON 格式（多行）输出，可读性更好
journalctl -b -u nginx.serviceqq -o json-pretty

# 显示日志占据的硬盘空间
journalctl --disk-usage

# 指定日志文件占据的最大空间
journalctl --vacuum-size=1G

# 指定日志文件保存多久
journalctl --vacuum-time=1years

●ifconfig 命令：
1.命令简介

ifconfig（configure a network interface）命令是系统管理员命令，用于查看和配置网络接口。
2.命令格式

ifconfig [-v] [-a] [-s] [INTERFACE]
ifconfig [-v] INTERFACE [aftype] OPTIONS | ADDRESS ...

不跟任何选项和参数单独执行 ifconfig 命令将显示当前活动接口的状态。如果给定一个接口参数，则它仅显示给定接口的状态。如果只给一个选项 -a，它将显示所有接口的状态，包括那些关闭的接口。其他情况，用于配置一个网络接口。
3.选项说明

-a
	显示所有接口的状态，包括那些关闭的接口
-s
	显示接口简短状态列表，类似于 netstat -i
-v
	冗余模式，遇到错误将报告错误信息
INTERFACE
	接口的名称。这通常是一个驱动程序名，后面跟着一个单元号，例如用于第一个以太网接口的 eth0
up
	此标志将导致激活接口。如果将地址分配给接口，则会隐式激活接口
down
	此标志用于关闭接口的驱动程序
[-]arp
	启用或关闭接口使用 ARP 协议
[-]promisc
	启用或禁用接口的混杂模式。如果选中，网络上的所有数据包都将由接口接收
[-]allmulti
	启用或禁用所有多播模式。如果选中，则接口将接收网络上的所有多播数据包
mtu N
	设置接口的最大传输单元
dstaddr ADDR
	为点对点链路（如 PPP）设置远程 IP 地址。关键字 dstaddr 现在已经过时了，使用 pointopoint 关键字代替
netmask ADDR
	设置接口的 IP 网络掩码。此值默认为通常的 A、B 或 C 类网络掩码（从接口 IP 地址派生），但可以设置为任何值
add ADDR/PREFIX_LEN
	向接口添加 IPv6 地址
del ADDR/PREFIX_LEN
	从接口中删除 IPv6 地址
tunnel ::aa.bb.cc.dd
	创建一个新的SIT(IPv6-in-IPv4)设备，通过隧道到达给定的目的地
irq ADDR
	设置此设备使用的中断行。并非所有设备都可以动态更改其 IRQ 设置
io_addr ADDR
	为该设备设置 I/O 空间中的起始地址
mem_start ADDR
	设置此设备使用的共享内存的起始地址。只有少数几个设备需要这个
media TYPE
	设置设备要使用的物理端口或介质类型。典型的类型值有10base2（细以太网）、10baseT（双绞线 10Mbps 以太网）、AUI（外部收发器）等。特殊的媒体类型可以使用 auto 来告诉驱动程序进行自动感知。注意，并非所有设备都可以更改此设置
[-]broadcast [ADDR]
	如果给定地址参数，则为该接口设置协议广播地址。否则设置（或清除）接口的 IFF_BROADCAST标志
[-]pointopoint [ADDR]
	这个关键字启用了接口的点对点模式，这意味着它是两台机器之间的直接连接，没有其他人监听它。如果给了地址参数，就像过时的 dstaddr 关键字一样，设置另一端的协议地址。否则设置或清除接口的 IFF_POINTOPOINT 标志
hw CLASS ADDR
	如果设备驱动程序支持此操作，则设置此接口的物理地址。CLASS 为硬件类型名称，ADDR 为物理地址。目前支持的硬件类包括 ether (Ethernet)、ax25 (AMPR AX.25)、ARCnet 和 netrom (AMPR NET/ROM)
multicast
	在接口上设置多播标志。一般不需要显示设置，因为驱动程序本身会设置正确的标志
ADDRESS
	接口的 IP 地址
txqueuelen LENGTH
	设置设备的传输队列的长度。对于具有高延迟（调制解调器链路，ISDN）的较慢设备，将其设置为小值是有用的，以防止快速批量传输过多地干扰诸如 telnet 之类的交互通信

4.常用示例

（1）查看处于激活状态的网络接口信息。

ifconfig
eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:1E:51  
          inet addr:10.160.7.81  Bcast:10.160.15.255  Mask:255.255.240.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0
          TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:3607197869 (3.3 GiB)  TX bytes:6115042 (5.8 MiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:56103 errors:0 dropped:0 overruns:0 frame:0
          TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:5079451 (4.8 MiB)  TX bytes:5079451 (4.8 MiB)

eth0 表示第一块网卡。

第一行 Link encap:Ethernet 表示连接类型为以太网，HWaddr 00:16:3E:00:1E:51 为网卡的物理地址；
第二行 inet addr:10.160.7.81 为网卡的 IPv4 地址，Bcast:10.160.15.255 为广播地址，Mask:255.255.240.0 为子网掩码；
第三行 UP（代表网卡开启状态），BROADCAST（支持广播），RUNNING（代表网卡的网线被接上），MULTICAST（支持组播），MTU:1500（最大传输单元 1500 字节），Metric:1 表示网卡路由数据包优先级，数值越低，优先级越高；
第四、五行：接收、发送数据包情况统计；
第七行：接收、发送数据字节数统计信息。

lo 是表示主机的回环地址，这个一般是用来测试一个网络程序，只能在本机上访问，局域网或外网的主机无法访问该地址。

（2）查看所有网络接口信息，不论其是否激活。

ifconfig -a

（3）查看指定网络接口信息。

ifconfig eth0

（4）启动和关闭指定网卡。

# 启动网卡
ifconfig eth0 up
# 关闭网卡
ifconfig eth0 down

（5）修改 MAC 地址。

ifconfig eth0 down
ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE
ifconfig eth0 up

（6）配置 IP 地址。

# 给 eth0 网卡配置 IP 地址
ifconfig eth0 192.168.1.56

# 给 eth0 网卡配置 IP 地址并加上子网掩码
ifconfig eth0 192.168.1.56 netmask 255.255.255.0 

# 给 eth0 网卡配置 IP 地址，加上子网掩码，加上广播地址
ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255

（7）启用和关闭 ARP 协议。

# 开启网卡 eth0 的 arp 协议
ifconfig eth0 arp
# 关闭网卡 eth0 的 arp 协议
ifconfig eth0 -arp

（8）设置最大传输单元。

# 设置能通过的最大数据包大小为 1500 bytes
ifconfig eth0 mtu 1500

（9）添加和删除 IPv6 地址。

# 添加 IPv6 地址
ifconfig eth0 add 3ffe:3240:800:1005::2/64

# 删除 IPv6 地址
ifconfig eth0 del 3ffe:3240:800:1005::2/64

●ping 命令：
1.命令简介

ping（Packet Internet Groper 命令是因特网包探索器，用于测试网络连通性，是常用的网络命令之一。

ping 命令用于向指定的网络主机发送特殊数据报 IMCP 回应请求报文（IMCP ECHO_REQUEST），多数网络设备收到该数据包后会回应 ICMP 回应回复报文 （ICMP Echo-Reply），以此来验证网络连接是否正常。

注意：Linux 系统下的 ping 命令与 Windows 系统下的 ping 命令稍有不同。Windows 下运行 ping 命令一般会发出 4 个请求就结束运行该命令；而 Linux 下不会自动终止，此时需要我们按 Ctrl+C 终止或者使用 -c 参数为 ping 命令指定发送的请求数目。
2.命令格式

ping
ping [OPTIONS] DESTINATION

不跟参数单独执行 ping 命令将显示简短用法。其中参数为零到多个，目标主机可以是主机 IP 或者域名。
3.选项说明

-4
	只使用 IPv4
-6
	只使用 IPv6
-A
	探测包发送间隔自适应往返时间，这样网络中存在的未应答的探测请求一般不会超过一个
-a
　　每次发送数据时发出鸣响（Audible）
-B
	不允许 ping 改变包头的源地址
-b
	允许 ping 一个广播地址
-c COUNT
　　发送 count 个 ECHO_REQUEST 数据包后结束 ping 程序
-D
	在每行前打印时间戳
-d
　　使用 socket 的 SO_DEBUG 选项。实际上，Linux 内核不使用这个套接字选项
-F FLOW_LABEL
	仅 IPv6 有效。为请求包分配一个 20 比特的 flow label。如果 FLOW_LABEL 为 0，内核会随机分配
-f
　　采用洪泛模式大量且快速地向目标发送数据包。如果发送间隔没有设置，则默认设置为 0，并按照报文接受的速度和一百次每秒的速度来发送报文（以最快的为准）。只有超级用户能够将此选项和 -i 0 选项一起使用
-h
	显示帮助信息
-I INTERFACE
　　使用指定的网络接口地址发送数据包
-i INTERVAL
　　每隔 INTERVAL 秒发送一次数据包，默认一秒 ping 一次。只有超级用户可以将间隔设置为小于0.2 秒的值
-L
	抑制组播报文回送，只适用于 ping 的目标为一个组播地址
-l PRELOAD
	在没有接受到回复报文之前能发送的最多报文。非超级用户最多只能设置为 3
-M PMTUDISC_OPT
	选择 Path MTU Discovery 策略模式。PMTUDISC_OPT 取值可以为 do（不允许分段，甚至不允许在本地分段）、want（找出 PMTU，在如果包太大就在本地分段） 或 dont（不要设置 IP 包首部中的 DF 位，即允许分段）
-m MARK
	使用标记来标记发送的数据包
-n
　　只输出主机 IP 地址，不通过查询 DNS 获知 IP 地址对应的主机名，以节省时间
-O
	在发送下一个数据包之前报告未完成的 ICMP Echo 请求
-p PATTERN
　　最多指定 16 个字节去填充发送的数据包，这对于诊断网络中数据依赖问题很有用。例如，-p ff 会将所有的填充数据设置为 1
-Q TOS
 	用来设置服务质量（Quality of Service ）。ICMP 协议有一个 8 bits 的区分服务（Differentiated Services）。低两位用于分离数据，高 6 位表示区分服务，一般有最小时延、最大吞吐量、最高可靠性、最小代价
-q
　　静态输出。仅程序启动和结束时显示摘要行
-R
　　记录路由过程
-r
　　忽略正常的路由表，而直接向主机发送数据包。如果目标主机不再直连的网络上，则返回异常
-S SNDBUF
		设置套接字的发送缓冲区大小。如果没有设置，则被设定为不超过一个报文长度
-s PACKETSIZE
　　指定要发送的数据的字节数。默认是 56 字节，与 8 字节的 ICMP 头部结合刚好是 64 字节的 ICMP 数据包
-T TIMESTAMP_OPTION
	设置 IP 报文的时间戳选项。选项可以是以下三种：
	（1）-T tsonly 只记录时间戳；
	（2）-T tsandaddr 收集时间戳和 IP 地址；
	（3）-T tsprespec [host1 [host2 [host3[host4]]]] 收集来自预定的网络地址的时间戳
-t TTL
　　设置 IP 包的 TTL 值
-U
	打印完整的用户对用户延迟
-V
	显示版本信息并退出
-v
　　详细模式输出
-W TIMEOUT
　　设置等待 ICMP 响应的超时时间，单位秒
-w DEADLINE
　　ping 程序在 DEADLINE 秒后退出，不管发送或接收多少数据包

4.常用示例

（1）显示 ping 的简要用法。

ping
Usage: ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]
            [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]
            [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]
            [-w deadline] [-W timeout] [hop1 ...] destination

（2）测试能否 ping 通 IP。

ping 9.134.114.170
PING 9.134.114.170 (9.134.114.170) 56(84) bytes of data.
64 bytes from 9.134.114.170: icmp_seq=1 ttl=64 time=0.033 ms
64 bytes from 9.134.114.170: icmp_seq=2 ttl=64 time=0.040 ms
...

回包正常，表示网络链路通畅。

（3）测试能否 ping 通域名。

ping baidu.com
PING baidu.com (220.181.38.148) 56(84) bytes of data.
64 bytes from 220.181.38.148: icmp_seq=1 ttl=249 time=39.4 ms
64 bytes from 220.181.38.148: icmp_seq=2 ttl=249 time=39.3 ms
...

回包正常，表示网络链路通畅。

（4）每隔 0.5 秒 ping 一次，一共 ping 3 次。

ping -i 0.5 -c 3 baidu.com
PING baidu.com (220.181.38.148) 56(84) bytes of data.
64 bytes from 220.181.38.148: icmp_seq=1 ttl=249 time=39.3 ms
64 bytes from 220.181.38.148: icmp_seq=2 ttl=249 time=39.3 ms
64 bytes from 220.181.38.148: icmp_seq=3 ttl=249 time=39.3 ms

--- baidu.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 39.375/39.390/39.399/0.010 ms

下面简单地介绍一下 ping 产生的响应内容的含义：

PING baidu.com (220.181.38.148) 56(84) bytes of data.
	表示 ping 目标主机的域名和 IP，以及不带包头的包大小和带包头的包大小，参考 -s 选项

64 bytes from 220.181.38.148: icmp_seq=1 ttl=249 time=39.3 ms
64 bytes from 220.181.38.148: icmp_seq=2 ttl=249 time=39.3 ms
64 bytes from 220.181.38.148: icmp_seq=3 ttl=249 time=39.3 ms
	icmp_seq：ping 序列，从 1 开始；如果数字不是按顺序递增也就意味着丢包了
	ttl：剩余的 ttl；见下文的 TTL 解释
	time: 响应时间，数值越小，通信速度越快

3 packets transmitted, 3 received, 0% packet loss, time 1001ms
	发出去的包数，返回的包数，丢包率，总耗费时间

rtt min/avg/max/mdev = 39.375/39.390/39.399/0.010 ms
	最小/最大/平均响应时间和本机硬件耗费时间

（5）综合实例，每隔 0.5 秒 ping 一次，一共 ping 3 次，并且设置发送包的大小为 1024 和 TTL 值为 255。

ping -i 0.5 -c 3 -s 1024 -t 255 baidu.com
PING baidu.com (39.156.69.79) 1024(1052) bytes of data.
1032 bytes from 39.156.69.79: icmp_seq=1 ttl=249 time=44.8 ms
1032 bytes from 39.156.69.79: icmp_seq=2 ttl=249 time=40.5 ms
1032 bytes from 39.156.69.79: icmp_seq=3 ttl=249 time=40.4 ms

--- baidu.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 40.441/41.927/44.810/2.045 ms

（6）综合实例，使用 -i 指定发送数据包时间间隔，-c 指定一共发送多少个数据包，-I 指定源地址，-q 直接显示程序的启动和最后结果。

ping -i 0.2 -c 3 -I 9.134.114.170 baidu.com -q
PING baidu.com (39.156.69.79) from 9.134.114.170 : 56(84) bytes of data.

--- baidu.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 400ms
rtt min/avg/max/mdev = 40.476/40.541/40.588/0.171 ms

（7）以最快的速度，使用最大的包进行 ping，可用于测试目标主机的承压能力。

ping -f -s 65507 baidu.com

注意：此用法非常危险，65535（包头+内容）*100个包每秒=6.25MB，每秒发送 6.25MB 的数据，相当于 50Mbps 的带宽，完全可能导致目标主机拒绝服务，请谨慎使用。

（8）ping 不通的情况。

ping -c 3 9.9.9.9
PING 9.9.9.9 (9.9.9.9) 56(84) bytes of data.

--- 9.9.9.9 ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 1999ms

ping 不通目标主机的常见原因有：

No Answer：原因可能是，对方主机没工作，双方网络配置不正确，路由问题等
Request Time Out：对方主机已关机，路由问题或对端防火墙设置禁止ping
Unknown Host Name：DNS设置问题，或者对方主机不存在
Destination Net Unreachable：双方没有建立连接，或对方主机不存在
Bad IP Address：IP 地址不存在或 IP 不能被 DNS 服务器解析
transmit failed，error code：网卡驱动问题
no rout to host：网卡工作不正常
Ping 127.0.0.1 如果ping不通，表明本地机 TCP/IP 协议不能正常工作

5.拓展知识
5.1 TTL

当我们在使用 ping 命令时，返回结果里会带一个 TTL 值。这个东西的含义其实就是Time To Live，指的是报文在网络中能够存活的限制。以前这个限制方式是设定一个时间（Time To Live中的Time就是这样来的），当报文在网络中转发时，时间超过这个限制，最后一个收到报文的‘路由点’就会把它扔掉，而不继续转发。后来把时间限制改为了跳数限制，就是当报文在网络中转发时，每经过一个‘路由点‘，就把预先设定的这个TTL数值减 1，直到最后 TTL=1 时报文就被扔掉，不向下转发。

路由点：我这里是指完成路由功能的机器，因为并不是只有路由器才可以完成路由转发功能，比如主机可以配置路由转发。

所以，回包中的 TTL 表示目标主机返回的报文到达本机后，从它预设的 TTL 值减小到现在的值。
5.2 开启和禁用 ping 响应

有时为了保护主机，很多时候我们需要禁止 ICMP 协议，在这种情况下，终端再使用ping命令检测，服务器不会再做出任何响应。

（1）临时开启 ping。

echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all

（2）临时禁用 ping。

echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all 

（3）永久禁用 ping。在配置文件 /etc/sysctl.conf 中增加如下一行。修改完成后执行sysctl -p使新配置生效

net.ipv4.icmp_echo_ignore_all=1          # 1 表示禁止

（4）永久开启 ping。在配置文件 /etc/sysctl.conf 中增加如下一行。修改完成后执行 sysctl -p 使新配置生效。

net.ipv4.icmp_echo_ignore_all=0          # 0 表示允许

●help 命令（builtin）：
1.命令简介

help 命令是 Bash 内建命令，用于查看 Bash 内部命令的帮助信息。

help 命令只能显示 Bash 内部命令的帮助信息，对于外部命令的帮助信息需要使用 man 或 info 命令查看。
2.命令格式

help [-dms] [PATTERN...]

PATTERN 用于匹配命令，如果有与模式匹配的命令，help 返回状态为 0，否则为非 0。
3.选项说明

-d
	输出每个命令的简短描述
-m
	以类似于 man 手册的格式描述命令
-s
	只显示命令使用格式

4.常用示例

（1）查看 help 自身的帮助信息。

help help

（2）以类似于 man 手册格式查看 help 命令的帮助信息。

help -m help

（3）查看 help 命令的简短描述。

help -d help
help - Display information about builtin commands.

（4）查看 help 和 cd 命令使用格式。

help -s help cd
help: help [-dms] [pattern ...]
cd: cd [-L|[-P [-e]]] [dir]

●alias 命令（builtin）：
1.命令简介

alias 是 Bash 内建命令，用来设置命令的别名。

我们可以使用 alias 命令将一些较长的命令进行简化，建议使用单引号将原来的命令引起来，防止特殊字符导致错误。

alias 命令的作用只局限于当前会话，若要每次登录都能够使用这些命令别名，则可将相应的 alias 命令放到 Bash 的初始化文件 /etc/bashrc（针对所有用户）或 ~/etc/.bashrc（针对当前用户）中。
2.命令格式

alias [-p] [NAME[=VALUE] ...]

不带参数或使用 -p 选项将在标准输出上以 “alias name=value” 的形式打印别名列表。对于参数列表中没有提供值的每个名称，将打印别名和对应的值，否则设置别名对应的值。
3.选项说明

-p
	以可重用的格式 alias name=value 打印所有已定义的别名

4.常用示例

（1）以可重用的格式 alias name=value 打印所有已定义的别名。

alias
# 或
alias -p

alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'


（2）查看指定命令的别名。

alias ll
alias ll='ls -l --color=auto'

（3）设置命令别名。

alias ll="ls -l --color=auto -h"

●unalias 命令（builtin）：
1.命令简介

unalias 命令是为 Bash 内建命令，用来删除命令别名。
2.命令格式

alias [-a] [NAME...]

如果使用 -a 选项，则表示取消所有已经存在的命令别名。如果需要取消任意一个命令别名，则使用该命令别名作为指令的参数即可。
3.选项说明

-a 删除所有的别名定义

4.常用示例

（1）删除指定别名。

# 先查看别名 ls
alias ls
alias ls='ls --color=auto'

# 删除别名 ls
unalias ls

# 再查看别名 ls，无法找到别名，表示删除成功
alias ls
-bash: alias: ls: not found

（2）删除所有别名。

unalias -a

删除后的别名将无法使用，请谨慎操作。

●seq 命令：
1.命令简介

seq（Sequence） 命令用于按照指定步长产生从起始数到结束数之间的所有整数。起始数和步长可使用默认值 1，结束数必须指定。
2.命令格式

seq [OPTION]... LAST
seq [OPTION]... FIRST LAST
seq [OPTION]... FIRST INCREMENT LAST

3.选项说明

注意，长选项的强制性参数对于短选项也是强制的。

-f, --format=FORMAT
	使用 printf 样式的浮点格式
-s, --separator=STRING
	使用指定字符串分隔数字（默认：\n）
-w, --equal-width
	在数字添加 0 使得宽度相同
--help
	显示帮助信息并退出
--version
	显示版本信息并退出

4.常用示例

（1）输出 1~5。

seq 5
# 或
seq 1 5
# 或
seq 1 1 5
1
2
3
4
5

（2）按照步长 10 生成从 10 到 50 的整数序列。

seq 10 10 50
10
20
30
40
50

（3）按照指定格式 num%03g 格式输出。num 为前置字符串，%03g 表示数字宽度为 3，不足前置补 0。

seq -f"num%03g" 3
num001
num002
num003

（4）前置补 0 使得数字宽度相同。

seq -w 9 11
09
10
11

注意，当输出等宽字符串时不能再指定格式字符串，即 -w 与 -f 不能一起用。

（5）使用指定字符串分隔数字。

seq -w -s "," 9 11
09,10,11

（6）使用 Tab 分隔数字。

seq -s "`echo -e '\t'`" 9 11
9	10	11

先用命令做成一个 Tab，然后再指定成分隔符。

●nl 命令：
1.命令简介

nl（number line）命令用于计算文件的行号并将带有行号的内容输出到标准输出。相比于命令 cat -n，nl 可以对行号做比较多的显示设计，包括位数与是否自动补齐 0 等功能。
2.命令格式

nl [OPTION]... [FILE]...

在没有文件或文件是 - 时，从标准输入读取内容。
3.选项说明

注意，长选项的强制性参数对于短选项也是强制的。

-b, --body-numbering=STYLE
	使用指定样式给文件的正文行编号。STYLE 可取值如下：
	a：给所有行编号，不论其是否为空行（类似 cat -n）
	t：只给非空行编号
	n：不编行
	pBRE：只给包含基本正则表达式（basic regular expression，BRE）的行编号
-d, --section-delimiter=CC
	使用 CC 作为逻辑页分隔符
-f, --footer-numbering=STYLE
	使用指定样式给文件的页脚行编号。STYLE 可取值同上
-h, --header-numbering=STYLE
	使用指定样式给文件的页脚行编号。STYLE 可取值同上
-i, --line-increment=NUMBER
	使用指定增量增加行号
-l, --join-blank-lines=NUMBER
	将指定数量的一组空行视为 1 行
-n, --number-format=FORMAT
	指定行号格式，FORMAT 主要有三种：
	ln：左对齐，无前导 0
	rn：右对齐，无前导 0
	rz：右对齐，有前导 0 
-p, --no-renumber
	不要重置每个区段的行号
-s, --number-separator=STRING
	可能的话在行号后添加字符串
-v, --starting-line-number=NUMBER
	设置每个区段的第一行的行号
-w, --number-width=NUMBER
	行号栏位的占用的位数
--help
	显示此帮助并退出
--version
	显示版本信息并退出 

nl 不带任何选项执行时，使用如下默认选项：

-bt -d'\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6

CC 是用于分隔逻辑页数的两个分界符，如果要指定 “”， 请输入 “\”。
4.常用示例

给定文件 test.txt 用于测试，内容如下：

testtxt1
testtxt2
	
testtxt3

（1）使用默认选项给 test.txt 文件编号并输出。

nl test.txt
     1	testtxt1
     2	testtxt2
       
     3	testtxt3

（2）显示行号，指定对齐方式。

# 左对齐，无前导 0
nl -nln test.txt
1     	testtxt1
2     	testtxt2
       
3     	testtxt3

# 右对齐，无前导 0
nl -nrn test.txt
     1	testtxt1
     2	testtxt2
       
     3	testtxt3

# 右对齐，有前导 0
nl -nrz test.txt
000001	testtxt1
000002	testtxt2
       
000003	testtxt3

（3）指定宽度为 4 位，默认为 6 位。

nl -nrz -w4 test.txt
0001	testtxt1
0002	testtxt2
     
0003	testtxt3

（4）空行显示行号。

nl -nrz -w4 -ba test.txt
0001	testtxt1
0002	testtxt2
0003	
0004	testtxt3

（5）设置行号增量为 2。

nl -nrz -w4 -ba -i2 test.txt
0001	testtxt1
0003	testtxt2
0005	
0007	testtxt3

●rev 命令：
1.命令简介

rev（reverse）命令用于将文件中的每行内容以字符为单位反序输出，即第一个字符最后输出，最后一个字符最先输出，以此类推。
2.命令格式

rev [OPTION] [FILE...]

如果没有指定文件，则读取标准输入。
3.选项说明

-V, --version
	显示版本信息并退出
-h, --help
	显示帮助信息并退出

4.常用示例

给定文件 test.txt 用于测试，内容如下：

abcdefg
1234567

（1）反序显示文件的每行内容。

rev test.txt
gfedeba
7654321

（2）反序显示从标准输入读取的内容。

rev
dablelv
vlelbad

每输入一行内容后，键入回车将显示反序后的内容。键入 Ctrl + d 结束输入。

●tac 命令：
1.命令简介

tac（cat 的反序）命令以行为单位反序输出文件内容，即第一行最后显示，最后一行先显示。输出内容和 cat 命令相反。
2.命令格式

tac [OPTION]... [FILE]...

如果没有文件或文件是 -，读取标准输入。
3.选项说明

长选项的强制性参数对于短选项也是强制的。

-b, --before
	在行前而非行尾添加分隔标志
-r, --regex
 	将分隔标志视作正则表达式来解析
-s, --separator=STRING
  	指定字符串代替换行符作为行分隔标志
--help
 	显示帮助信息并退出
--version
 	显示版本信息并退出

4.常用示例

给定文件 file1 和 file2 用于测试，内容分别是：
file1 内容：

123
456
789

file2 内容：

abc
def

（1）反向查看文件内容。

tac file1
789
456
123

（2）反向查看文件内容，以字符串 b 作为行分隔符。

tac -s"b" file2
c
def
ab

（3）连接文件 file1 和 file2 到 file3。

tac file1 file2 > file3

cat file3
789
456
123
def
abc

●gzip 命令：
1.命令简介

gzip（GNU zip）命令用来压缩和解压缩文件，是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，采用 Deflate（LZ77 + 哈夫曼编码）无损压缩算法压缩为后缀为 .gz 的 gzip 文件。

gzip 不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和 tar 命令一起构成 Linux 操作系统中比较流行的压缩文件格式。据统计，gzip 命令对文本文件有 60%～70% 的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。
2.命令格式

gzip [ -acdfhlLnNrtvV19 ] [-S SUFFIX] [ NAME... ]

3.选项说明

-a --ascii
	使用 ASCII 文字模式。在转换行末字符时使用本地约定。此选项仅在某些非 Unix 系统上支持。对于 MSDOS，压缩时将 CR LF 转换为 LF，解压缩时将 LF 转换为 CR LF
-c, --stdout, --to-stdout
	把压缩后的文件输出到标准输出，不去变更原始文件
-d, --decompress, --uncompress
	解压缩
-f, --force
	强制压缩或解压缩，即使文件具有多个链接或相应的文件已经存在，或者压缩数据是从终端读取或写入终端的
-h, --help
	显示帮助信息并退出
-l, --list
	列出压缩文件的相关信息
-L, --license
	显示版权信息并退出
-n, --no-name
	压缩文件时，不保存原来的文件名称及时间戳。解压缩时，即使原文件名和时间戳存在也不还原。该选项为解压缩时的默认选项
-N, --name
	压缩时，始终保存原始文件名和时间戳；这是默认的。解压缩时，如果存在，则恢复原始文件名和时间戳。此选项对于限制文件名长度的系统或在文件传输后丢失时间戳的系统非常有用
-q, --quiet
	不显示警告信息
-r, --recursive
	递归处理，将指定目录下的所有文件及子目录一并处理
-S, --suffix=SUFFIX
	更改压缩后解压缩后的文件的后缀名
-t, --test
	测试压缩文件是否正确无误
-v, --verbose
	显示指令执行过程
-V, --version
	显示版本信息并退出
-#, --best, --fast
	指定压缩效果。压缩率是一个介于 1~9 的数值，数值越大，压缩率越高，压缩速度越低，缺省为 6。--best 等同于 -9，--fast 等同于 -1

4.常用示例

（1）不保留原文件压缩。

gzip /etc/passwd

压缩后的 /etc/passwd 将变为 /etc/passwd.gz。

（2）保留原文件压缩。

gzip -c /etc/passwd > passwd.gz

（3）压缩时显示指令执行过程。

gzip -v /etc/passwd
/etc/passwd:	 57.9% -- replaced with /etc/passwd.gz

（4）解压 .gz 文件，不保留原文件。

gzip -dv /etc/passwd.gz
/etc/passwd.gz:	 57.9% -- replaced with /etc/passwd

（5）递归压缩指定目录下的所有文件。

ls dir
file1  file2  file3

gzip -rv dir
dir/file3:	-10.0% -- replaced with dir/file3.gz
dir/file2:	-25.0% -- replaced with dir/file2.gz
dir/file1:	-16.7% -- replaced with dir/file1.gz

●bzip2 命令：
1.命令简介

bzip2 用来压缩和解压缩文件，是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，采用 Burrow-Wheeler 块排序文本压缩算法和 Huffman 编码将文件压缩为后缀为 .bz2 的 bzip2 文件。压缩率一般比基于 LZ77/LZ78 的压缩软件好得多，其性能接近 PPM 族统计类压缩软件。

bzip2 不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和 tar 命令一起使用完成对文件的打包和压缩。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。
2.命令格式

bzip2 [OPTIONS] [FILES...]

bzip2 命令行参数有意设计为接近 GNU gzip 的形式，但也不完全相同。bzip2 从命令行读入选项和文件名。 每个文件被名为 “原始文件名.bz2” 的压缩文件替换。 每个压缩文件具有与原文件相同的修改时间、 权限， 如果可能的话， 还具有相同的属主， 因此在解压缩时这些特性将被正确地恢复。

bzip2 在缺省情况下不覆盖已有的文件。 如果想覆盖已有的文件，要指定 -f 选项。
3.选项说明

-c, --stdout
    将数据压缩或解压缩输出至标准输出
-d, --decompress
    强制解压缩。 bzip2, bunzip2 以及 bzcat 实际上是同一个程序，进行何种操作将根据程序名确定。 指定该选项后将不考虑这一机制，强制 bzip2 进行解压缩
-z, --compress
	-d 选项的补充：强制进行压缩操作，而不管执行的是哪个程序
-t, --test
    检查指定文件的完整性，但并不对其解压缩。 实际上将对数据进行实验性的解压缩操作，而不输出结果
-f, -force
    强制覆盖输出文件。通常 bzip2 不会覆盖已经存在的文件。该选项还强制 bzip2 打破文件的硬连接，缺省情况下 bzip2 不会这么做。
-k, --keep
    在压缩或解压缩时保留输入文件（不删除这些文件）
-s, --small
    在压缩、解压缩及检查时减少内存用量。 采用一种修正的算法进行压缩和测试， 每个数据块仅需要 2.5 个字节。 这意味着任何文件都可以在 2300K 的内存中进行解压缩， 尽管速度只有通常情况下的一半。在压缩时，-s 将选定 200K 的块长度，内存用量也限制在 200K 左右， 代价是压缩率会降低。 总之，如果机器的内存较少（8MB 或更少）， 可对所有操作都采用 -s 选项
-q, --quiet
    压制不重要的警告信息。属于 I/O 错误及其它严重事件的信息将不会被压制
-v, --verbose
    详尽模式——显示每个被处理文件的压缩率。 命令行中更多的 -v 选项将增加详细的程度， 使 bzip2 显示出许多主要用于诊断目的信息
-L, --license, -V, --version
	显示显示软件版本、许可证条款及分发条件
-1 (or --fast) to -9 (or --best)
    在压缩时将块长度设为 100 k、200 k ... 900 k。 对解压缩没有影响
--
    将所有后面的命令行变量看作文件名，即使这些变量以减号 - 打头。 可用这一选项处理以减号 - 打头的文件名， 例如：bzip2 -- -myfilename
--repetitive-fast, --repetitive-best
    这些选项在 0.9.5 及其以上版本中是多余的。 在较早的版本中，这两个选项对排序算法的行为提供了一些粗糙的控制，有些情况下很有用。 0.9.5 及其以上版本采用了改进的算法而与这些选项无关

4.常用示例

（1）不保留原文件压缩。

bzip2 /etc/passwd

压缩后 /etc/passwd 将变为 /etc/passwd.bz2。

（2） 保留原文件压缩。

bzip2 -k /etc/passwd
# 或
bzip2 -c /etc/passwd > /etc/passwd.bz2

（3）压缩时显示指令执行过程。

bzip2 -v /etc/passwd
/etc/passwd:  2.256:1,  3.546 bits/byte, 55.67% saved, 1552 in, 688 out.

（4）解压 .bz2 文件，不保留原文件。

bzip2 -d /etc/passwd.bz2

（5）解压 .bz2 文件，保留原文件。

bzip2 -dk /etc/passwd.bz2
# 或
bzip2 -dc /etc/passwd.bz2 > /etc/passwd

（6）测试.bz2压缩文件的完整性，实际上不解压。

bzip2 -tv /etc/passwd.bz2
/etc/passwd.bz2: ok

●diff 命令：
1.命令简介

diff（different）命令是以逐行的方式，比较文本文件的异同。

如果给定的文件名是 -，表示从标准输入读取内容。如果给定的文件是目录，则将会比较该目录中具有相同文件名的文件，默认情况下不会对其子目录文件进行任何比较操作。

由于历史原因，diff 有四种输出格式：

正常格式（选项 --normal ）
并列格式（选项 -y, --side-by-side）
上下文格式（选项 -C NUM, -c, --context[=NUM]）
合并格式（选项 -U NUM, -u, --unified[=NUM]）

2.命令格式

diff [OPTION]... FILES

FILES 取值形式有如下几种：

FILE1 FILE2
DIR1 DIR2
DIR FILE
FILE DIR

FILES 除了上面的几种取值形式，也可以使用选项 --from-file（指定第一个文件）或 --to-file（指定第二个文件）。如果输入相同，退出状态为 0；如果输入不同，则为 1；如果出现故障，则为 2。
3.选项说明

注意，长选项的强制性参数对于短选项也是强制的。

-a, --text
    所有的文件都视为文本文件来逐行比较
-B, --ignore-blank-lines
    忽略插入删除空行引起的变化
-b, --ignore-space-change
    忽略因空白符数量不同造成的差异
-C NUM
-c, --context[=NUM]
    使用上下文格式输出，显示异行处上下指定数量的行（默认为 3 行）
 --color[=WHEN]
 	将输出着色；WHEN 可取值 never、always 或 auto（默认值）
-D, --ifdef=NAME
	输出与 "#ifdef NAME" 不同的合并文件
-d, --minimal
    改变算法找出一组更小的变更。这会使 diff 变慢
-E, --ignore-tab-expansion
	忽略因 Tab 扩展引起的更改
-e, --ed
    输出为一个有效的 ed 脚本
-F, --show-function-line=RE
	显示匹配 RE 的前面的行
--from-file=FILE1
	将 FILE 1 与所有文件进行比较；FILE 1 可以是一个目录
--GTYPE-group-format=GFMT
	用组格式 GFMT 格式化类型为 GTYPE 的输入组
--line-format=LFMT
    用格式 LFMT 格式化所有输入行
--LTYPE-line-format=LFMT
 	用行格式 LFMT 格式化类型为 LTYPE 的输入行
	上面三个选项和响应的格式提供了对输出的细粒度控制。
	行类型 LTYPE 可取值 old、new 或 unchanged，组类型 GTYPE 可取值 LTYPE 或 changed。
	组格式 GFMT 特含如下内容：
	%< FILE1 中的行
	%> FILE2 中的行
	%= FILE1 和 FILE2 中共有的行
	%[-][WIDTH][.[PREC]]{doxX}LETTER
		使用 printf 输出风格修饰 LETTER，LETTER 使用如下字母表示新组，下面的小写字母表示旧组
		F	首行行号
        L	尾行行号
        N	行数 = L-F+1
        E	等于 F-1
        M	等于 L+1
        %(A=B?T:E)
              if A equals B then T else E
	行格式 LFMT  特含如下内容：
	%L	行的内容
	%l	行的内容，不包括任何尾随的换行符
	%[-][WIDTH][.[PREC]]{doxX}n
		使用 printf 风格修饰输入行号 n
	组格式 GFMT 和行格式 LFMT 共有的内容：
	%%			表示百分号 %
	%c'C'		表示大写字母 C
	%c'\OOO'	表示码值为八进制 000 的字符
	C			其他字符
--help
	显示帮助信息并退出
--horizon-lines=NUM
	保持共有前缀和后缀的 NUM 行
-I, --ignore-matching-lines=RE
    忽略匹配正则表达式 RE 的行
-i, --ignore-case
    忽略大小写
--ignore-file-name-case
	比较文件名时忽略大小写
-l, --paginate
    将结果交由 pr 程序来分页
--label LABEL
    输出比较结果时使用 LABEL 代替文件名和时间戳
--left-column
	只输出公共行的左列
-N, --new-file
	将缺席文件视为空文件。在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：Only in 目录：文件 A。若使用 -N 参数，则 diff 会将文件 A 与一个空白的文件比较
-n, --rcs
    将比较结果以 RCS 的格式来显示
--no-dereference
	不解析
--no-ignore-file-name-case
	比较文件名时大小写敏感
--normal
	使用正常格式输出比较结果。为默认输出格式
-p, --show-c-function
	显示每个更改在哪个 C 函数中
--palette=PALETTE
	当使用选项 --color 时，指定要使用的颜色。PALETTE 是使用冒号分隔的终端支持的能力列表
-q, --brief
    仅报告文件是否相异，忽略差别的细节
-r, --recursive
    当比较目录时，递归比较子目录
-S, --starting-file=FILE
    当比较目录时，由 FILE 开始。这用于继续中断的比较
-s, --report-identical-files
    当两个文件相同时报告
--speed-large-files
	使用启发规则加速操作那些有许多离散的小差异的大文件
--strip-trailing-cr
	去掉输入行尾的回车符 CR
--suppress-common-lines
    在并列格式中不印出公共行
-T, --initial-tab
    在每行前面加上 Tab 以便对齐
-t, --expand-tabs
    在输出时将 Tab 扩展为空格
--tabsize=NUM
	一个 Tab 表示 NUM（默认 8） 个空格
--to-file=FILE2
	将所有文件与 FILE2 进行比较；FILE2 可以是一个目录
-U NUM
-u, --unified[=NUM]
	使用合并格式输出，输出 NUM（默认 3）行的统一上下文
--unidirectional-new-file
	将缺席的第一批文件视为空文件
-v, --version
    输出版本信息并退出
-W, --width=NUM
    使用 -y 选项采用列格式输出时，指定栏宽。缺省为 130
-w, --ignore-all-space
    在比较行的时候忽略空白符
-y, --side-by-side
    使用并格式输出两列
 -Z, --ignore-trailing-space
 	忽略行尾的空白符

4.常用示例

给定测试文件 file1 和 file2，其内容为十二生肖中动物的英文。
file1 内容：

mouse
cattle
tiger
rabbit
dragon
snake
horse
sheep
monkey
chicken
dog
pig

file2 内容：

mouse
cattle
tiger
        rabbit
dragon
snake
h orse
sheeps
monkey
chicken

（1）比较两个文件的异同，使用正常格式输出。

diff file1 file2
4c4
< rabbit
---
> 	rabbit
7,8c7,8
< horse
< sheep
---
> h orse
> sheeps
11,12d10
< dog
< pig

diff 的正常输出格式有三种提示：

a - add
c - change
d - delete 

因此可以看出，上面的输出中 3c3 和 7,8c7,8 表示两者在 3、7 和 8 行内容有所不同；11,12d10 表示后者比前者少了 11 和 12 行。

特殊字符 < 表示该行属于第一个文件，> 表示该行属于第二个文件，— 为分隔符。

（2）比较两个文件的异同，使用并列格式输出，并指定列宽为 50。

diff -y -W50 file1 file2

在这里插入图片描述
其中特殊字符的含义如下：

| 表示前后 2 个文件内容有不同
< 表示后面文件比前面文件少了 1 行内容
> 表示后面文件比前面文件多了 1 行内容

（3）比较两个文件的异同，使用上下文格式输出，并只显示异行处上下各一行上下文。

diff -C1 file1 file2
*** file1	Sat Feb 15 22:24:46 2020
--- file2	Sat Feb 15 22:29:26 2020
***************
*** 3,12 ****
  tiger
! rabbit
  dragon
  snake
! horse
! sheep
  monkey
  chicken
- dog
- pig
--- 3,10 ----
  tiger
! 	rabbit
  dragon
  snake
! h orse
! sheeps
  monkey
  chicken

这种方式在开头两行作了比较文件的说明，这里有三种特殊字符：

-	出现在前者，表示后者比前者少一行
+	出现在后者，表示后者比前者多一行
!	出现在两者，表示有差别的行

（4）比较两个文件的异同，使用合并格式输出，并只显示异行处上下各一行上下文。

diff -U1 file1 file2
--- file1	2020-02-15 22:24:46.522867000 +0800
+++ file2	2020-02-15 22:29:26.686867000 +0800
@@ -3,10 +3,8 @@
 tiger
-rabbit
+	rabbit
 dragon
 snake
-horse
-sheep
+h orse
+sheeps
 monkey
 chicken
-dog
-pig

第一部分，也是文件的基本信息。— 表示第一个文件，+++ 表示第二个文件。
第二部分，@@包围的内容，其中 -3,10 表示输出的内容属于第一个文件的 3 至 10 行，+3,8 表示输出的内容属于第二个文件的 3 至 8 行。
第三部分，为比较后合并的内容。减号 - 表示后者比前者少了该行，加号表示后者比前者多了该行。

（5）比较时忽略空白字符（Tab、空格），使用正常格式输出。

diff -w file1 file2
8c8
< sheep
---
> sheeps
11,12d10
< dog
< pig

可以发现，后者包含 Tab 的 rabbit 行和空格的 horse 行与前者比较时属于相同行。

（6）比较文件夹中同名文件的不同，使用正常格式输出。

ll dir1
total 4
-rw-r--r-- 1 root root  0 Feb 16 00:24 a.txt
-rw-r--r-- 1 root root 74 Feb 15 22:24 file

ll dir2
total 4
-rw-r--r-- 1 root root  0 Feb 16 00:24 b.txt
-rw-r--r-- 1 root root 69 Feb 15 22:29 file

diff dir1 dir2
Only in dir1: a.txt
Only in dir2: b.txt
diff dir1/file dir2/file
4c4
< rabbit
---
> 	rabbit
7,8c7,8
< horse
< sheep
---
> h orse
> sheeps
11,12d10
< dog
< pig

●route 命令：
1.命令简介

route 命令用于显示和操作 IP 路由表。

要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在 Linux 系统中，设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 IP 地址设置为 Linux 机器的默认路由。

要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在 /etc/rc.d/rc.local 中添加 route 命令，作为开机启动命令来保证该路由设置永久有效。
2.命令格式

route [-CFvnNee] [-A FAMILY |-4|-6]
route [-v]  [-A FAMILY | -4 | -6]  add  [-net|-host]  TARGET  [netmask  NM] [gw GW] [metric N] [mss M] [window W] [irtt I] [reject] [mod] [dyn] [reinstate] [[dev] IF]
route [-v] [-A FAMILY | -4 | -6] del [-net|-host] TARGET [gw GW] [netmask NM] [metric N] [[dev] IF]
route [-V] [--version] [-h] [--help]

第一行格式用于查看路由表；
第二行格式用于添加一条路由；
第三行格式用于删除一条路由；
第四行格式用于查看版本与帮助信息。
3.选项说明

-A FAMILY
    指定的地址族。FAMILY 可取值 inet、inet6 等。-4 等同于 -A inet，-6 等同于 -A inet6
-C
	操作内核的路由缓存
-F
    操作内核的 FIB（Forwarding Information Base） 路由表。默认选项
-e
    用 netstat(8) 的格式来显示路由表。-ee 将用路由表中的所有参数生成一个很长的行
-host
    路由目标为主机
-n
    以数字地址代替主机或网络名。此项对试图检测对域名服务器进行路由发生故障的原因非常有用
-net
    路由目标为网络
-v
	开启冗余模式
del
    删除一条路由
add
    添加一条路由
TARGET
    指定目标网络或主机。可以用点分十进制形式的 IP 地址或主机/网络名
netmask NM
    为添加的路由指定网络掩码
gw GW
    为发往目标网络/主机的任何分组指定网关。注意：指定的网关首先必须是可达的，也就是说必须为该网关预先指定一条静态路由。如果你为本地接口之一指定这个网关地址的话，那么此网关地址将用于决定此接口上的分组将如何进行路由。这是 BSD 风格所兼容的
metric M
    把选路表中的 metric 字段值设为 M。metric 表示路由跳数
mss M
   设置最大传输单元 MTU
window W
    把基于此路由之上的连接的 TCP 窗口长度设为 W 字节。这通常只用于 AX.25 网络和不能处理背靠背帧的设备
irtt I
    把基于此路由之上的 TCP 连接的初始往返时间设为 I 毫秒（1-12000）。这通常也只用于 AX.25 网络。如果省略此选项，则使用 RFC1122 的缺省值 300ms
reject
    设置一条阻塞路由以使一条路由查找失败。这用于在使用缺省路由前先屏蔽掉一些网络。但这并不起到防火墙的作用
mod, dyn, reinstate
    设置一条动态或更改过的路由。这些标志通常只由路由进程来设置。这只用于诊断目的
dev IF
    强制使路由与指定的设备关联，否则内核会自己决定使用相应的设备（通常检查已存在的路由、设备说明和已加入路由的设备)。在多数正常的网络上无需使用该选项。如果 dev IF 是命令行上最后一个选项，那么可以省略关键字 dev

4.常用示例

（1）显示当前路由表。

Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         9.134.112.1     0.0.0.0         UG    0      0        0 eth1
9.0.0.0         9.134.112.1     255.0.0.0       UG    0      0        0 eth1
9.134.112.0     0.0.0.0         255.255.240.0   U     0      0        0 eth1
10.0.0.0        9.134.112.1     255.0.0.0       UG    0      0        0 eth1
100.64.0.0      9.134.112.1     255.192.0.0     UG    0      0        0 eth1
link-local      0.0.0.0         255.255.0.0     U     1002   0        0 eth1
172.16.0.0      9.134.112.1     255.240.0.0     UG    0      0        0 eth1
192.168.0.0     9.134.112.1     255.255.0.0     UG    0      0        0 eth1
192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 docker0

上面的输出中，有两行值得注意：

default         9.134.112.1     0.0.0.0         UG    0      0        0 eth1
	表示数据传送目的是访问 Internet，则由接口 eth1 将数据包发送到网关 9.134.112.1
9.134.112.0     0.0.0.0         255.255.240.0   U     0      0        0 eth1
	表示主机所在网络的地址为 9.134.112.0，若数据传送目标是在本局域网内通信，则可直接通过 eth1 转发数据包

Destination 表示目标网络或主机地址；
Gateway 表示网关地址，如果是 * 表示未设置；
Genmask 表示目标网络的网络掩码；目标是主机对应 255.255.255.255，默认路由对应 0.0.0.0；
Flags 为路由状态标志，含义如下：

U 路由当前为启动状态（Up ）
H 目标为主机（Host）
G 使用网关（Gateway）路由
R 恢复（Reinstate ）动态路由的路由
D 由守护进程或导向器动态（Dynamically）安装
M 由路由守护程序或导向器动态修改（Modified）
A 由 addrconf 安装
C 缓存（Cache）项
! 路由当前为关闭状态

Metric 表示与目标的距离，通常以跳数计算；
Ref 表示此路由的引用数（Linux 内核中不使用）；
Use 表示查找路由的计数。根据 -F 和 -C 的使用，这将是路由缓存未命中（-F）或命中（-C）；
Iface 表示将此路由的数据包发送到的接口。

（2）以数字地址代替主机或网络名。

route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         9.134.112.1     0.0.0.0         UG    0      0        0 eth1
9.0.0.0         9.134.112.1     255.0.0.0       UG    0      0        0 eth1
9.134.112.0     0.0.0.0         255.255.240.0   U     0      0        0 eth1
10.0.0.0        9.134.112.1     255.0.0.0       UG    0      0        0 eth1
100.64.0.0      9.134.112.1     255.192.0.0     UG    0      0        0 eth1
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth1
172.16.0.0      9.134.112.1     255.240.0.0     UG    0      0        0 eth1
192.168.0.0     9.134.112.1     255.255.0.0     UG    0      0        0 eth1
192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 docker0

（3）添加一条路由。

route add -net 127.0.0.0 netmask 255.0.0.0 dev lo

# 查看设置后的结果
route -n | grep lo
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo

使用 netmask 255.0.0.0 添加与 lo 设备相关联的回环路由项。

（4）屏蔽一条路由。

route add -net 224.0.0.0 netmask 240.0.0.0 reject

# 查看设置后的结果
route | grep 224.0.0.0
224.0.0.0       -               240.0.0.0       !     0      -        0 -

（5）删除一条路由。

route del -net 224.0.0.0 netmask 240.0.0.0 reject

（6）添加默认网关。

route add default gw 9.134.112.2

# 查看设置后的结果
route | grep 9.134.112.2
default         9.134.112.2     0.0.0.0         UG    0      0        0 eth1

route del default gw 9.134.112.2

5.拓展知识
5.1 路由类型
5.1.1 主机路由

主机路由是路由选择表中指向单个 IP 地址或主机名的路由记录。主机路由的 Flags 字段为 H。例如，在下面的示例中，本地主机通过 IP 地址 192.168.1.1 的网关到达 IP地址为 10.0.0.10 的主机。

Destination	Gateway		Genmask			Flags	Metric	Ref	Use	Iface
10.0.0.10	192.168.1.1	255.255.255.255	UH		0		0   0	eth0

5.1.2 网络路由

网络路由是代表主机可以到达的网络。网络路由的 Flags 字段为 N。例如，在下面的示例中，本地主机将发送到网络 192.19.12.0 的数据包转发到 IP 地址为 192.168.1.1 的路由器。

Destination   Gateway		Genmask 		Flags	Metric	Ref	Use	Iface
192.19.12     192.168.1.1   255.255.255.0   UN		0       0	0	eth0

5.1.3 默认路由

当主机不能在路由表中查找到目标主机的 IP 地址或网络路由时，数据包就被发送到默认路由（默认网关）上。默认路由的 Flags 字段为 G。例如，在下面的示例中，默认路由是 IP 地址为 192.168.1.1 的路由器。

Destination	Gateway			Genmask		Flags	Metric	Ref	Use	Iface
default		192.168.1.1		0.0.0.0		UG		0       0	0   eth0

●cal 命令：
1.命令简介

cal（calendar）命令用于用于显示当前或者指定日期的公历。
2.命令格式

cal [OPTIONS] [[[DAY] MONTH] YEAR]

可指定 YEAR（1-9999）、MONTH（1-12）和 DAY（1-31）。不跟任何选项和参数单独执行 cal，显示当月月历。
3.选项说明

-1, --one
	只显示当前月份（默认）
-3, --three
	显示前一个月、当前月和下一个月的月历
-h, --help
	显示帮助信息并退出
-j, --julian
	显示日期在当年中的第几天
-m, --monday
	显示星期一为一个星期的第一天
-s, --sunday
	显示星期天为一个星期的第一天（默认）
-V, --version
	显示版本信息并退出
-y, --year
	显示当年的日历

4.常用示例

（1）显示当前月份。

cal

在这里插入图片描述
（2）显示当前月份，星期一为一个星期的第一天。

cal -m

在这里插入图片描述
（3）显示当前月份，显示日期在当年中的第几天。

cal -j

在这里插入图片描述
（4）显示前一个月、当前月和下一个月的月历。

cal -3

在这里插入图片描述
（5）显示指定日期。

cal 24 6 2015

在这里插入图片描述

●watch 命令：
1.命令简介

watch 命令以周期性的方式执行给定的命令，并全屏显示执行结果。

watch 是一个非常实用的命令，基本所有的 Linux 发行版都带有它。如同名字一样，watch 可以帮助监测一个命令的运行结果，省得我们一遍遍地手动运行。比如 tail 一个 log 文件，ls 监测某个文件的大小变化等。缺省每 2 秒运行一下程序，可以用 -n 或 --interval 来指定间隔的时间。
2.命令格式

watch [OPTIONS] COMMAND

3.选项说明

-d, --differences [PERMANENT]
	高亮显示最近两次更新之间的差异。-d cumulative 选项会把变动过的地方（不管最近的那次有没有变动）都高亮显示出来
-n, --interval SECONDS
	指定监测间隔，单位秒。默认 2s，不能低于 0.1s
-p, --precise
	尝试精确地按照指定的间隔进行一次命令监视
-t, --no-title
	关闭 watch 命令在顶部的时间间隔、命令、当前时间的输出
-b, --beep
	被监测的命令退出码非零时发出哔哔声
-e, --errexit
	被监测的命令发生错误时 watch 停止更新，并在按键之后退出
-g, --chgexit
	被监测的命令输出发生变化时退出 watch
-c, --color
	解释 ANSI 颜色和样式序列
-x, --exec
	将命令传递给 exec(2) 而不是 sh -c
-h, --help
	显示帮助信息并退出
-v, --version
	显示版本信息并退出

4.常用示例

（1）重复执行 uptime 命令，默认每隔 2s 执行一次。

watch uptime

（2）查看当前目录文件 log 的变化。

watch -d "ls -l | grep log"

注意，当监测的命令中包含管道，需要使用引号将其括起来。

（3）每 10s 查看一次系统的平均负载。

watch -n10 cat /proc/loadavg

（4）每隔 1s 高亮显示网络连接数的变化情况。

watch -n1 -d netstat -ant

●iostat 命令：
1.命令简介

iostat（IO statistics）命令被用于监视 CPU 和输入输出设备的使用情况。iostat 有一个弱点，它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。

iostat 属于 sysstat 软件包，RedHat 系的 Linux 可以用 yum install sysstat 直接安装。
2.命令格式

iostat [OPTIONS] [ DEVICE [...] | ALL ] [ INTERVAL [ COUNT ]]

INTERVAL 表示 iostat 报告的时间间隔（单位秒），COUNT 表示报告的总次数。
3.选项说明

-c
	显示 CPU 使用情况
-d
	显示磁盘使用情况
--dec={ 0 | 1 | 2 }
	指定要使用的小数位数，默认为 2
-g GROUP_NAME { DEVICE [...] | ALL }
	显示一组设备的统计信息
-H
	此选项必须与选项 -g 一起使用，指示只显示组的全局统计信息，而不显示组中单个设备的统计信息
-h
	以可读格式打印大小
-j { ID | LABEL | PATH | UUID | ... } [ DEVICE [...] | ALL ]
	显示永久设备名。选项 ID、LABEL 等用于指定持久名称的类型
-k
	以 KB 为单位显示
-m 
	以 MB 为单位显示
-N
	显示磁盘阵列（LVM） 信息
-n
	显示NFS 使用情况
-p [ { DEVICE [,...] | ALL } ]
	显示磁盘和分区的情况
-t
	打印时间戳。时间戳格式可能取决于 S_TIME_FORMAT 环境变量
-V
	显示版本信息并退出
-x
	显示详细信息
-y
	如果在给定的时间间隔内显示多个记录，则忽略自系统启动以来的第一个统计信息
-z
	省略在采样期间没有活动的任何设备的输出。

4.常用示例

（1）显示所有设备负载情况。

iostat
Linux 3.10.107-1-tlinux2_kvm_guest-0049 (VM_114_170_centos) 	02/22/20 	_x86_64_	(8 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.10    0.00    0.12    0.01    0.00   99.77

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               1.57         0.99        40.17    1649382   66723341
vdb               0.14         0.41         3.42     687445    5681756
scd0              0.00         0.00         0.00        318          0

CPU 属性值说明：

%user：CPU 处在用户模式下的时间百分比
%nice：CPU 处在带 NICE 值的用户模式下的时间百分比，即改变过优先级的进程的占用 CPU 的百分比
%system：CPU 处在内核模式下的时间百分比
%iowait：CPU 等待输入输出完成时间的百分比
%steal：管理程序维护另一个虚拟处理器时，虚拟 CPU 的无意识等待时间百分比
%idle：CPU 空闲时间百分比

注意： 如果 %iowait 的值过高，表示硬盘存在 I/O 瓶颈，%idle 值高，表示 CPU 较空闲，如果 %idle 值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量。%idle 值如果持续低于10，那么系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU。

磁盘属性值说明：

Device：/dev 目录下的磁盘（或分区）名称
tps：该设备每秒的传输次数。一次传输即一次 I/O 请求，多个逻辑请求可能会被合并为一次 I/O 请求。一次传输请求的大小是未知的
Blk_read/s (kB_read/s, MB_read/s)：每秒读取的数据大小。每个块等同于扇区，大小为 512B
Blk_wrtn/s (kB_wrtn/s, MB_wrtn/s)：每秒写入的数据大小
Blk_read (kB_read, MB_read)：读取数据的总大小
Blk_wrtn (kB_wrtn, MB_wrtn)：写入数据的总大小

（2）显示磁盘的详细使用情况。

iostat -dx
Linux 3.10.107-1-tlinux2_kvm_guest-0049 (VM_114_170_centos) 	02/22/20 	_x86_64_	(8 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
vda               0.03     1.58    0.05    1.53     0.99    40.16    52.35     0.00    2.51    4.53    2.45   0.48   0.08
vdb               0.00     0.12    0.02    0.12     0.41     3.41    53.61     0.00    8.99    2.98    9.99   0.38   0.01
scd0              0.00     0.00    0.00    0.00     0.00     0.00     7.23     0.00    0.41    0.41    0.00   0.41   0.00

磁盘属性值说明：

Device：/dev 目录下的磁盘（或分区）名称
rrqm/s：每秒合并到设备队列中的读取请求数
wrqm/s：每秒合并到设备队列中的写请求数
r/s：设备每秒完成的读请求数
w/s：设备每秒完成的写请求数
rsec/s (rkB/s, rMB/s)：每秒读取的数据大小。每扇区大小为 512 字节
wsec/s (wkB/s, wMB/s)：每秒写入的数据大小
avgrq-sz：平均每次设备 I/O 操作的数据大小 
avgqu-sz： I/O 请求队列平均长度
await：每次 I/O 平均耗时 （单位毫秒）。包括在请求队列中的等待时间和真正 I/O 时间
r_await：每个读操作平均耗时（单位毫秒）。包括在请求队列中的等待时间和真正读取时间
w_await：每个写操作平均耗时（单位毫秒）。包括在请求队列中的等待时间和真正写入时间
svctm：平均每次设备 I/O 操作的服务时间（单位毫秒）。警告！不要再信任此字段，此字段将在将来的 sysstat 版本中删除
%util：在统计时间内所有处理 IO 时间，除以总共统计时间。例如，如果统计间隔 1s，该设备有 0.8s 在处理 IO，而 0.2s 闲置，那么该设备的 %util = 0.8/1 = 80%，所以该参数暗示了设备的繁忙程度。

注意：如果 %util 是100%，表明产生的 I/O 请求太多，设备已经接近满负荷运行了（当然如果磁盘具有并发能力，即使 %util 是 100%，磁盘使用未必就到了瓶颈，比如 RAID 阵列和现代固态硬盘）。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，I/O 响应太慢，则需要进行必要优化。如果 avgqu-sz 比较大，也表示有大量 I/O 在等待。

（3）查看指定磁盘的负载情况。

iostat -d vda
Linux 3.10.107-1-tlinux2_kvm_guest-0049 (VM_114_170_centos) 	02/22/20 	_x86_64_	(8 CPU)

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               1.57         0.99        40.16    1649382   67150673

（4）只查看 CPU 使用情况。每一个间隔 1s 显示一次，总共显示 2 次。

iostat -c 1 3
Linux 3.10.107-1-tlinux2_kvm_guest-0049 (VM_114_170_centos) 	02/22/20 	_x86_64_	(8 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.10    0.00    0.12    0.01    0.00   99.77

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.00    0.00    0.13    0.00    0.00   99.87

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.00    0.00    0.13    0.00    0.00   99.87

●lsof 命令:
1.命令简介

lsof（list open files）用于查看进程打开的文件，是十分方便的系统监测工具。因为 lsof 命令需要访问核心内存和各种系统文件，所以需要 root 权限才可执行。

在 Linux 中，一切皆文件。通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件，所以 lsof 不仅可以查看进程打开的普通文件、目录，还可以查看进程监听的端口和 socket 等相关的信息。进程打开的每一个文件，系统在后台都会为之分配一个文件描述符，无论这个文件的本质如何。该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口，因为应用程序打开的文件描述符列表提供了大量关于应用程序本身的信息，通过 lsof 能够查看这个列表，对系统监测以及排错很有帮助。

lsof 查看的打开文件可以是：

普通文件
目录
字符或块设备文件
共享库
管道、命名管道
符号链接
网络文件（如 NFS file、网络 socket，Unix 域名 socket）
其它类型的文件，等等

2.命令格式

lsof [OPTIONS] [--] [NAMES]

在没有任何选项的情况下，lsof 列出所有属于活动进程的打开文件。
3.选项说明

-?, -h 
	显示帮助信息
-a
参数被视为逻辑与 AND，会影响全部的参数
-A A
	在配置了 AFS 分布式网络文件系统的系统上可用，其 AFS 内核代码是通过动态模块实现的。通过 A 指定备用名称列表文件，在该文件中可以找到动态模块的内核地址
-b
	避免 lsof 因调用可能阻塞的内核函数而产生阻塞，比如 lstat(2)、readlink(2) 和 stat(2) 等内核函数
-c C
	显示出以字符或字符串 C 开头的命令程序开启的文件，如 lsof -c init。如果 C 以斜杠 / 开头和结尾，则斜杠之间的字符被解释为正则表达式。该选项可多次指定
+c W
	指定 COMMAND 列的宽度，单位字符。默认为 9
-C
	禁用从内核的名称缓存中报告任何路径名
-D D
	指导 lsof 使用设备缓存文件。该选项的使用有时受到限制。-D 必须后面跟着一个函数字母，函数字母后面可以有一个路径名称。lsof 识别以下功能字母：
	?	报告设备缓存文件路径
	b	构建设备缓存文件
	i	忽略设备缓存文件
	r	读取设备缓存文件
	u	读取并更新设备缓存文件
+D D
	递归搜索目录 D。如显示在 /usr/local 及其子目录下被程序开启的文件：lsof +D /usr/local
+d D
	 非递归搜索目录 D。如显示在 /usr/local 下被程序开启的文件：lsof +d /usr/local
-d FD
	指定文件描述符列表，可以采用逗号分隔，也可以指定范围。比如 1,2,3 或 1-3。如果前面包含尖号，表示排除。如显示 FD 为 4 的进程：lsof -d 4
+|-e S
	豁免（exempt）路径名称为 S 的文件系统不受可能阻塞的内核函数调用的影响。+e 选项豁免 stat(2)、lstat(2) 和大多数 readlink(2) 内核函数调用。-e 选项只能豁免 stat(2) 和 lstat(2) 内核函数调用
+|-E
	+E 指定使用端点信息显示 Linux 管道、Linux UNIX 套接字和 Linux 伪终端文件，并显示端点的文件。-E 则不显示端点的文件
-F LIST
	指定字符列表 LIST，选择输出给另一程序处理的字段，各字段对应的字符见下文
+|-f [cfgGn]
	f 本身澄清了路径名参数的解释方式。当后面跟着 c、f、g、G 或 n 时，它指定要启用（+）或抑制（-）内核文件结构信息。
	c 文件结构使用计数（not Linux）
	f 文件结构地址（not Linux）
	g 文件标志缩写（Linux 2.6.22 及更高版本）
	G 十六进制文件标志（Linux 2.6.22 及更高版本）
	n 文件结构节点地址（not Linux）
-g [PGID]
	选择或排除属于指定进程组的进程打开的文件。 进程组 ID 使用逗号分隔，如果 PGID 前面包含尖号，表示排除。若没有指定 PGID，则显示全部。如显示 PGID 为 6 和 7 的进程：lsof -g6,7
-i [I]
	选择其 Internet 地址与 -i 中指定的地址匹配的文件，若没有相关地址被指定，则监听全部。
	用法： lsof -i [46][protocol][@hostname|hostaddr][:serivce|port]
	说明：4 6 分别表示 IPv4 和 IPv6   
    protocol： TCP or UDP   
    hostname：主机名
    hostaddr：IPv4 或 IPv6 地址
    service：主机提供的服务的名称，即 /etc/services 中的 service name
    port：端口号
-K
	在支持任务（线程）报告方式的系统上输出进程的任务（线程）列表
-k K
	指定内核名称列表文件，代替 /vmunix、/mach 等
-l
	禁止将 user ID 转换为登录的名称，默认是登录名称
+|-L [L]
	+ 或 - 表示开启或关闭显示文件连接数，如果只有单纯的 +L，后面没有任何数字，则表示显示全部，如果后面有数字，只有文件连接数少于该数字的会被列出
+|-m M
	-m 指定一个内核内存文件 M ，代替 /dev/kmem 或 /dev/mem。+m 将装载补充文件写入标准输出文件
+|-M
	启用或禁用报告本地 TCP、UDP 和 UDPLITE 端口的端口映射器注册
-n
	不将 IP 地址转换为主机名
-N
	显示 NFS 文件
-o
	始终显示文件偏移量。它导致 SIZE/OFF 输出列标题更改为 OFFSET
-o O
	指定在文件偏移量的 0t 之后要打印的小数位数
-O
	指示 lsof 避免被某些内核操作阻塞。即在分叉的子进程中执行它们。虽然使用此选项将减少 lsof 启动开销，但也可能导致 lsof 在内核不响应函数时挂起。谨慎使用此选项
-P
	禁止将网络文件的端口号转换为端口名
-p S
	排除或选择进程的文件列表，进程 ID 列表使用逗号分隔，如 123 或 123,^456。尖号表示排除指定 PID
-R
	使用列 PPID 列出父进程的 PID
+|-r [T[mFMT]]
 	控制 lsof 不断重复执行，间隔 T 秒，默认为 15s。-r 永远不断地执行，直到收到中断讯号（ctrl+ c），+r 一直执行，直到没有文件被显示。可选的 mFMT 参数指定标记线的格式，格式 FMT 遵循 C 语言标准库函数 strftime(3) 的规范
-S [T]
	指定内核函数 lstat(2)、readlink(2) 和 stat(2) 的可选超时秒值，否则可能会死锁。t 的最小值是 2；默认值是 15
-s [P:S]
	列出文件的大小，若该文件没有大小，则留下空白。它导致 SIZE/OFF 输出列标题更改为 SIZE。P 表示协议名称 TCP  or  UDP，S 表示逗号分隔的协议状态
-T [T]
	-T 没有参数则禁用 TCP/TPI 信息报告。跟如下参数，则显示指定 TCP/TPI 信息：
	f 选择报告套接字选项，状态和值，以及 TCP标志和值
	q 选择队列长度
	s 选择连接状态
	w 选择窗口大小
-t
	生成只有进程标识符而没有标题的简洁输出，这样输出可以通过管道传递给 kill(1) 杀死
-U
	选择 UNIX 域套接字文件的列表
-u USERS
	选择登录名或用户 ID 位于逗号分隔集 USERS 中的用户的文件列表。如 root 或 548,root”，如果用户名或用户 ID 前有尖号 ^，表示排除
-V
	指示被要求列出但找不到的项
-v
    显示版本信息
+|-w
	   启用（＋）或禁用（－）警告消息
-X
	Linux 下跳过所有打开的 TCP、UDP 和 UDPLITE IPv4 和 IPv6 文件的信息报告
-x [fl]
	一般与选项 +d 和 +D 选项，指示搜索时是否跨文件系统和符号链接。-x 不跟任何参数时，表示跨文件系统和符号链接
-Z [Z]
	指定如何处理 SELinux 安全上下文。当在运行的 Linux 内核中禁用SELinux时，Z 字段将被抑制输出。-Z 选项不跟参数，如 -Z -，安全上下文将列在 SECURITY-CONTEXT 列中输出
--
	双减号表示选项结束
NAMES
	列出指定文件，符号链接在使用前将被解析

4.输出字段说明

当指定了 -F 选项时，lsof 将生成适合由另一个程序（如 awk 或 Perl 脚本或 C 程序）处理的输出。

下面是 lsof 可输出的字段。单个字符表示字段标识符。

a	文件访问模式
c	进程命令名
C	文件结构共享计数
d	文件的设备字符码
D	文件的主要/次要设备号
F	文件结构地址
f	文件描述符
G	文件标志
g	进程组 ID
i	文件 inode 编号
K	任务 ID
k	链接计数
L	进程登录名
m	重复输出之间的标记
N	节点标识符
n	文件名、注释、Internet 地址
o	文件偏移量（十进制）
P	协议名称
p	进程 ID
R	父进程 ID
r	原始设备号
S	文件的流标识
s	文件大小（十进制）
T	TCP/TPI 信息
t	文件类型
u	进程用户 ID
Z	SELinux 安全上下文（禁用 SELinux 时禁用）
z	Solaris 10 及更高版本的区域名
0	使用NUL字段结束符字符代替NL
1-9	系统特定的字段标识符

可以使用命令 lsof -F? 查看上面字段的说明信息。
5.常用示例

（1）无任何参数，列出所有属于活动进程的打开文件。

lsof | head
COMMAND     PID   TID USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME
systemd       1       root  cwd       DIR              252,1     4096          2 /
systemd       1       root  rtd       DIR              252,1     4096          2 /
systemd       1       root  txt       REG              252,1  1616248      47908 /usr/lib/systemd/systemd
systemd       1       root  mem       REG              252,1    20032      25897 /usr/lib64/libuuid.so.1.3.0
systemd       1       root  mem       REG              252,1   252704      25043 /usr/lib64/libblkid.so.1.1.0
systemd       1       root  mem       REG              252,1    90632      25988 /usr/lib64/libz.so.1.2.7
systemd       1       root  mem       REG              252,1   153192      25496 /usr/lib64/liblzma.so.5.0.99
systemd       1       root  mem       REG              252,1    23968      25065 /usr/lib64/libcap-ng.so.0.0.0
systemd       1       root  mem       REG              252,1    19888      25018 /usr/lib64/libattr.so.1.1.0

lsof 输出各列信息的意义如下：

COMMAND：进程的名称
PID：进程标识符
TID：任务 ID。Linux 下 TID 为空表示该行为进程
USER：进程所有者
FD：文件描述符。主要有：
	cwd：应用程序当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改
	txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序
	lnn：库引用（AIX）
	err：FD 信息错误
	jld：监狱目录（FreeBSD）
	ltx：共享库文本（代码和数据）
	mxx：十六进制内存映射类型号 xx
	m86：DOS合并映射文件
	mem：内存映射文件
	mmap：内存映射设备
	pd：父目录
	rtd：根目录
	tr：内核跟踪文件（OpenBSD）
	v86：VP/ix 映射文件
	0：标准输出
	1：标准输入
	2：标准错误
	
	文件描述符后一般还跟着文件状态模式：
	r：只读模式
	w：写入模式
	u：读写模式
	空格：文件的状态模式为 unknow，且没有锁定
	-：文件的状态模式为 unknow，且被锁定
	
	同时在文件状态模式后面，还跟着相关的锁：
	N：对于未知类型的 Solaris NFS 锁
	r：文件部分的读锁
	R：整个文件的读锁
	w：文件的部分写锁
	W：整个文件的写锁
	u：任何长度的读写锁
	U：用于未知类型的锁
	x：用于部分文件上的 SCO OpenServer Xenix 锁
	X：用于整个文件上的 SCO OpenServer Xenix 锁
	space：无锁

TYPE：文件类型。常见的文件类型有：
	REG：普通文件
	DIR：表示目录
	CHR：表示字符类型
	BLK：块设备类型
	UNIX：UNIX 域套接字
	FIFO：先进先出队列
	IPv4：IPv4 套接字
DEVICE：磁盘名称
SIZE：文件的大小或文件偏移量（以字节为单位）
NODE：索引节点
NAME：打开文件的确切名称

（2）查看谁正在使用某个文件，也就是说查找某个文件相关的进程。

lsof /bin/bash
COMMAND     PID USER  FD   TYPE DEVICE SIZE/OFF  NODE NAME
watchdog.  7639 root txt    REG  252,1   922760 45210 /usr/bin/bash
bash       8591 root txt    REG  252,1   922760 45210 /usr/bin/bash
bash       9694 root txt    REG  252,1   922760 45210 /usr/bin/bash
bash      20151 root txt    REG  252,1   922760 45210 /usr/bin/bash

（3）递归查看某个目录下所有被打开的文件信息。

lsof +D ./test
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
bash    8518 root  cwd    DIR  252,1     4096 799036 ./test/shell

（4）列出某个用户打开的文件信息。

lsof -u root

（5）列出某个进程所打开的文件信息。

 lsof -c sshd

-c 选项将会列出所有以 sshd 开头的进程所打开的文件。其实也可以通过命令lsof | grep sshd来查看，但是第一种方法更加简洁。

（6）列出多个进程打开的文件信息。

lsof -c mysql -c apache

（7）列出某个用户以及某个进程所打开的文件信息。

lsof -u test -c mysql 

注意，-u 与 -c 选项之间是或的关系。可以使用 -

（8）列出除了某个用户外的所有被打开的文件信息。

lsof -u ^root

尖号 ^ 在用户名之前，表示排除在外，即不显示 root 用户所打开的文件信息。

（9）通过某个进程号显示该进程打开的文件。

lsof -p 1

（10）列出多个进程号对应的文件信息。

lsof -p 1,2,3

（11）列出除了某个进程号，其他进程号所打开的文件信息。

lsof -p ^1

（12）列出所有的网络连接。

lsof -i

（13）列出所有的 TCP 网络连接信息。

lsof -i tcp

（14）列出所有 UDP 网络连接信息。

lsof -i udp

（15）列出谁在使用某个端口。

lsof -i :3306

（16）列出谁在使用某个特定的 UDP 或 TCP 端口。

lsof -i udp:55
lsof -i tcp:80

（17）列出某个用户的所有活跃的网络端口。

lsof -a -u test -i

（18）列出所有网络文件系统。

lsof -N

（19）选择 UNIX 域套接字文件的列表。

lsof -U

（20）查看某个用户组所打开的文件信息。

lsof -g 5555

（21）根据指定文件描述符的文件信息。

lsof -d txt
lsof -d 1
lsof -d 2

0 表示标准输入，1 表示标准输出，2 表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始。

（22）查看指定文件描述符范围的文件信息。

lsof -d 2-3

（23）列出 COMMAND 列中包含字符串 sshd 且文件描符的类型为 txt 的文件信息。

lsof -c sshd -a -d txt
COMMAND   PID USER  FD   TYPE DEVICE SIZE/OFF  NODE NAME
sshd     8254 root txt    REG  252,1   819608 27632 /usr/sbin/sshd
sshd    20149 root txt    REG  252,1   819608 27632 /usr/sbin/sshd

（24）列出被进程号为 1234 的进程所打开的所有 IPV4 网络文件。

lsof -p 1234 -a -i 4

（25）列出目前连接主机 peida.linux 上端口为：20，21，22，25 相关的所有文件信息，且每隔 3 秒不断地执行 lsof 指令。

lsof -i @peida.linux:20,21,22,25 -r 3

●vmstat 命令:
1.命令简介

vmstat（Virtual Memory Statistics）命令用于报告虚拟内存状态的统计信息。

vmstat 不仅可以监测虚拟内存，也可监测进程、物理内存、内存分页、磁盘和 CPU 等的活动信，是对系统的整体情况进行统计，不足之处是无法对某个进程进行深入分析。

vmstat 属系统管理员命令，属于 sysstat 软件包，RedHat 系的 Linux 可以用 yum install sysstat 直接安装。
2.命令格式

vmstat [OPTIONS] [DELAY [COUNT]]

DELAY 表示报告之间的间隔（秒）。如果没有指定间隔，仅打印一条自系统启动以来的平均统计信息。

COUNT 表示报告的次数，如果指定了 DELAY，没有指定 COUNT，表示无限次报告。
3.选项说明

-a, --active
	显示活跃和非活跃内存
-f, --forks
	显示从系统启动至今的 fork 数量 。这包括 fork、vfork 和 clone 系统调用，并相当于创建的任务总数。每个进程由一个或多个任务表示，这取决于线程的使用情况
-m, --slabs
	显示 slabinfo
-n, --one-header
	只在开始时显示一次各字段名称
-s, --stats
	显示各种事件计数器和内存统计信息的表
-D, --disk-sum
	报告一些有关磁盘活动的汇总统计数据
-d, --disk
	显示磁盘相关统计信息
-p, --partition DEVICE
	显示指定磁盘分区统计信息
-S, --unit CHAR
	使用指定单位显示。CHAR 可取值有 k（1000）、K（1024）、m（1000000） 、M（1048576）。默认单位为 K（1024 Bytes）
-t, --timestamp
	将时间戳附加到每行
-w, --wide
	宽输出模式，输出大于 80 个字符/行
-h, --help
	显示帮助信息并退出
-V, --version
	显示版本信息并退出

4.常用示例

（1）显示系统各项统计信息。

vmstat 
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 9120876 554900 5998224    0    0     0     6    1    2  0  0 100  0  0

vmstat 命令执行结果共分为 6 部分：procs、memory、swap、io、system、cpu。

输出内容的含义如下：

procs（进程）
r(run)
	运行或等待 CPU 时间片的进程数。如果该值长期大于服务器 CPU 的个数，则说明 CPU 资源不足
b(block)
	等待 I/O 的进程数量。该数值如果长时间大于 1，则表明系统 I/O 遇到瓶颈

memory（内存，单位 KB）
swpd
	虚拟内存（swap 空间）已使用的大小
free
	空闲的物理内存的大小
buff
	用作缓冲的内存大小，一般存放待写入磁盘的数据
cache
	用作缓存的内存大小，一般存放从磁盘中读取的数据

swap（虚拟内存，单位 KB）
si
	每秒从交换区写到内存的大小
so
	每秒写入交换区的内存大小

io（单位 块/秒）
bi
	每秒读取的块数（读磁盘）
bo
	每秒写入的块数（写磁盘）

system（系统）
in
	每秒 CPU 的中断次数，包括时钟中断
cs
	每秒上下文切换数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进行上下文切换，这个值越小越好

cpu（以百分比显示）
us
	用户进程执行时间
sy
	系统进程执行时间
id
	空闲时间（包括 IO 等待时间）
wa
	等待 IO 时间。wa 的值高时，说明 IO 等待比较严重，这可能由于磁盘大量做随机访问造成的，也有可能是磁盘出现瓶颈
st
	被偷走的 CPU 时间

（2）每隔 1s 报告 3 次系统各项统计信息。

vmstat 1 3
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 9120312 554900 5999148    0    0     0     6    1    2  0  0 100  0  0
 0  0      0 9120048 554900 5999148    0    0     0     0  836  785  0  0 100  0  0
 1  0      0 9120064 554900 5999148    0    0     0    52  834  815  0  0 100  0  0

（3）显示活跃和非活跃内存。

vmstat -a
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free  inact active   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 9124948 2119956 4194464    0    0     0     6    1    2  0  0 100  0  0

使用 -a 选项显示活跃和非活跃内存时，所显示的内容除增加 inact 和 active 外，其他显示内容与不使用选项的 vmstat 输出的内容相同。

字段说明：

inact：非活跃内存大小
active：活跃的内存大小

（4）查看系统自启动以来已经 fork 了多少次。

vmstat -f
5245186 forks

（5）显示内存相关统计信息及多种系统活动数量。

     16165976 K total memory
       491596 K used memory
      4194836 K active memory
      2119968 K inactive memory
      9124404 K free memory
       554900 K buffer memory
      5995076 K swap cache
            0 K total swap
            0 K used swap
            0 K free swap
      1660593 non-nice user cpu ticks
           26 nice user cpu ticks
      1987770 system cpu ticks
   1606632174 idle cpu ticks
       148581 IO-wait cpu ticks
            2 IRQ cpu ticks
         9090 softirq cpu ticks
            0 stolen cpu ticks
      2376421 pages paged in
     89871709 pages paged out
            0 pages swapped in
            0 pages swapped out
   1698946367 interrupts
   1672804654 CPU context switches
   1580713782 boot time
      5245774 forks

这些信息的分别来自于 /proc/meminfo、/proc/stat 和 /proc/vmstat。

（6）查看磁盘的读写。

vmstat -d
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
vda    77168  53491 3302309  349900 3094238 3196966 162673698 7600604	0   1531
vdb    34381    237 1428906  106216 257198 238871 17119528 3120952      0    117

这些信息主要来自于 /proc/diskstats。

输出字段说明：

disk 磁盘名

reads
total
	读取成功的数据总大小
merged
	合并的读请求数
sectors
	成功读取的扇区数
ms
	读取所花费的毫秒数

Writes
total
	写入成功的数据总大小
merged
	合并的写请求数
sectors
	成功写入的扇区数
ms
	写入所花费的毫秒数

IO
cur
	当前处于 I/O 等待的进程
s
	I/O 花费的秒数

（7）查看系统的 slab 信息。

Cache                       Num  Total   Size  Pages
kmalloc-8192                108    128   8192      4
kmalloc-4096                407    488   4096      8
kmalloc-2048               1093   1168   2048     16
...

由于内核会有许多小对象，这些对象构造销毁十分频繁，比如 i-node，dentry，这些对象如果每次构建的时候就向内存要一个页（4KB），而其实只有几个字节，这样就会非常浪费，为了解决这个问题，就引入了一种新的机制来处理在同一个页中如何分配小存储区，而 slab 可以对小对象进行分配,这样就不用为每一个对象分配一个页，从而节省了空间。内核对一些小对象创建析构很频繁，slab 对这些小对象进行缓冲，可以重复利用，减少内存分配次数。

●ssh 命令:
1.命令简介

ssh（Secure SHell）命令是 OpenSSH 套件的组成部分，是远程登录服务 SSH 的客户端程序，用于登录远程主机。

ssh 是一个用于登录到远程机器并在远程机器上执行命令的程序。它的目的是取代 rlogin 和 rsh，并在一个不安全的网络上提供两个不受信任的主机之间的安全加密通信。X11 连接和任意 TCP 端口也可以通过安全通道进行转发。
2.命令格式

ssh [OPTIONS] [-p PORT] [USER@]HOSTNAME [COMMAND]

ssh 最常用的功能是登录远程主机，选择以什么用户连接哪台机器，然后输入密码即可。

如果不想通过选项 -p 指定 PORT，可使用 URI 格式 ssh://[USER@]HOSTNAME[:PORT] 来指定目标主机。
3.选项说明

-1
    强制只使用协议第一版
-2
    强制只使用协议第二版
-4
    强制只使用 IPv4 地址.
-6
    强制只使用 IPv6 地址
-A
    允许转发认证代理的连接。可以在配置文件中对每个主机单独设定这个参数
-a
    禁止转发认证代理的连接
-b BIND_ADDRESS
    在拥有多个地址的本地机器上，指定连接的源地址
-C
	压缩所有数据。压缩算法与 gzip(1) 使用的相同
-c {blowfish | 3des | des}
    选择会话的密码算法。3des 是默认算法
-c CIPHER_SPEC
    另外, 对于协议第二版，这里可以指定一组用逗号隔开、按优先顺序排列的加密算法
-D [BIND_ADDRESS:]PORT
	指定一个本地主机动态的应用程序级的转发端口。工作原理是这样的，本地机器上分配了一个 socket 侦听 port 端口，一旦这个端口上有了连接，该连接就经过安全通道转发出去，根据应用程序的协议可以判断出远程主机将和哪里连接。目前支持 SOCKS4 和 SOCKS5 协议，而 ssh 将充当 SOCKS 服务器. 只有 root 才能转发特权端口。可以在配置文件中指定动态端口的转发
-e ESCAPE_CHAR
	设置 pty 会话的转义字符，默认为字符 ~。转义字符只在行首有效，转义字符后面跟一个点表示结束连接，后跟一个 control-Z 表示挂起连接，跟转义字符自己表示输出转义字符自身。把转义字符设为 none 则禁止 转义功能，使会话完全透明
-F CONFIGFILE
	指定 ssh 指令的配置文件，将忽略系统级配置文件 /etc/ssh/ssh_config 和用户级配置文件 ~/.ssh/config
-f 
    ssh 在执行命令前退至后台
-g
    允许远端主机连接本地的转发端口
-I SMARTCARD_DEVICE
    指定智能卡设备。智能卡里面存储了用户的 RSA 私钥
-i IDENTITY_FILE
    指定一个 RSA 或 DSA 认证所需的身份（私钥）文件。协议第一版的默认文件是 ~/.ssh/identity 以及协议第二版的 ~/.ssh/id_rsa 和 ~/.ssh/id_dsa 文件。可以同时使用多个 -i 选项，也可以在配置文件中指定多个身份文件
-K
	启用基于 GSSAPI 的身份验证和向服务器转发 GSSAPI 凭据
-k
   禁用向服务器转发 GSSAPI 凭据
-L [BIND_ADDRESS:]PORT:HOST:HOSTPORT
	将本地主机的地址和端口接收到的数据通过安全通道转发给远程主机的地址和端口
-l LOGIN_NAME
    指定登录远程主机的用户。可以在配置文件中对每个主机单独设定这个参数
-M
	将 ssh 客户端置于主模式进行连接共享。多个 -M 选项将 ssh 置于主模式，并在接受从连接之前进行确认
-m MAC_SPEC
	对于协议第二版，可以指定一组用逗号隔开，按优先顺序排列的 MAC (message authentication code) 算法
-N
    不执行远程命令，用于转发端口。仅限协议第二版
-n
	把 stdin 重定向到 /dev/null，防止从 stdin 读取数据。在后台运行时一定会用到这个选项
-O CTL_CMD
	控制主动连接多路复用主进程。参数 CTL_CMD 将被传递给主进程。CTL_CMD 可取值 check（检查主进程是否正在运行）和 exit（让主进程退出）
-o OPTION
    可以在这里给出某些选项，格式和配置文件中的格式一样。它用来设置那些没有单独的命令行标志的选项
-p PORT
    指定远程主机的端口。可以在配置文件中对每个主机单独设定这个参数
-q
    安静模式。消除大多数的警告和诊断信息
-R [BIND_ADDRESS:]PORT:HOST:HOSTPORT
	将远程主机上的地址和端口接收的数据通过安全通道转发给本地主机的地址和端口
-S CTL_PATH
	指定用于连接共享的控制套接字的位置
-s
    用于请求远程系统上的子系统调用。子系统是 SSH2 协议的一个特性，它有助于将 SSH 用作其他应用程序（如 sftp(1)）的安全传输。子系统通过远程命令指定
-T
    禁止分配伪终端
-t
	强制分配伪终端。这可用于在远程计算机上执行基于屏幕的任意程序，例如菜单服务。多个 -t  选项强制分配终端, 即使没有本地终端
-V
	显示版本信息并退出
-v
    冗详模式。打印关于运行情况的调试信息。在调试连接、认证和配置问题时非常有用。多个 -v 选项能够增加冗详程度，最多三个
-W HOST:PORT
	将客户端上的标准输入和输出通过安全通道转发给指定主机的端口
-w LOCAL_TUN[:REMOTE_TUN]
	指定客户端和服务端之间转发的隧道设备
-X
    允许 X11 转发，可以在配置文件中对每个主机单独设定这个参数
-x
    禁止 X11 转发
-Y
	启用受信任的 X11 转发。受信任的 X11 转发不受 X11 安全扩展控制的约束
-y
	使用 syslog(3) 系统模块发送日志信息。默认情况下，此信息被发送到 stderr

4.常用示例

（1）使用指定用户名和端口登录远程主机。

ssh -p3600 root@9.134.114.170

输入用户登录密码后完成登录。未指明端口和用户名，则分别由配置文件 ~/.ssh/ssh_config 和 /etc/ssh/ssh_config 中的 Port 和 User 选项决定。如果配置文件未指定，则端口默认为 22 ，用户名默认为当前用户。

注意：ssh 获取相关参数的顺序如下：

1.command-line options
2.user's configuration file (~/.ssh/config)
3.system-wide configuration file (/etc/ssh/ssh_config)

ssh 利用非对称加密实现安全的登录，非对称加密中有两个密钥：公钥和私钥。公钥由私钥产生，但却无法推算出私钥；公钥加密后的密文，只能通过对应的私钥来解密。非对称加密的登录流程如下：
在这里插入图片描述
整个登录过程如下：

1.topgun 终端要登录 Server 服务器，发起登录请求 `ssh work@server.com`。
2.服务端运行有 sshd 服务，并监听指定的端口，默认为 22 号端口。服务端会生成一对公钥和私钥；此时将公钥返回给客户端；
3.客户端使用公钥，对登录密码进行加密（如服务器work用户密码为xxx），生成公钥加密字符串；
4.客户端将公钥加密字符串发送给服务端；
5.服务端使用私钥，解密公钥加密字符串，得到原始密码；
6.校验密码是否合法（此为本机 work 密码）；
7.返回登录结果给客户端：成功登录或密码错。

在非对称加密中，由于只有公钥会被传输，而私钥是服务端本地保存，因此即便公钥被监听，也无法拿到原始密码，从而安全地登录服务器。

（2）在远程主机上执行指定命令，如查看远程主机指定设备的分区情况。

ssh -p3600 root@9.134.114.170 fdisk -l /dev/vda
root's password: 
Authentication successful.

Disk /dev/vda: 107.4 GB, 107374182400 bytes, 209715200 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xf6abafec

   Device Boot      Start         End      Blocks   Id  System
/dev/vda1              63   209712509   104856223+  83  Linux

（3）通过 ssh 实现免密登录。免密登录的实现过程如下：
在这里插入图片描述

1.在客户端使用 ssh-keygen 生成一对密钥：公钥+私钥；
2.将客户端公钥追加到服务端的 authorized_key 文件中，完成公钥认证操作；
3.认证完成后，客户端向服务端发起登录请求，并传递公钥到服务端；
4.服务端检索 authorized_key 文件，确认该公钥是否存在。如果存在该公钥，则生成随机数 R，并用公钥进行加密，生成公钥加密字符串 pubKey(R)；
5.将公钥加密字符串传递给客户端；
6客户端使用私钥解密公钥加密字符串，得到 R；
7.服务端和客户端通信时会产生一个会话 ID(sessionKey)，用 MD5 对 R 和 SessionKey 进行加密，生成摘要；
8.客户端将生成的 MD5 加密字符串传给服务端；
9.服务端同样生成 MD5(R,SessionKey) 加密字符串；
10.如果客户端传来的加密字符串等于服务端自身生成的加密字符串，则认证成功。此时不用输入密码，即完成建连，可以开始远程执行 Shell 命令了。

第一步使用 ssh-keygen 命令在客户端生成 RSA 公钥和私钥，一直回车确认。公钥和私钥默认名称为 id_rsa.pub（公钥）和私钥（id_rsa），默认保存在 ~/.ssh 目录下。

ssh-keygen -t rsa

第二步将客户端公钥追加至服务端 ~/.ssh/authorized_keys 文件中，authorized_keys 是用来存放客户端公钥的文件。有三种方法，一是通过 ssh-copy-id 命令，二是通过 scp 命令，三是手动复制。例如使用 ssh-copy-id 命令实现如下：

ssh-copy-id -i ~/.ssh/id_rsa.pub -p 3600 root@9.134.114.170

第三步使用 ssh 进行免密登录。

ssh -p3600 root@9.134.114.170

●wget 命令：
1.命令简介

wget 命令是一个非交互式网络下载器，用于从指定 url 下载文件。

wget 是 Linux 环境下流行的强大稳定的下文件下载工具，主要有如下几个特点：
（1）wget 支持的协议丰富，支持 HTTP、HTTPS 和 FTP 协议，可以使用 HTTP 代理；
（2）wget 支持自动下载。wget 是非交互式的，这意味着它可以在后台工作。这意味这你可以登录系统，启动一个 wget 下载任务，然后退出系统，wget 将在后台执行直到任务完成；
（3）wget 支持断点续传，即在下次下载文件时，从已经下载的部分开始继续下载未完成的部分，而没有必要从头开始下载；
（4）wget 对弱网络有很强的适应性，在带宽很窄的情况下和不稳定网络中，如果由于网络的原因下载失败，wget 会不断地尝试，直到整个文件下载完毕。
2.命令格式

wget [OPTION]... [URL]...

3.选项说明

注意，长选项所必须的参数在使用短选项时也是必须的。

基本启动选项
-V,  --version
	显示 wget 的版本信息并退出
-h, --help
	打印帮助
-b, --background
	启动后转入后台执行。如果没有通过 -o 指定输出文件，则将输出重定向到 wget-log
-e,  --execute=COMMAND
	执行命令，就好像命令是 .wgetrc 的一部分一样。命令将在 .wgetrc 中的命令之后执行。如果需要指定多个 .wgetrc 命令，请使用 -e 的多个实例

日志和输入文件选项
-o,  --output-file=LOGFILE
  	将日志信息写入 LOGFILE
-a,  --append-output=LOGFILE
	将日志信息追加至 LOGFILE，而不是覆盖原 LOGFILE
-d, --debug
	打印大量调试信息
-q, --quiet
	安静模式（无信息输出）
-v,  --verbose
	详尽的输出（此为默认设置）
-nv, --no-verbose
	关闭详尽输出，但不进入安静模式。这意味着错误信息和基本信息仍然会被打印出来
-i, --input-file=FILE
	下载本地或外部 FILE 中的 URLs
-F, --force-html
	把输入文件当成 HTML 文件
-B, --base=URL
	将 URL 作为在 -F -i 参数指定的文件中出现的相对链接的前缀

下载选项
--bind-address=ADDRESS
	绑定至本地主机上的 ADDRESS (主机名或是 IP)
-t,  --tries=NUMBER
	设置重试次数为 NUMBER (0 代表无限制)
-O,  --output-document=FILE
	将下载的文档写入 FILE
-nc, --no-clobber
	在同一个目录中下载同一个文件将导致文件的原始副本被保留，第二个副本被命名为 file.1，第三个为 file.2，以此类推
-c,  --continue 
	断点续传下载文件
--progress=TYPE
	选择进度条类型，可取值 dot 和 bar
-N,  --timestamping
	只获取比本地文件新的文件
--no-use-server-timestamps
  	不用服务器上的时间戳来设置本地文件
-S, --server-response
  打印服务器响应
--spider
	不下载任何文件，只检查文件是不是在那里
-T,  --timeout=SECONDS
  	将所有超时设为 SECONDS 秒
--dns-timeout=SECS
	设置 DNS 查寻超时为 SECS 秒
--connect-timeout=SECS
	设置连接超时为 SECS 秒
--read-timeout=SECS
	设置读取超时为 SECS 秒
-w, --wait=SECONDS
	等待间隔为 SECONDS 秒
--waitretry=SECONDS
	在获取文件的重试期间等待 SECONDS 秒
--random-wait
	获取多个文件时，每次随机等待间隔在 0.5*WAIT 至 1.5*WAIT 秒，WAIT 由 -w 选项指定
--no-proxy
	禁止使用代理
-Q, --quota=NUMBER
	设置获取配额为 NUMBER 字节，后缀为 k（千字节）或 m（兆字节）。当下载的文件总大小达到配额后将暂停下载。请注意，配额不会影响下载单个文件。将配额设置为 0 或 inf 不限制下载配额
--limit-rate=RATE
	限制下载速率为 RATE 字节每秒。RATE 可使用后缀 k（千字节）或 m（兆字节）
--no-dns-cache
	关闭 DNS 查寻缓存
--restrict-file-names=MODES
	限定文件名中的字符为 MODES 允许的字符
-4,  --inet4-only
  	仅连接至 IPv4 地址
-6,  --inet6-only
	仅连接至 IPv6 地址
--prefer-family=FAMILY
	首先连接至指定协议的地址。FAMILY 为 IPv6，IPv4 或是 none
--retry-connrefused
	即使拒绝连接也要重试
--user=USER
	将 ftp 和 http 的用户名均设置为 USER
--password=PASS
	将 ftp 和 http 的密码均设置为 PASS
--ask-password
	提示输入密码
--no-iri
	关闭国际化 URI(IRI) 的支持
--local-encoding=ENC
	IRI (国际化资源标识符) 使用 ENC 作为本地编码
--remote-encoding=ENC
	使用 ENC 作为默认远程编码

目录选项
-nd, --no-directories
	不创建目录
-x,  --force-directories
	强制创建目录
-nH, --no-host-directories
	不要创建主目录
--protocol-directories
	在目录中使用协议名称
-P,  --directory-prefix=PREFIX
	以 PREFIX/ 作为前缀来保存文件
--cut-dirs=NUMBER
	忽略远程目录中 NUMBER 个目录层

HTTP 选项
--http-user=USER
	设置 http 用户名为 USER
--http-password=PASS
	设置 http 密码为 PASS
--no-cache
	不在服务器上缓存数据
--default-page=NAME
	改变默认页 (默认页通常是 index.html)
  -E,  --adjust-extension
  	以合适的扩展名保存 HTML/CSS 文档
--ignore-length
	忽略头部的 Content-Length 区域
--header=STRING
	在头部插入 STRING
--max-redirect
	每页所允许的最大重定向
--proxy-user=USER
	使用 USER 作为代理用户名
--proxy-password=PASS
	使用 PASS 作为代理密码
--referer=URL
	在 HTTP 请求头包含 Referer:URL
--save-headers
	将 HTTP 头保存至文件
-U, --user-agent=AGENT
	标识为 AGENT 而不是 Wget/VERSION
--no-http-keep-alive
	禁用 HTTP keep-alive (永久连接)
--no-cookies
	不使用 cookies
--load-cookies=FILE
	会话开始前从 FILE 中载入 cookies
--save-cookies=FILE
	会话结束后保存 cookies 至 FILE
--keep-session-cookies
	载入并保存会话 (非永久) cookies
--post-data=STRING
	使用 POST 方式；把 STRING 作为数据发送
--post-file=FILE
	使用 POST 方式；发送 FILE 内容
--content-disposition
	当选中本地文件名时允许 Content-Disposition 头部 (尚在实验)
--auth-no-challenge
	发送不含服务器询问的首次等待的基本 HTTP 验证信息

HTTPS (SSL/TLS) 选项
--secure-protocol=PR     选择安全协议，可以是 auto、SSLv2、SSLv3 或是 TLSv1 中的一个
--no-check-certificate
	不要验证服务器的证书
--certificate=FILE
	客户端证书文件
--certificate-type=TYPE
	客户端证书类型，PEM 或 DER
--private-key=FILE
       私钥文件
--private-key-type=TYPE
	私钥文件类型，PEM（默认） 或 DER
--ca-certificate=FILE
	带有一组 CA 认证的文件
--ca-directory=DIR
	保存 CA 认证的哈希列表的目录
--random-file=FILE
	带有生成 SSL PRNG 的随机数据的文件
--egd-file=FILE
	用于命名带有随机数据的 EGD 套接字的文件

FTP 选项
--ftp-user=USER
	设置 ftp 用户名为 USER
--ftp-password=PASS
	设置 ftp 密码为 PASS
--no-remove-listing
	不要删除 FTP 检索生成的临时 .list 文件
 --no-glob
 	不在 FTP 文件名中使用通配符展开
--no-passive-ftp
	禁用 passive 传输模式
--retr-symlinks
	递归目录时，获取符号链接指向的文件

递归下载选项
-r,  --recursive
	指定递归下载
-l,  --level=NUMBER
	最大递归深度 (inf 或 0 代表无限制，即全部下载)
--delete-after
	下载完成后删除本地文件
-k,  --convert-links
	让下载得到的 HTML 或 CSS 中的链接指向本地文件
-K,  --backup-converted
	在转换文件 X 前先将它备份为 X.orig
-m, --mirror
	打开适合镜像的选项。此选项打开递归和时间戳，设置无限递归深度，并保留ftp目录列表。等价于 -N -r -l inf --no-remove-listing 选项
-p,  --page-requisites
	下载所有用于显示 HTML 页面的图片之类的元素
--strict-comments
	用严格方式 (SGML) 处理 HTML 注释

递归接受/拒绝选项
-A,  --accept=LIST
	逗号分隔的可接受的扩展名列表
-R,  --reject=LIST
	逗号分隔的要拒绝的扩展名列表
-D,  --domains=LIST
	逗号分隔的可接受的域列表
--exclude-domains=LIST
	逗号分隔的要拒绝的域列表
--follow-ftp
	跟踪 HTML 文档中的 FTP 链接
--follow-tags=LIST
	逗号分隔的跟踪的 HTML 标识列表
--ignore-tags=LIST
	逗号分隔的忽略的 HTML 标识列表
-H,  --span-hosts
	递归时转向外部主机
-L,  --relative
	只跟踪有关系的链接
-I,  --include-directories=LIST
	允许目录的列表
--trust-server-names
	在重定向时，重定向 URL 的最后一个组件将用作本地文件名。默认情况下，它是原始 URL 中的最后一个组件
-X,  --exclude-directories=LIST
	排除目录的列表
-np, --no-parent
	不追溯至父目录
--ignore-case
	匹配文件/目录时忽略大小写

4.常用示例

（1）使用 wget 下载单个文件。比如下载 git for windows。

wget https://github.com/git-for-windows/git/releases/download/v2.25.1.windows.1/Git-2.25.1-32-bit.tar.bz2

wget 虽然有很多选项，但是最常用的是不带任何选项，给定文件的 url 进行下载。

（2）下载单个文件，使用指定的文件名保存。

wget -O GitForWindows.tar.bz2 https://github.com/git-for-windows/git/releases/download/v2.25.1.windows.1/Git-2.25.1-32-bit.tar.bz2

（3）使用 wget -b 将 wget 放在后台执行。

wget -b https://github.com/git-for-windows/git/releases/download/v2.25.1.windows.1/Git-2.25.1-32-bit.tar.bz2
Continuing in background, pid 9369.
Output will be written to 'wget-log'.

对于下载非常大的文件的时候，我们可以使用参数 -b 进行后台下载，可以使用命令tail -f wget-log查看 wget 的日志文件 wget-log 来察看下载进度。

（4）使用 wget -c 断点续传。

wget -c https://github.com/git-for-windows/git/releases/download/v2.25.1.windows.1/Git-2.25.1-32-bit.tar.bz2

使用 wget -c 重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。

（5）使用 wget --spider 测试下载链接。

wget --spider https://github.com/git-for-windows/git/releases/download/v2.25.1.windows.1/Git-2.25.1-32-bit.tar.bz2

（6）现在多个文件。每个文件的下载链接统一存放在一个文件中。

wget -i filelist.txt

（7）使用 wget -o 将下载过程中的日志信息存入到日志文件，而不是输出到终端。

wget -o wget.log https://github.com/git-for-windows/git/releases/download/v2.25.1.windows.1/Git-2.25.1-32-bit.tar.bz2

●useradd 命令:
1.命令简介

useradd 是系统管理员命令，用来创建新用户或更新创建新用户时的默认信息。

如果在创建用户时没有指定密码的话，用户的默认密码是不可用的。所以 useradd 一般与 passwd 命令成对使用，在创建用户后给用户设置密码。
2.命令格式

useradd [options] LOGIN
useradd -D
useradd -D [options]

3.选项说明

-b, --base-dir BASE_DIR
	新账户的主目录的基目录
-c, --comment COMMENT
	新账户的备注信息，备注信息保存在 /etc/passwd 的备注栏中
-d, --home-dir HOME_DIR
	新账户的主目录
-D, --defaults
	显示或更改默认的 useradd 配置
-e, --expiredate EXPIRE_DATE
	新账户的过期日期，日期格式为 YYYY-MM-DD。如果未指定，useradd 将使用在 /etc/default/useradd 中指定的到期日期 EXPIRE，或默认情况下使用空字符串(无过期)
-f, --inactive INACTIVE
	指定在密码过期后多少天即关闭该账号。如果为 0 账号立即被停用；如果为 -1 则账号一直可用。默认值为 -1
-g, --gid GROUP
	指定用户所属的主组。主组必须已经存在
-G, --groups GROUPS
	指定用户所属的附加组，多个组使用逗号分隔
-h, --help
  显示帮助信息并推出
-k, --skel SKEL_DIR
	指定用户的骨架目录。与选项 -m （或 --create-home）联用，骨架目录包含要复制到用户主目录中的文件和目录
-K, --key KEY=VALUE
	不使用 /etc/login.defs 中的默认值（UID_MIN、UID_MAX、UMASK、PASS_MAX_DAYS 等）
-l, --no-log-init
	不要将此用户添加到最近登录和登录失败数据库
-m, --create-home
	创建用户的家目录。useradd 默认会创建 home 目录，除非 /etc/login.defs 中的 CREATE_HOME 设置为no
-M, --no-create-home
	不创建用户的主目录。即使 /etc/login.defs 中的 CREATE_HOME 设置为 yes
-N, --no-user-group
	不创建同名的组
-o, --non-unique
 	允许使用重复的 UID 创建用户
-p, --password PASSWORD 
 	设置账户密码，注意是使用 crypt(3) 加密后的用户密码，不是密码的明文。默认是用户密码不可用。推荐使用 passwd 命令给用户设置密码
-r, --system
  	创建一个系统账户
-R, --root CHROOT_DIR
	设置根目录。在 Linux 系统中，系统默认的根目录是 /
-s, --shell SHELL 
	新账户的登录 Shell
-u, --uid UID
	新账户的用户 ID
-U, --user-group
	创建与用户同名的组，并将用户添加到此组中。为默认动作，除非  /etc/login.defs 中 USERGROUPS_ENAB 被设置为 no 或显示使用选项 -N, --no-user-group
-Z, --selinux-user SEUSER
	为 SELinux 用户映射使用指定 SEUSER

4.常用示例

（1）添加新用户。

useradd dablelv

默认在创建用户时的同时会创建一个同名的用户主组和在 /home 目录下同名的家目录，除非在配置文件 /etc/login.defs 中 USERGROUPS_ENAB 和 CREATE_HOME 被设置为 no。

（2）添加新用户时，显示指明家目录和所属的主组。

useradd -d /home/dablelvH -g root dablelv

添加用户成功后，我们可以使用 id 命令查看用户 dablelv 的用户 ID、主组和附加组。

id dablelv
uid=1000(dablelv) gid=0(root) groups=0(root)

（3）添加新用户后，并使用 passwd 给用户设置密码。

useradd dablelv
passwd dablelv

（4）添加用户，并给用户设置有效期。

useradd -e 2020-12-31 dablelv

（5）使用 useradd -D 查看创建新用户时的默认信息，或直接 cat /etc/default/useradd。

useradd -D
GROUP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes

（6）修改创建新用户时的默认信息。

useradd -D -f 0

#查看是否修改成功
useradd -D | grep INACTIVE
INACTIVE=0

●passwd 命令：
1.命令简介

passwd 令用于设置用户的认证信息，包括用户密码、账户锁定、密码失效等。

系统管理员能用它管理系统用户的密码，只有管理员可以指定用户名称，一般用户只能变更自己的密码。
2.命令格式

passwd [OPTIONS] [USERNAME]

不带任何选项和参数直接运行 passwd 表示修改当前用户的登录密码，这也是 passwd 最常见的用法。
3.选项说明

注意，长选项的必须参数对于短选项也是必须的。

-k, --keep
	保持身份验证令牌不过期
-d, --delete
  删除已命名帐号的密码(仅限 root 用户)
-l, --lock
	锁定指定帐户的密码(仅限 root 用户)。锁定是在密码加密字符串前面加上 ! 使得密码校验不通过。注意，帐户没有完全锁定，用户仍然可以通过其他身份验证方式登录，如 ssh 公钥身份验证
-u, --unlock
	解锁指定账户的密码(仅限 root 用户)
-e, --expire
	终止指定帐户的密码(仅限 root 用户)
-f, --force
	强制执行操作
-x, --maximum=DAYS
	密码的最长有效时限(仅限 root 用户)
-n, --minimum=DAYS
	密码的最短有效时限(仅限 root 用户)
-w, --warning=DAYS
	在密码过期前多少天开始提醒用户(仅限 root 用户)
-i, --inactive=DAYS
	当密码过期后经过多少天该帐号会被禁用(仅限 root 用户)
-S, --status
	报告已命名帐号的密码状态(仅限 root 用户)
--stdin
	从标准输入读取令牌(仅限 root 用户)
-?, --help
  	显示帮助信息并退出
--usage
	显示简要使用信息

4.常用示例

（1）修改当前登陆的账户密码。

passwd

注意，设置用户密码时一定要遵守"复杂性、易记忆性、时效性"的密码规范。简单来讲就是密码要大于 8 位，包含大小写字母、数字和特殊符号，并且容易记忆和定期更换。

（2）修改其他用户密码，需要管理员权限。

passwd USERNAME

（3）锁定指定帐户的密码，使得用户通过密码无法登录。需要管理员权限。

passwd -l USERNAME

（4）解锁指定帐户的密码。需要管理员权限。

passwd -u USERNAME

（5）终止指定帐户的密码，使用户下次登陆强制改密码。需要管理员权限。

passwd -e USERNAME

（6）清除登录密码，使得用户无需通过密码即可登录。需要管理员权限，风险极大，不推荐使用。

passwd -d USERNAME

（7）查询帐号的密码状态。

passwd -S dablelv
dablelv PS 2020-03-08 0 90 7 -1 (Password set, SHA512 crypt.)

显示账户状态信息，共有7个字段，分别是登录名、密码、上次修改时间、密码修改间隔时间(0)、密码有效期(90)、警告时间(7)、密码不失效（-1），单位都是天。

（8）设置密码的最小和最大有效天数。

passwd -x 100 -n 30 dablelv

#查看是否设置成功
passwd -S dablelv
dablelv PS 2020-03-08 30 100 7 -1 (Password set, SHA512 crypt.)

（9） 在密码过期前多少天开始提醒用户。

passwd -w 7 dablelv

●userdel 命令:
1.命令简介

userdel（user delete） 命令是系统管理员命令，用于删除用户账户和相关文件。

其实 userdel 命令实际上是修改了系统的用户账号文件 /etc/passwd、/etc/shadow 以及 /etc/group 文件，这与 Linux 系统“一切操作皆文件”的思想正好吻合。

值得注意的是，如果有该要删除用户相关的进程正在运行，userdel 命令通常不会删除一个用户账号。如果确实必须要删除，可以先终止用户进程，然后再执行userdel命令进行删除。但是 userdel 命令也提供了一个面对该种情况的参数，即 -f 选项。
2.命令格式

userdel [options] LOGIN

若不加选项，则仅删除用户帐号，而不删除相关文件。
3.选项说明

-f, --force
		强制删除用户，即使用户当前已登录
-h, --help
	显示帮助信息并推出
-r, --remove
	删除用户的同时删除与用户相关的所有文件，比如删除主目录和邮件池
-R, --root CHROOT_DIR
  	在 CHROOT_DIR 目录中应用更改并使用 CHROOT_DIR 目录中的配置文件
-Z, --selinux-user
	为用户删除所有的 SELinux 用户映射

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

4.常用示例

（1）删除用户，但不删除其家目录及文件。

userdel tom

（2）删除用户，删除主目录和邮件池。

userdel  -r tom

请不要轻易用 -r 选项，它会删除用户的同时删除用户所有的文件和目录，切记如果用户目录下有重要的文件，在删除前请备份。

（3）强制删除用户。

userdel -f tom

●usermod 命令:
1.命令简介

usermod（user modify）命令是系统管理员命令，用于修改用户账号 。

usermod可用来修改用户账号的各项设定，修改系统账号文件来反映通过命令行指定的变化。
2.命令格式

usermod [OPTIONS] LOGIN

3.选项说明

-c, --comment
	添加备信息
-d, --home HOME_DIR
	用户的新主目录
-e, --expiredate EXPIRE_DATE
	设定帐户过期的日期
-f, --inactive INACTIVE
	过期 INACTIVE 天数后，设定密码为失效状态
-g, --gid GROUP
	强制使用 GROUP 为新主组
-G, --groups GROUPS
	新的附加组列表 GROUPS
-a, --append GROUP
	将用户追加至上边 -G 中提到的附加组中，并不从其它组中删除此用户
-h, --help
	显示此帮助信息并推出
-l, --login LOGIN
	新的登录名称
-L, --lock
	锁定用户帐号
-m, --move-home
	将家目录内容移至新位置 (仅于 -d 一起使用)
-o, --non-unique
	允许使用重复的(非唯一的) UID
-p, --password PASSWORD
	将加密过的密码 (PASSWORD) 设为新密码
-s, --shell SHELL
	该用户帐号的新登录 shell
-u, --uid UID
  	用户帐号的新 UID
-U, --unlock
	解锁用户帐号
-Z, --selinux-user  SEUSER
	用户账户的新 SELinux 用户映射

4.常用示例

（1）修改用户的家目录。

usermod -d /home/tom tom

（2）改变用户的 uid。

usermod -u 888 tom

（3）修改用户名为 jerry。

usermod -l jerry tom

（4）锁定 tom 用户。

usermod -L tom

（5）解锁 tom 用户。

usermod -U tom

（6）添加新的附加组。

usermod -G deng tom

（7）修改用户登录 Shell。

usermod -s /bin/sh tom

（8）修改用户的 GID。

usermod -g 1003 tom

（9）指定帐号过期日期。

usermod -e 2020-12-31 tom

（10）指定用户帐号密码过期多少天后，禁用该帐号。

usermod -f 3 tom

●groupadd 命令：
1.命令简介

groupadd 命令是系统管理员命令，用于创建一个新组。

groupadd 命令使用命令行上指定的值以及系统中的默认值创建一个新的组帐户。新组将根据需要被添加到系统文件中。
2.命令格式

groupadd [OPTIONS] GROUP

3.常用选项

  -f, --force
  	如果组已经存在则成功退出并且如果 GID 已经存在则取消 -g
  -g, --gid GID
  	为新组使用 GID
  -h, --help
  	显示帮助信息并推出
  -K, --key KEY=VALUE
  	不使用 /etc/login.defs 中的默认值
  -o, --non-unique
  	允许创建有重复 GID 的组
  -p, --password PASSWORD
  	为新组使用加密过的密码
  -r, --system
  	创建一个系统组

4.参考示例

（1）添加一个用户组。

groupadd  g1

（2）添加一个用户组并指定GID。

groupadd -g 888 g2

（3）使用 -r 创建系统工作组。

groupadd -r -g 889 g3

（4）允许创建有重复 GID 的组。

groupadd -o -r -g 889 g4

#查看新创建的用户组
tail -n 3 /etc/group
g2:x:888:
g3:x:889:
g4:x:889:

（5）为新组使用加密过的密码。

groupadd -p $6$6B3fQyRr$DWk9/i2ly/8IFNA8lNReCAve6eODSGuvOD2Y2q/NGZXGgaQ9j/APs0TpA3b5nPg2VcuDyHVCz.d8zpeJYJar./ g5

5.相关文件

/etc/group		#群组信息
/etc/gshadow	#群组加密信息

●groupdel 命令：
1.命令简介

groupdel（group delete）命令是系统管理员命令，用于删除一个组。

groupdel 命令用于删除指定的工作组，本命令要修改的系统文件包括 /ect/group 和 /ect/gshadow。
2.命令格式

groupdel [OPTIONS] GROUP

3.常用选项

-h, --help
  	显示此帮助信息并推出

4.常用示例

（1）删除用户组

groupdel g1

（2）查看帮助信息。

●groupmod 命令：
1.命令简介

groupmod（group modify）是系统管理员命令，用于更改群组识别码或名称。

不过大家还是要注意，用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。
2.命令格式

groupmod [OPTIONS] GROUP

3.选项说明

-g, --gid GID
	将组 ID 改为 GID
-h, --help
	显示此帮助信息并推出
-n, --new-name NEW_GROUP
	改名为 NEW_GROUP
-o, --non-unique
	允许使用重复的 GID
-p, --password PASSWORD
	将密码更改为(加密过的) PASSWORD

4.常用示例

（1）改用户组 ID。

groupmod -g 8888 g5

#参看是否修改成功
tail -3 /etc/group
g3:x:889:
g4:x:889:
g5:x:8888:

（2）更改用户组名。

groupmod -n heima g5

#查看是否修改成功
tail -5 /etc/group
g3:x:889:
g4:x:889:
heima:x:8888:

（3）更改用户组密码。

groupmod -p $6$6B3fQyRr$DWk9/i2ly/8IFNA8lNReCAve6eODSGuvOD2Y2q/NGZXGgaQ9j/APs0TpA3b5nPg2VcuDyHVCz.d8zpeJYJar./ heima

（4）允许使用重复的 GID。

groupmod -g 8888 -o g4

#查看是否修改成功
tail -3 /etc/group
g3:x:889:
g4:x:8888:
heima:x:8888:

●gpasswd 命令：
1.命令简介

gpasswd 是Linux下工作组文件 /etc/group 和 /etc/gshadow 管理工具。

系统管理员可以使用 -a 选项定义组管理员，使用 -m 选项定义成员，由组管理员用组名调用的 gpasswd 只提示输入组的新密码。
2.命令格式

gpasswd [OPTIONS] GROUP

3.选项说明

-a, --add USER
	向组 GROUP 中添加用户 USER
-d, --delete USER
	从组 GROUP 中添加或删除用户
-h, --help
	显示此帮助信息并退出
-r, --delete-password
	删除组密码
-R, --restric	t
向其成员限制访问组 GROUP
-M, --members USER,...
	设置组 GROUP 的成员列表
-A, --administrators ADMIN,...
	设置组的管理员列表

4.常用示例

（1）向组 test 中添加用户 itcast。

gpasswd -a itcast test

（2）从组 test 中删除用户。

gpasswd -d itcast test

（3）移除组的密码。

gpasswd  -r test

（4）设置组的管理员列表。

gpasswd -A deng test

（5）给用户组创建密码。

gpasswd test

●curl 命令：
1.命令简介

curl 命令是一个利用 URL 规则在 Shell 终端命令行下工作的文件传输工具。它支持文件的上传和下载，是综合传输工具，但按使用习惯，一般称 curl 为下载工具。curl 被设计为无需用户交互即可工作。

作为一款强力的下载工具，curl 支持包括 HTTP、HTTPS、FTP、SFTP、SCP 等众多协议，还提供了大量有用的技巧，如代理支持、用户身份验证、FTP 上传、HTTP post、SSL 连接、cookies、文件传输恢复、Metalink 等等。

一般我们使用 curl 作为 HTTP(s) 的客户端访问指定链接。
2.命令格式

curl [OPTIONS] [URL...]

3.选项说明

-#, --progress-bar
	显示进度条
-a, --append
	上传文件时，附加到目标文件
-A, --user-agent STRING
	设置用户代理发送给服务器
--anyauth
	可以使用“任何”身份验证方法
-b, --cookie <NAME=STRING/FILE>
	cookie 字符串或文件读取位置
--basic
	使用 HTTP 基本验证
-B, --use-ascii
	使用 ASCII 文本传输
-c, --cookie-jar FILE
	操作结束后把 cookie 写入指定文件中
-C, --continue-at OFFSET
	断点续转
-d, --data DATA
	以 HTTP POST 方式传送指定格式的数据。如 JSON 串，相应地 Header 中的 Content-Type 字段需设为 application/json。如果传输文件，使用选项 -T
--data-ascii DATA
	以 ascii 的方式 post 数据
--data-binary DATA
	以二进制的方式 post 数据
--negotiate
	使用 HTTP 身份验证
--digest
	使用数字身份验证
--disable-eprt
	禁止使用 EPRT 或 LPRT
--disable-epsv
	禁止使用 EPSV
-D, --dump-header FILE
	把 header 信息写入到指定文件中
--egd-file FILE
 	为随机数据(SSL)设置EGD socket路径
--tcp-nodelay
	使用 TCP_NODELAY 选项
-e, --referer
	来源网址
-E, --cert CERT[:PASSWD]
	客户端证书文件和密码 (SSL)
 --cert-type TYPE
 	证书文件类型 (DER/PEM/ENG) (SSL)
--key KEY
	私钥文件名 (SSL)
--key-type TYPE
	私钥文件类型 (DER/PEM/ENG) (SSL)
--pass PASS
	私钥密码 (SSL)
--engine NAME
	选择用于密码操作的OpenSSL加密引擎
--cacert FILE
	CA 证书 (SSL)
--capath <directory>	CA目录 (made using c_rehash) to verify peer against (SSL)
--ciphers LIST
	SSL 密码
--compressed
	要求返回是压缩的形势 (using deflate or gzip)
--connect-timeout SECONDS
	设置最大请求时间
--create-dirs
	建立本地目录的目录层次结构
--crlf
	上传是把 LF 转变成 CRLF
-f, --fail
	连接失败时不显示 http 错误
--ftp-create-dirs
	如果远程目录不存在，创建远程目录
--ftp-method [multicwd/nocwd/singlecwd]
	控制 CWD 的使用
--ftp-pasv
	使用 PASV/EPSV 代替端口
--ftp-skip-pasv-ip
	使用 PASV 的时候，忽略该IP地址
--ftp-ssl
	尝试用 SSL/TLS 来进行 ftp 数据传输
--ftp-ssl-reqd
	要求用 SSL/TLS 来进行 ftp 数据传输
-F, --form NAME=CONTENT
	模拟 http 表单提交数据
--form-string NAME=STRING
	模拟 http 表单提交数据
-g, --globoff
	禁用网址序列和范围使用 {} 和 []
-G, --get
	以get的方式来发送数据
-H, --header LINE
	自定义头信息传递给服务器
--ignore-content-length
	忽略的 HTTP 头信息的长度
-i, --include
	输出时包括 protocol 头信息
-I, --head
	只显示请求头信息
-j, --junk-session-cookies
	读取文件进忽略 session cookie
--interface INTERFACE
	使用指定网络接口/地址
--krb4 LEVEL
	使用指定安全级别的 krb4
-k, --insecure
	允许不使用证书到SSL站点
-K, --config
	指定的配置文件读取
-l, --list-only
	列出ftp目录下的文件名称
--limit-rate RATE
	设置传输速度
--local-port NUM[-NUM]
	强制使用本地端口号
-L, --location
	如果（HTTP/HTTPS）服务器报告请求的页面已移动到其他位置，此选项将使 curl 在新位置上重做请求。使用身份验证时，curl 只将其凭据发送到初始主机。如果重定向将 curl 转移到其他主机，它将无法截获用户+密码。另请参见选项 --location-trusted，了解如何更改此设置。您可以使用--max-redirs 选项限制要执行的重定向次数
--location-trusted
	（HTTP/HTTPS）类似于-L，--location，但允许向站点可能重定向到的所有主机发送名称+密码。这可能会导致安全漏洞因为如果使用 HTTP 协议明文传输用户名+密码
-m, --max-time SECONDS
	设置请求处理超时时间（含建立连接的耗时）
--max-redirs NUM
	设置最大重定向次数
--max-filesize BYTES
	设置最大下载的文件总量
-M, --manual
	显示全手动
-n, --netrc
	从 netrc 文件中读取用户名和密码
--netrc-optional
	使用 .netrc 或者 URL来覆盖 -n
--ntlm
	使用 HTTP NTLM 身份验证
-N, --no-buffer
	禁用缓冲输出
-o, --output FILE
	把输出写到指定文件中
-O, --remote-name
	把输出写到与远程文件同名的本地文件中
-p, --proxytunnel
	使用 HTTP 代理
--proxy-anyauth
	选择任一代理身份验证方法
--proxy-basic
	在代理上使用基本身份验证
--proxy-digest
	在代理上使用数字身份验证
 --proxy-ntlm
 	在代理上使用 ntlm 身份验证
-P, --ftp-port ADDRESS
	使用端口地址，而不是使用PASV
-q, --disable
	作为第一个参数，关闭 .curlrc
-Q, --quote CMD
	文件传输前，发送命令到服务器
-r/--range RANGE
	检索来自HTTP/1.1或FTP服务器字节范围
--range-file
	读取（SSL）的随机文件
-R, --remote-time
	在本地生成文件时，保留远程文件时间
--retry NUM
	传输出现问题时，重试的次数
--retry-delay SECONDS
	传输出现问题时，设置重试间隔时间
--retry-max-time SECONDS
	传输出现问题时，设置最大重试时间
-s, --silent
	静默模式。不输出任何东西
-S, --show-error
	显示错误
--socks4 HOST[:PORT]
	用 socks4 代理给定主机和端口
--socks5 HOST[:PORT]
	用 socks5 代理给定主机和端口
--stderr FILE
	将对 stderr 的所有写入重定向到指定的文件
-t, --telnet-option OPT=VAL
	Telnet 选项设置
--trace FILE
	对指定文件进行 debug
--trace-ascii FILE
	启用对所有传入和传出数据（包括描述性信息）的完整跟踪转储到给定文件。使用“-”作为文件名将输出发送到 stdout
--trace-time
	跟踪详细输出时，添加时间戳
-T, --upload-file FILE
	上传文件
--url URL
	指定要提取的 URL
-u, --user USER[:PASSWORD]
	设置服务器的用户和密码
-U, --proxy-user USER[:PASSWORD]
	设置代理用户名和密码
-v, --verbose
	打印更多信息，主要用于调试
-V, --version
	显示有关 curl 及其使用的 libcurl 版本的信息
-w, --write-out FORMAT
	什么输出完成后
-x, --proxy HOST[:PORT]
	在给定的端口上使用HTTP代理
-X, --request COMMAND
	指定与 HTTP 服务器通信时使用的自定义请求方法，默认为 GET
-y, --speed-time
	放弃限速所要的时间，默认为30
-Y, --speed-limit
	停止传输速度的限制，速度时间

4.常用示例

    发起 HTTP GET 请求。注意 GET 请求可以携带包体。

curl -X GET 'http://9.138.158.214:10000?advertiser_id=93&auth_code=AUTH_CODE' -H 'Content-Type:application/json' -d '{"action_time":1591100087,"ad_id":"101642"}'

如果 URL 携带参数，需要使用单引号或双引号将 URL 引起来，因为字符 & 是 Shell 特殊字符，或者使用反斜杠对其转义。

    获取网页数据。

curl https://www.baidu.com

执行后，百度官网的网页内容就会显示在屏幕上了。

    保存网页内容。

curl https://www.baidu.com > baidu_index.html
# 或
curl https://www.baidu.com -o baidu_index.html

    静默模式下载文件。注意 URL 在最后要具体到某个文件，不然无法下载。

curl -s -O  https://dl.softmgr.qq.com/original/im/QQ9.3.3.27011.exe

    下载文件时显示进度条。

curl -#  -O  https://dl.softmgr.qq.com/original/im/QQ9.3.3.27011.exe
######################################################################## 100.0%

    访问需要授权的页面时，可通过 -u 选项提供用户名和密码进行授权。

curl -u root  https://github.com/jindeng/sz14.git
Enter host password for user 'root':

    只打印响应头部信息。

curl (-I | --head) https://github.com/jindeng/sz14.git

    限制 curl 的下载速度。

curl URL --limit-rate 50k

使用 --limit-rate 限制 curl 的下载速度，命令中用 k（千字节）和 m（兆字节）指定下载速度限制。

    指定可下载的最大文件大小。

curl URL --max-filesize bytes

使用 --max-filesize 指定可下载的最大文件大小，如果文件大小超出限制，命令则返回一个非 0 退出码，如果命令正常则返回 0。

    用 curl 设置用户代理。

curl URL -A "Mozilla/5.0"

有些网站访问会提示只能使用 IE 浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用 -A 或者 --user-agent 选项。

    自定义头信息传递给服务器。使用多个 -H 选项可传递多个头部信息。

curl -H "Host:man.linuxde.net" -H "accept-language:zh-cn" URL

    curl 设置 cookies。使用 --cookie 选项来指定 cookie，多个 cookie 使用分号分隔。

curl URL --cookie "user=root;pass=123456"

将 cookie 另存为一个文件，使用 --cookie-jar 选项。

curl URL --cookie-jar cookie_file

    curl 设置参照页字符串。使用 --referer 选项指定参照页字符串。

curl --referer URL1 URL2

参照页是位于 HTTP 头部中的一个字符串，用来表示用户是从哪个页面到达当前页面的，如果用户点击网页 A 中的某个连接，那么用户就会跳转到B网页，网页 B 头部的参照页字符串就包含网页 A 的 URL。

    断点续传。curl 能够从特定的文件偏移处继续下载，它可以通过指定一个便移量来下载部分文件。

curl URL/File -C OFFSET

偏移量是以字节为单位的整数，如果让 curl 自动推断出正确的续传位置使用：

curl -C - URL

    连接失败时不显示 http 错误。

curl -f https://unknow.com

    通过 ftp 上传。

curl -T test.sql ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/ 

    通过 ftp下载。

curl -u 用户名:密码 -O URL

●strace 命令:
1.命令简介

strace 命令是一个集诊断、调试、统计于一体的工具，我们可以使用 strace 跟踪程序的系统调用和信号传递来对程序进行分析，以达到解决问题或者是了解程序工作过程的目的。当然 strace 与专业的调试工具比如说 gdb 之类的是没法相比的，因为它不是一个专业的调试器。

strace 的最简单的用法就是执行一个指定的命令，在指定的命令结束之后它也就退出了。在命令执行的过程中，strace 会记录和解析进程的所有系统调用以及这个进程所接收到的所有信号值。
2.命令格式

strace [OPTIONS] command [ARGS]

3.选项说明

-c
	统计每个系统调用的时间、次数和错误，并在程序退出时报告摘要
-C
	类似于 -c，但在进程运行时也打印常规输出
-D
	将跟踪进程作为分离的孙进程运行，而不是作为跟踪对象的父进程运行。这通过保持跟踪对象是调用进程的直接子进程来减少 strace 的可见效果
-d
	输出 strace 关于标准错误的调试信息
-f
	跟踪由 fork(2), vfork(2) and clone(2) 调用所产生的子进程
-ff
	如果提供 -o FILENAME，则所有进程的跟踪结果输出到相应的 FILENAME.pid 中，pid 是各进程的进程号 
-F
	该选项已废弃，作用等同于 -f
-h
	输出简要的帮助信息
-i
	在系统调用时打印指令指针
-q
	禁止附加、分离等信息。当输出被重定向到文件并直接运行命令而不是附加命令时，这将自动发生
-qq
	如果给定两次，则禁止关于进程退出状态的消息
-r
	在每次系统调用进入时打印相对时间戳。它记录连续系统调用开始之间的时间差
-t
	在输出中的每一行前加上时间信息
-tt
	如果给定两次，在输出中的每一行前加上微秒级的时间信息
-ttt
	如果给定三次，则打印的时间将包括微秒，并且开始部分将打印自纪元以来的秒数
-T
	显示每一系统调用所耗的时间 
-v
	输出所有的系统调用。一些调用关于环境变量，状态，输入输出等调用，由于使用频繁默认不输出
-V
	输出 strace 的版本信息.
-x
	以十六进制形式输出非标准字符串
-xx
	所有字符串以十六进制形式输出
-y
	与文件描述符参数关联的打印路径
-a COLUMN
	设置返回值的输出位置，默认为40
-b SYSCALL
	如果达到指定的系统调用，与跟踪进程分离。目前，只支持 execve。如果希望跟踪多线程进程，因此需要 -f，但不希望跟踪其（可能非常复杂的）子进程，则此选项非常有用
-e EXPR
	指定一个表达式，用来控制如何跟踪。格式如下: 
	[qualifier=][!]value1[,value2]... 
	qualifier 只能是 trace, abbrev, verbose, raw, signal, read, write 其中之一。value 是用来限定的符号或数字。默认的 qualifier 是 trace，感叹号是否定符号。例如：-e open 等价于 -e trace=open，表示只跟踪 open 调用。而 -etrace=!open 表示跟踪除了 ope 以外的所有其他调用。有两个特殊的符号 all 和 none，分别表示跟踪所有和不跟踪任何系统调用。注意有些 Shell 使用 ! 来执行历史记录里的命令，所以要使用反斜杠对 ! 进行转义
-e trace=SET
	只跟踪指定的系统调用。例如: -e trace=open,close,rean,write 表示只跟踪这四个系统调用，默认的为 trace=all 
-e trace=file
	只跟踪有关文件操作的系统调用
-e trace=process 
	只跟踪有关进程控制的系统调用
-e trace=network 
	跟踪与网络有关的所有系统调用
-e strace=signal
	跟踪所有与系统信号有关的系统调用 
-e trace=ipc 
	跟踪所有与进程通讯有关的系统调用
-e trace=desc
	跟踪所有与文件描述符相关的系统调用
-e trace=memory
	跟踪所有与内存映射相关的系统调用
-e abbrev=SET
	缩写打印大型结构的每个成员的输出。默认值是 abbrev=all。-v 选项的效果是 abbrev=none
-e verbose=SET
	为指定的系统调用集取消引用结构。默认是 verbose=all
-e raw=SET
	将指定的系统调用的参数以十六进制显示
-e signal=SET
	指定跟踪的系统信号，默认为 signal=all。如 signal=!SIGIO（或 signal=!io），表示不跟踪 SIGIO 信号
-e read=SET
	输出从指定文件描述符中读出的数据。例如：-e read=3,5
-e write=SET
	输出写入到指定文件中的数据
-o FILENAME
	将 strace 的输出写入指定文件
-O OVERHEAD
	将跟踪系统调用的开销设置为指定的微秒
-p PID
	跟踪指定的进程
-P PATH
	只跟踪系统调用的访问路径。多个 -P 选项可用于指定多个路径
-s STRSIZE
	指定输出的字符串的最大长度，默认为 32。注意，文件名不被认为是字符串，总是全部打印
-S SORTBY
	根据指定的条件对 -c 选项打印的直方图的输出进行排序。SORTBY 合法值是 time、calls、name 和 nothing，默认值是 time
-u USERNAME
	以指定用户的 UID、GID 和补充组执行被跟踪的命令
-E VAR=VAL
 	为命令设置环境变量
 -E VAR
 	从继承的环境变量列表中删除变量 VAR，然后将其传递给命令

4.常用示例

现在我们做一个很简单的程序来演示 strace 的基本用法。这个程序的 C 语言代码如下：

#include<stdio.h>
int main()
{
        int a = 0;
        printf("please input:\n");
        scanf("%d", &a);
        printf("%10d\n", a);      
        return 0;
}

通过 gcc 编译，默认生成名为 a.out 的可执行程序。

gcc main.c

（1）追踪系统调用。

strace -o strace.out ./a.out

输入 4 然后回车生成 strace 的输出文件 strace.out，其内容如下：

execve("./a.out", ["./a.out"], [/* 28 vars */]) = 0
brk(0)                                  = 0x1e79000
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff4e9feb000
access("/etc/ld.so.preload", R_OK)      = 0
open("/etc/ld.so.preload", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=18, ...}) = 0
mmap(NULL, 18, PROT_READ|PROT_WRITE, MAP_PRIVATE, 3, 0) = 0x7ff4e9fea000
close(3)                                = 0
readlink("/proc/self/exe", "/root/test/c++/strace/a.out", 4096) = 27
open("/lib64/libonion.so", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0`\20\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=42880, ...}) = 0
mmap(NULL, 1072448, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ff4e9ee4000
mprotect(0x7ff4e9ee7000, 1048576, PROT_NONE) = 0
mmap(0x7ff4e9fe7000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x3000) = 0x7ff4e9fe7000
mmap(0x7ff4e9fe8000, 7488, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ff4e9fe8000
close(3)                                = 0
munmap(0x7ff4e9fea000, 18)              = 0
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=74350, ...}) = 0
mmap(NULL, 74350, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7ff4e9ed1000
close(3)                                = 0
open("/lib64/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\20\35\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2122016, ...}) = 0
mmap(NULL, 3944896, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ff4e9a07000
mprotect(0x7ff4e9bc1000, 2093056, PROT_NONE) = 0
mmap(0x7ff4e9dc0000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b9000) = 0x7ff4e9dc0000
mmap(0x7ff4e9dc6000, 16832, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ff4e9dc6000
close(3)                                = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff4e9fea000
open("/lib64/libdl.so.2", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0`\16\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=19344, ...}) = 0
mmap(NULL, 2109744, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ff4e9803000
mprotect(0x7ff4e9805000, 2097152, PROT_NONE) = 0
mmap(0x7ff4e9a05000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7ff4e9a05000
close(3)                                = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff4e9ecf000
arch_prctl(ARCH_SET_FS, 0x7ff4e9ecf740) = 0
mprotect(0x7ff4e9dc0000, 16384, PROT_READ) = 0
mprotect(0x7ff4e9a05000, 4096, PROT_READ) = 0
mprotect(0x600000, 4096, PROT_READ)     = 0
mprotect(0x7ff4e9fec000, 4096, PROT_READ) = 0
munmap(0x7ff4e9ed1000, 74350)           = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff4e9ee3000
write(1, "please input:\n", 14)         = 14
fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff4e9ee2000
read(0, "4\n", 1024)                    = 2
write(1, "         4\n", 11)            = 11
exit_group(0)                           = ?
+++ exited with 0 +++

从跟踪的结果可以看到，系统首先调用 execve 开始一个新的进程，接着进行环境的初始化操作，最后停顿在read(0, "4\n", 1024) = 2，这也就是执行到了 scanf 函数，等待我们输入数字。在输入完 4 之后，再调用 write 函数将格式化后的数值 4输出到屏幕，最后调用 exit_group 退出进程，完成整个程序的执行过程。

（2）跟踪信号传递。我们还是使用上面的 a.out 程序，来观察进程接收信号的情况，即跟踪进程和信号相关的系统调用。

#开启跟踪
strace -e trace=signal -o strace.out ./a.out

#查找进程 ./a.out 进程 ID
ps -ef | grep a.out | grep -v "grep\|strace"
root     10787 10784  0 22:46 pts/1    00:00:00 ./a.out

#根据上一步查到的进程 ID 通过 kill 命令发送信号 SIGKILL
kill -9 10787

再次查看 strace 的输出文件 strace.out 的内容。

--- SIGWINCH {si_signo=SIGWINCH, si_code=SI_KERNEL} ---
--- SIGWINCH {si_signo=SIGWINCH, si_code=SI_KERNEL} ---
+++ killed by SIGKILL +++

进程被杀退出时，strace 会输出 killed by SIGX（SIGX 代表发送给进程的信号）等，那么进程自己退出时会输出什么呢？

这里有个叫做 test_exit 的程序，其代码如下:

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
       exit(1);
}

我们 strace 看下它退出时 strace 上能看到什么痕迹。

strace -tt -e trace=process -f ./test_exit

-e trace=process 表示只跟踪和进程管理相关的系统调用。

输出：

23:07:24.672849 execve("./test_exit", ["./test_exit"], [/* 35 vars */]) = 0
23:07:24.674665 arch_prctl(ARCH_SET_FS, 0x7f1c0eca7740) = 0
23:07:24.675108 exit_group(1)           = ?
23:07:24.675259 +++ exited with 1 +++

可以看出，进程自己退出时（调用 exit 函数，或者从 main 函数返回）, 最终调用的是 exit_group系统调用， 并且 strace 会输出 exited with X（X为退出码）。

可能有人会疑惑，代码里面明明调用的是 exit, 怎么显示为 exit_group?

这是因为这里的 exit 函数不是系统调用，而是 glibc 库提供的一个函数，exit 函数的调用最终会转化为 exit_group 系统调用，它会退出当前进程的所有线程。实际上，有一个叫做 _exit() 的系统调用（注意 exit 前面的下划线）线程退出时最终会调用它。

（3）系统调用统计。strace 不光能追踪系统调用，通过使用参数 -c，它还能将进程所有的系统调用做一个统计分析给你，下面来看看 strace 对系统调用的统计。

strace -c ./a.out
please input:
4
         4
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
100.00    0.000038           3        15           mmap
  0.00    0.000000           0         4           read
  0.00    0.000000           0         2           write
  0.00    0.000000           0         5           open
  0.00    0.000000           0         5           close
  0.00    0.000000           0         7           fstat
  0.00    0.000000           0         7           mprotect
  0.00    0.000000           0         2           munmap
  0.00    0.000000           0         1           brk
  0.00    0.000000           0         1           access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         1           readlink
  0.00    0.000000           0         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0.000038                    52           total

这里很清楚的告诉你调用了那些系统函数，调用次数多少，消耗了多少时间等等这些信息，这个对我们分析一个程序来说是非常有用的。

（4）trace 一个现有的进程。strace 不光能自己初始化一个进程进行 trace，还能使用 -p 选项追踪现有的进程。具体用法如下：

strace -p PID

●nc 命令：
1.命令简介

nc（netcat）是一个短小精悍、功能实用、简单可靠的网络工具，主要有如下作用：
（1）端口侦听，nc 可以作为 server 以 TCP 或 UDP 方式侦听指定端口；
（2）端口扫描，nc 可以作为 client 发起 TCP 或 UDP 请求；
（3）机器之间传输文件；
（4）机器之间网络测速。

nc 实际上是 ncat 的软链接。ncat 是为 Nmap(Network Mapper) 项目编写的，是 Nmap 套件中的一员，它旨在成为可靠的后端工具，可立即为其他应用程序和用户提供网络连接。ncat 不仅可以使用 IPv4 和 IPv6，还可以为用户提供几乎无限的潜在用途。

Nmap 是
2.命令格式

nc [-46DdhklnrStUuvzC] [-i interval] [-p source_port] [-s source_ip_address] [-T ToS] [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]] [hostname] [port[s]]

3.选项说明

-4/6
	强制只使用 IPv4/IPv6 地址
-D
	在套接字上启用调试
-d
	不从 stdin 读取
-h
	打印出帮助信息
-k
	强制 nc 在当前连接完成后继续侦听另一个连接。注意如果不使用 -l 选项，则使用此选项是错误的
-l
	指定 nc 应该侦听传入的连接，而不是启动到远程主机的连接。将此选项与 -p、-s 或 -z 选项结合使用是错误的。此外，使用 -w 选项指定的超时将被忽略
-n
	不要在任何指定的地址、主机名或端口上执行任何 DNS 或服务查找
-r
	随机选择源端口和目标端口，而不是按照系统分配的顺序或范围内的顺序选择它们
-S
	启用 RFC 2385 TCP MD5 签名选项
-t
	使 nc 发送 RFC 854 DON'T 和 WON'T 响应 RFC 854 的 DO 和 WILL 请求。这使得使用 nc 编写 telnet 会话脚本成为可能
-U
	指定使用 Unix 域套接字
-u
	使用 UDP 代替默认选项 TCP
-v
	显示命令执行过程
-z
	表示 zero，只扫描侦听守护进程，而不向它们发送任何数据。此选项与 -l 选项结合使用是错误的
-C
	发送 CRLF 作为换行符
-i interval
	指定发送和接收的文本之间的延迟时间间隔。还可指定连接到多个端口之间的延迟时间
-p source_port
	指定 nc 应使用的源端口，但须受特权限制和可用性限制。将此选项与 -l 选项结合使用是错误的
-s source_ip_address
	设置本地主机送出数据包的 IP 地址。注意将此选项与 -l 选项结合使用是错误的
-T ToS
	指定连接的 IP 服务类型(TOS)。有效值是标记 ''lowdelay'', ''throughput'', ''reliability''，或以 0x 开头的 8 位十六进制值
-w timeout
	如果连接和 stdin 空闲超过指定秒数，则连接将被关闭。-w 标志对 -l 选项没有影响。缺省不超时
-X proxy_protocol
	请求 nc 在与代理服务器对话时使用指定的协议。支持的协议是 “4”(SOCKsv.4)、“5”(SOCKV.5) 和 “connect”(HTTPS proxy)。如果未指定协议，则使用 SOCKS v.5
-x proxy_address[:port]
	使用指定代理服务器地址和端口连接到主机。如果未指定端口，则使用代理协议的已知端口（SOCKS为1080，HTTPS为3128）

nc 的控制参数不少，常用的几个参数如下所列：

-l
	指定 nc 将处于侦听模式。指定该参数，则意味着 nc 被当作 server，侦听并接受连接，而非向其它地址发起连接
-p PORT
	指定 nc 使用的源端口
-s 
	指定发送数据的源 IP 地址，适用于多网卡机器
-u
	指定 nc 使用 UDP 协议，默认为 TCP
-v
	输出交互或出错信息，新手调试时尤为有用
-w
	超时秒数，后面跟数字 
-z
	表示 zero，扫描时不发送任何数据

4.常用示例

（1）通过 ll 命令查看 nc 命令。

lrwxrwxrwx 1 root root 4 Aug 30 22:33 /usr/bin/nc -> ncat

（2）监听本地端口。
假设在当前命令行终端 A 进行监听。

nc -vl 8888
Ncat: Version 6.40 ( http://nmap.org/ncat )
Ncat: Listening on :::8888
Ncat: Listening on 0.0.0.0:8888

开启另外一个命令行终端 B，同样使用 nc 发起连接。

nc -v 127.0.0.1 8888

另一个终端 A 将会收到请求并打印连接信息：

Ncat: Connection from 127.0.0.1.
Ncat: Connection from 127.0.0.1:37229.

如果在终端 B 输入内容，那么终端 A 将收到终端 B 发送的内容并打印到标准输出。

（3）利用 nc 之间的连接进行文件传输。
使用 nc 传输文件还是比较方便的，因为不用 scp 和 rsync 那种输入密码的操作了。把 A 机器上的一个文本文件发送到 B 机器上
需注意操作次序，receiver 先侦听端口，sender 向 receiver 所在机器的该端口发送数据。

receiver：

nc -l 8888 > received.txt

sender:

nc 127.0.0.1 8888 < file.txt

receiver 接收完毕，会自动退出监听。接收文件与原文件 md5 值相同，表示文件接收成功。

md5sum file.txt
8f6aab448ec32637b84c3484a1a44e0b  file.txt

md5sum received.txt
8f6aab448ec32637b84c3484a1a44e0b  received.txt

（4）利用 nc 传输目录。
发送目录与发送文件类似，只不过是利用 tar 先将目录打包成一个文件，然后发送。接收方再利用 tar 进行解压缩还原为目录。

receiver：

nc -l 8888 | tar -xzvf -

sender：

tar -czvf - DIR_NAME | nc 127.0.0.1 8888

注意，tar -f 选项后跟横杠 - 表示从标准输入读取或将结果输出到标准输出。

（5）测试网速。
测试网速其实利用了传输文件的原理，就是把来自一台机器的 /dev/zero 发送给另一台机器的 /dev/null
就是把一台机器的无限个 0，传输给另一个机器的空设备上，然后新开一个窗口使用 dstat 命令监测网速
在这之前需要保证机器先安装 dstat 工具。

yum install -y dstat

第 1 步，在 A 机器先启动接收数据的命令，监听自己的 8888 端口，把来自这个端口的数据都输出给空设备（这样不写磁盘，测试网速更准确）。

nc -l 8888 > /dev/null

第 2 步，在 B 机器发送数据，把无限个 0 发送给 A 机器的 8888 端口。

nc 10.0.1.161 8888 < /dev/zero

在 A 机器新的窗口上使用 dstat 命令查看当前网速。dstat 命令比较直观，它可以查看当前 CPU，磁盘，网络，内存页和系统的一些当前状态指标。我们只需要关注 recv 和 send 两列，分别表示接收和发送的数据，另外注意数字后面的单位 B，KB，MB。

在这里插入图片描述
5.FAQ

使用 nc 测试网速时，如果是在同一台机器发送数据，即：

nc 127.0.0.1 8888 < /dev/zero

那么 receiver 将无法收到数据，具体原因还未找到，有知道的网友也麻烦留言告知，万分感谢。

●nslookup 命令：
1.命令简介

nslookup（Name Server Lookup）是一种网络管理命令，用于从 DNS 服务器查询域名、IP 或其他 DNS 记录信息。

nslookup 有两种工作模式，交互模式和非交互模式。在交互模式下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。在非交互模式下，针对一个主机或域名仅仅获取特定的名称或所需信息。

进入交互模式有两种方式：
（1）直接输入 nslookup 命令，不加任何参数，此时 nslookup 会连接到默认的域名服务器（/etc/resolv.conf 的第一个 DNS 地址）；
（2）第一个参数是连字符（-），第二个参数是域名服务器的主机名或IP，即nslookup - SERVER|IP。

其他方式则进入非交互模式，比如nslookup NAME查询域名对应的IP。
2.命令格式

nslookup [-OPTION] [NAME | -] [SERVER]

NAME 为域名，SERVER 为域名服务器地址。
3.选项说明

-query=TYPE
	设置查询的类型。等同交互命令 set type=VALUE。VALUE 取值见下文
-timeout=NUMBER
	设置等待响应的超时时间，单位秒。等同交互命令 set timeout=NUMBER

4.交互命令

HOST [SERVER]
	查询域名对应的地址。如果指定 SERVER 则使用指定的域名服务器解析
server DOMAIN
	指定域名服务器
lserver DOMAIN
	改变默认域名服务器
exit
	退出交互模式
set KEYWORD[=VALUE]
	此命令用于更改影响查找的状态信息。有效关键字为：
	all
		打印所有 KEYWORD 当前配置
	class=VALUE
		改变 DNS class，VALUE 可取值 IN(Internet)、CH(Chaos)、HS(Hesiod)和 ANY，默认 IN。DNS class 用于指定信息的协议组
	[no]debug
		在搜索时打开或关闭完整响应数据包和任何中间响应数据包的显示。默认 nodebug，简写 [no]deb
	[no]d2
		打开或关闭调试模式。这将显示有关 nslookup 正在执行的操作的更多信息。默认 nod2
	domain=NAME
		设置搜索列表
	[no]search
		如果查找请求包含至少一个句点但没有以尾随句点结束，则将域搜索列表中的域名追加到请求，直到收到应答。默认 search
	port=VALUE
		修改默认的TCP/UDP域名服务器端口。默认 53
	type=VALUE
		更改查询的类型。可取值 A(A记录)、CNAME(CNAME记录)、NS(域名服务器记录)、MX(邮件交换记录)、PTR(反向记录)等。大小写不敏感，默认 A(Address)
	[no]recurse
		如果域名服务器没有该信息，请告诉它查询其他服务器。默认 recurse，简写 [no]rec
	retry=NUMBER
		设置重试次数
	timeout=NUMBER
		设置等待响应的超时时间，单位秒
	[no]vc
		打开或关闭发送请求到服务器使用虚拟电路。默认 novc
	[no]fail
		如果域名服务器响应 SERVFAIL 或推荐（nofail）或终止查询（fail），尝试下一个名称服务器。默认不尝试(nofail)

5.常用示例

（1）在非交互模式下正向解析，查询域名信息。

nslookup baidu.com
Server:		10.123.119.98
Address:	10.123.119.98#53

Non-authoritative answer:
Name:	baidu.com
Address: 39.156.69.79
Name:	baidu.com
Address: 220.181.38.148

（2）在交互模式下正向解析，查询域名信息。

nslookup
> baidu.com
Server:		10.123.119.98
Address:	10.123.119.98#53

Non-authoritative answer:
Name:	baidu.com
Address: 220.181.38.148
Name:	baidu.com
Address: 39.156.69.79
> exit

最后一个交互命令 exit 表示退出。

（3）反向解析，通过 IP 查询对应的域名。

nslookup 209.132.183.105
Server:		10.123.119.98
Address:	10.123.119.98#53

Non-authoritative answer:
105.183.132.209.in-addr.arpa	name = redirect.redhat.com.

Authoritative answers can be found from:

（4）查询域名别名。

nslookup -query=cname www.baidu.com
Server:		10.123.119.98
Address:	10.123.119.98#53

Non-authoritative answer:
www.baidu.com	canonical name = www.a.shifen.com.

Authoritative answers can be found from:

不知道为什么，查询域名别名时需要在域名前面加上 www，不然会得到如下结果：

nslookup -query=cname baidu.com
Server:		10.123.119.98
Address:	10.123.119.98#53

Non-authoritative answer:
*** Can't find baidu.com: No answer

Authoritative answers can be found from:
baidu.com
	origin = dns.baidu.com
	mail addr = sa.baidu.com
	serial = 2012144164
	refresh = 300
	retry = 300
	expire = 2592000
	minimum = 7200

（5）查询其他类型的记录。

nslookup -query=TYPE DOMAIN|IP [DNS-SERVER]
TYPE:
	A		IPv4 地址记录
    AAAA	IPv6 地址记录  
	AFSDB 	Andrew文件系统数据库服务器记录 
	ATMA 	ATM地址记录 
	CNAME	别名记录 
	HINFO	硬件配置记录，包括CPU、操作系统信息 
	ISDN	域名对应的ISDN号码 
	MB		存放指定邮箱的服务器 
	MG		邮件组记录 
	MINFO	邮件组和邮箱的信息记录 
	MR		改名的邮箱记录 
	MX		邮件服务器记录 
	NS		名字服务器记录 
	PTR		反向记录 
	RP		负责人记录 
	RT		路由穿透记录 
	SRV		TCP服务器信息记录 
	TXT		域名对应的文本信息 
	X25		域名对应的X.25地址记录

●tree 命令：
1.简介

tree 以树状格式列出目录的内容。

在没有参数的情况下，树列出当前目录中的文件。当给定目录参数时，依次列出在给定目录中找到的所有文件和目录。完成列出找到的所有文件/目录后，tree 返回列出的文件和目录总数。
2.格式

tree [-adfghilnopqrstuvxACDFNS] [-L LEVEL [-R]] [-H BASE_HREF] [-T TITLE]
[-o FILENAME] [--nolinks] [-P PATTERN] [-I PATTERN] [--inodes] [--device]
[--noreport] [--dirsfirst] [--version] [--help] [--filelimit #] [DIRECTORY...]

3.选项

-a
	显示所有文件和目录。默认情况下，树不打印隐藏文件（以点“.”开头的文件）。在任何情况下，树都不会打印文件系统结构“.”（当前目录）和“..”（以前的目录）
-A
	打印缩进线时启用 ANSI line graphics hack，即使用 ANSI 绘图字符显示树状图而非以 ASCII 字符
-C
	输出条目加上色彩，便于区分类型
-d
	只显示目录名而不现实目录的内容
-D
	列出文件或目录的最后更改时间
-f
	在每个文件或目录之前，显示完整的相对路径
-F
	在目录，Socket，执行文件，符号连接，管道名称后，各自加上"/","=","*","@","|"，当文件为普通文件时，不追加任何标识符（就像 ls -F）
-g
	列出文件或目录的所属群组名称，没有对应的名称时，则显示群组ID
-H BASE_HREF
	打开 HTML 输出，包括 HTTP 引用。对 ftp 站点有用。BASE_HREF 提供使用 HTML 输出时的基本 ftp 位置。也就是说，本地目录可以是'/local/ftp/pub'，但必须引用为'ftp://hostname.organization.domain/pub“（BASE_HREF 应该是”ftp://hostname.organization.domain'). 提示：不要将 ANSI 行与此选项一起使用，也不要在目录列表中提供多个目录。如果希望通过 CCS 样式表使用颜色，除了此选项外，还可以使用 -C 选项强制颜色输出
-i
	不以阶梯状列出文件或目录名称，与 -f 选项结合使用时非常有用
-I PATTERN
	不显示符合通配符模式的文件或目录
-l
	如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录
-L LEVEL
	目录树的最大显示深度
-n
	始终关闭着色，但会被 -C 选项覆盖
-N
	按原样打印不可打印的字符，而不是默认插入脱字符（caret notation）
-o FILENAME
	输出到指定文件
-p
	打印每个文件的文件类型和权限（就像 ls-l）
-P PATTERN
	只显示符合通配符模式的文件或目录
-q
	用"?"号取代控制字符，列出文件和目录名称
-R
	Recursively cross down the tree each level directories (see -L option), and at each of them execute tree again adding '-o 00Tree.html' as a new option
-s
	以字节为单位列出文件或目录大小
-S
	启用 ASCII 线条图形（在使用 Linux 控制台模式字体时非常有用）。此选项现在相当于“--charset=IBM437”，最终将被弃用
-t
	按上次修改时间而不是按字母顺序对输出进行排序
-T TITLE
	在HTML输出模式下设置标题和 H1 标题字符串
-u
	列出文件或目录的拥有者名称，没有对应的名称时，则显示用户ID
-v
	按版本对输出进行排序
-x
	将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围
--nolinks
	关闭HTML输出中的超链接
--inodes
	打印文件或目录的索引节点号
--device
	打印文件或目录所属的设备号
--noreport
	忽略打印树列表末尾的文件和目录报告
--dirsfirst
	在文件之前列出目录
--help
	查看帮助信息
--version
	查看版本信息
--filelimit #
	不要显示包含超过 # 个条目的目录

4.示例

（1）显示当前目录树。

tree
.
├── 00Tree.html
├── es
│   ├── go.mod
│   ├── go.sum
│   ├── main
│   └── main.go
├── gen_req
│   ├── go.mod
│   └── main.go
└── shell
    ├── cat.sh
    ├── cat.tar
    ├── newfile
    ├── students.txt
    └── txt

3 directories, 12 files

（2）显示目录的内容的时候，使用选项 -L LEVEL 指定深度，比如目录树的最大显示深度为 1。

tree -L 1
.
├── 00Tree.html
├── es
├── gen_req
└── shell

3 directories, 1 file

（3）输出条目加上色彩，便于区分类型。

tree -C

（4）以字节为单位列出文件或目录大小，且不在最后报告文件目录的数量。

tree -s --noreport
.
├── [         94]  00Tree.html
├── [       4096]  es
│   ├── [        683]  go.mod
│   ├── [      29669]  go.sum
│   ├── [    7696390]  main
│   └── [       7188]  main.go
├── [       4096]  gen_req
│   ├── [         21]  go.mod
│   └── [        353]  main.go
└── [       4096]  shell
    ├── [         86]  cat.sh
    ├── [      30720]  cat.tar
    ├── [          0]  newfile
    ├── [        473]  students.txt
    └── [       1296]  txt

●nmap 命令:
1.命令简介

nmap（Network Mapper）是一个开源的网络探测和安全扫描程序。

nmap 的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。nmap 以新颖的方式使用原始 IP 报文来发现网络上有哪些主机，这些主机提供什么服务（应用程序名和版本），这些服务运行在什么操作系统（包括版本信息）， 它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。虽然 nmap 通常用于安全审核，许多系统管理员和网络管理员也用它来做一些日常工作，比如查看整个网络的信息，管理服务升级计划，以及监视主机和服务的运行。

nmap 输出的是一个被扫描的目标列表，以及每个目标根据不同选项输出的不同补充信息。“interesting ports table”是这些信息中的关键，这张表列出端口号、协议、服务名称和状态，状态可能是 open（开放的），filtered（被过滤的）， closed（关闭的），或者 unfiltered（未被过滤的）。 open 表示目标机器上的应用程序正在该端口监听连接/报文。 filtered 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，nmap 无法得知它的状态是 open 还是 closed。 closed 端口没有应用程序在它上面监听，但是他们随时可能开放。 当端口对 nmap 的探测做出响应，但是 nmap 无法确定它们是关闭还是开放时，这些端口就被认为是 unfiltered。如果 nmap 报告状态组合 open|filtered 和 closed|filtered 时，那说明 nmap 无法确定该端口处于两个状态中的哪一个状态。 当要求进行版本探测时，端口表也可以包含软件的版本信息。当要求进行 IP 协议扫描时 (-sO)，nmap 提供关于所支持的 IP 协议而不是正在监听的端口的信息。

除了“interesting ports table”，nmap 还能提供关于目标的进一步信息，包括反向域名，操作系统猜测，设备类型，和 MAC 地址。

nmap 的常用功能有：
（1）探测一组主机是否在线；
（2）扫描主机端口，嗅探所提供的网络服务；
（3）推断主机所用的操作系统。
2.命令格式

nmap [SCAN_TYPE...] [OPTIONS] {target specification}

3.选项说明

当 nmap 不带选项运行时，下面的选项概要会被输出。它帮助人们记住最常用的选项，但不能替代本手册其余深入的文档，一些晦涩的选项甚至不在这里。最新的选项概要可以在 https://nmap.org/data/nmap.usage.txt 查看。
TARGET SPECIFICATION

可以传递主机名、IP地址、网络等。

-iL <inputfilename>
	从指定文件中读取扫描的目标。在这个文件中要有一个主机或者网络的列表，由空格键、制表键或者回车键作为分割符。如果使用 -iL -，会从标准输入读取
-iR <num hosts>
	随机挑选主机进行扫描
--exclude <host1[,host2][,host3],...>
	排除指定的主机/网络
--excludefile <exclude_file>
	从文件指定文件中读取要排除的主机/网络

HOST DISCOVERY

-sL
	列表扫描-仅列出要扫描的目标
-sn
	Ping 扫描-禁用端口扫描
-Pn
	将所有主机视为联机--跳过主机发现(No ping)
-sP
	Ping 扫描-仅确定主机是否联机
-PS/PA/PU/PY [PORTLIST]
	TCP SYN/ACK/UDP/SCTP 发现探测到给定端口
-PO[protocol list]
	IP 协议 Ping
-PE/PP/PM
	ICMP 回显、时间戳和网络掩码请求发现探测
-n/-R
	从不进行 DNS 解析/始终解析[默认：有时解析]
--dns-servers <serv1[,serv2],...>
	指定自定义 DNS 服务器
--system-dns
	使用操作系统的 DNS 解析程序
--traceroute
	跟踪每个主机的跃点路径

SCAN TECHNIQUES

-sS/sT/sA/sW/sM
	TCP SYN/Connect()/ACK/Window/Maimon 扫描
-sN/sF/sX
	TCP Null, FIN 和 Xmas 扫描
--scanflags <flags>
	自定义TCP扫描标志
-sI <zombie host[:probeport]>
	空闲扫描
-sY/sZ
	SCTP INIT/COOKIE-ECHO 扫描
-sO
	IP 协议扫描
-b <FTP relay host>
	FTP 反弹扫描

PORT SPECIFICATION AND SCAN ORDER

-p <port ranges>
	只扫描指定端口，如 -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9
--exclude-ports <port ranges>
	从扫描中排除指定的端口
-F
	快速模式-扫描的端口数少于默认扫描
-r
	连续扫描端口-不要随机化
--top-ports <number>
	扫描 <number> 最常见的端口
--port-ratio <ratio>
	以大于给定值的比率扫描 nmap 服务文件中的所有端口，ratio 必须是 0.0 到 1.0 之间

SERVICE/VERSION DETECTION

-sV
	探测打开的端口以确定服务/版本信息
--version-intensity <level>
	设置版本探针强度（从 0 到 9，缺省为 7）
--version-light
	使用轻度探测强度，等价于 --version-intensity 2。这种模式使版本扫描速度更快，但识别服务的可能性稍低
--version-all
	等价于 --version-intensity 9，确保针对每个端口尝试每个探测器
--version-trace
	显示详细的版本扫描活动（用于调试）

SCRIPT SCAN

-sC
	等价于 --script=default
--script=<Lua scripts>
	<Lua scripts> 是以逗号分隔的目录、脚本文件或脚本类别
--script-args=<n1=v1,[n2=v2,...]>
	为脚本提供参数
--script-args-file=filename
	在文件中提供NSE脚本参数
--script-trace
	显示发送和接收的所有数据
--script-updatedb
	更新脚本数据库
--script-help=<Lua scripts>
	显示有关脚本的帮助

OS DETECTION

-O
	启用操作系统检测
--osscan-limit
	不符合此条件的主机不尝试操作系统检测，这可以节省大量的时间
--osscan-guess
	更积极地猜测操作系统

TIMING AND PERFORMANCE

时间值 默认以秒为单位，或附加时间单位 ms（秒），s（秒），m（分钟）或 h（小时），如 30m。

-T<0-5>
	设置计时模板（越高速度越快）
--min-hostgroup/max-hostgroup <size>
	并行主机扫描组大小
--min-parallelism/max-parallelism <numprobes>
	探测并行化
--min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout <time>
	指定探测往返时间
--max-retries <tries>
	Caps 端口扫描探头重新传输的次数
--host-timeout <time>
	设置主基探测超时时间
--scan-delay/--max-scan-delay <time>
	调整探针之间的延迟
--min-rate <number>
	发送数据包的速度不低于每秒 <number>
--max-rate <number>
	发送数据包的速度不高于每秒 <number>

FIREWALL/IDS EVASION AND SPOOFING

-f; --mtu <val>
	-f 选项使扫描请求（包括主机发现扫描）使用微小的碎片化 IP 数据包，可以用过选项 --mtu 指定 MTU
-D <decoy1,decoy2[,ME],...>
	用诱饵掩盖扫描
-S <IP_Address>
	欺骗源地址
-e <iface>
	使用指定的接口
-g/--source-port <portnum>
	使用给定的端口号
--proxies <url1,[url2],...>
	通过HTTP/SOCKS4代理中继连接
--data <hex string>
	将自定义有效负载附加到发送的数据包
--data-string <string>
	向发送的数据包附加自定义ASCII字符串
--data-length <num>
	向发送的数据包附加随机数据
--ip-options <options>
	使用指定的 IP 选项发送数据包
--ttl <val>
	设置 IP 生存时间字段
--spoof-mac <mac address/prefix/vendor name>
	要求 mmap 为其发送的所有原始以太网帧使用给定的 MAC 地址
--badsum
	使用伪 TCP/UDP/SCTP 校验和发送数据包

OUTPUT

-oN/-oX/-oS/-oG <file>
	分别以普通、XML、s|<cript kIddi3 和 grepable 格式输出扫描到给定文件名
-oA <basename>
	同时以三种主要格式输出
-v
	增加详细程度（使用 -vv 或更多以获得更大效果）
-d
	提高调试级别（使用 -dd 或更多以获得更大的效果）
--reason
	显示端口处于特定状态的原因
--open
	仅显示打开（或可能打开）的端口
--packet-trace
	显示发送和接收的所有数据包
--iflist
	打印主机接口和路由（用于调试）
--append-output
	附加到指定的输出文件而不是覆盖
--resume <filename>
	恢复中止的扫描
--noninteractive
	禁用运行时交互
--stylesheet <path/URL>
	使用 XSL 样式表查看 XML 输出或将其转换为 HTML
--webxml
	从 Nmap.Org 加载样式表，等价于 --stylesheet https://nmap.org/svn/docs/nmap.xsl
--no-stylesheet
	防止 nmap 将任何 XSL 样式表与其 XML 输出关联

MISC

-6
	启用 IPv6 扫描
-A
	启用操作系统检测、版本检测、脚本扫描和跟踪路由
--datadir <dirname>
	指定自定义 nmap 数据文件位置
--send-eth/--send-ip
	使用原始以太网帧或IP数据包发送
--privileged
	假设用户具有完全特权
--unprivileged
	假设用户缺少原始套接字权限
-V
	打印版本号
-h
	打印帮助摘要信息

4.常用示例

（1）扫描远程主机的指定端口来判断是否开放。

nmap IP -p PORT

# 示例
nmap 14.215.177.88 -p 8000

Starting Nmap 6.40 ( http://nmap.org ) at 2021-11-01 15:55 CST
Nmap scan report for 14.215.177.38
Host is up (0.00027s latency).
PORT     STATE SERVICE
8000/tcp open  unknown

Nmap done: 1 IP address (1 host up) scanned in 0.29 seconds

输出中 open 表示指定端口正在被监听。

（2）扫描指定 IP 或域名下开放的端口，可以很方便地发现目标端口的开放情况及主机在线情况。

nmap docs.nvidia.com

Starting Nmap 6.40 ( http://nmap.org ) at 2021-11-01 16:00 CST
Nmap scan report for docs.nvidia.com (129.227.48.130)
Host is up (0.00021s latency).
Other addresses for docs.nvidia.com (not scanned): 129.227.48.131 129.227.48.132 129.227.48.133 129.227.6.189 129.227.6.190 192.254.94.202 192.254.94.203 129.227.114.197 129.227.114.198
PORT      STATE SERVICE
1/tcp     open  tcpmux
3/tcp     open  compressnet
...
63331/tcp open  unknown
64623/tcp open  unknown
64680/tcp open  unknown
65000/tcp open  unknown
65129/tcp open  unknown
65389/tcp open  unknown

Map done: 1 IP address (1 host up) scanned in 9.53 seconds

(3) Ping 扫描。

Ping 扫描只进行 ping，然后显示出在线的主机。使用该选项扫描可以轻易获取目标信息而不会被轻易发现。

在默认情况下，nmap 会发送一个 ICMP 回声请求和一个 TCP 报文到目标端口。Ping 扫描的优点是不会返回太多的信息影响对结果的分析，并且扫描方式高效。

nmap -sP 192.168.0.0/24

Starting Nmap 6.40 ( http://nmap.org ) at 2021-11-04 23:19 CST
Nmap scan report for 192.168.0.0
Host is up (0.023s latency).
Nmap scan report for 192.168.0.1
Host is up (0.0056s latency).
Nmap scan report for 192.168.0.2
....
Nmap scan report for 192.168.0.255
Host is up (0.023s latency).
Nmap done: 256 IP addresses (256 hosts up) scanned in 1.99 seconds

●hexdump 命令:
1.命令简介

hexdump 以 ASCII、十进制、十六进制或八进制显示文件内容。
2.命令格式

hexdump [options] FILE [...]

3.选项说明

-b
	单字节八进制显示。
 -c
 	单字节字符显示。
 -C
 	规范化“十六进制+ASCII”显示。
 -d
 	两字节十进制显示。
 -e <format_string>
	以指定的格式字符串显示数据。
 -f <format_file>
	指定包含一个或多个换行分隔格式字符串的文件。内容使用 # 号开头表示注释。
-n <length>
	只解释输入的指定长度个字节。
 -o
	两字节八进制显示。
 -s <offset>
 	跳过开头指定长度个字节。
 -v
 	显示时不压缩相似的行。-v 选项使 hextump 显示所有输入数据。没有 -v 选项，任何数量的输出行组，如果与前一组相同，将被替换为由一个星号构成的行。
 -x
 	两字节十六进制显示。

4.格式
4.1 格式字符串

格式字符串可以包含任意数量的格式单元，由空格分隔。格式单元最多包含三项：迭代计数、字节计数和格式。

迭代计数是可选的正整数，缺省为1，表示每种格式应用的次数。

字节计数是可选的正整数，表示每次按照指定格式迭代要解释的字节数。

如果指定了迭代计数和/或字节计数，则必须使用单斜杠放在迭代计数之后和/或字节计数之前消除歧义。斜杠前后的任何空格都将被忽略。

格式是必需的，必须用双引号括起来。它被解释为 fprintf 样式的格式字符串（参见 fprintf(3)），但以下情况除外：

    星号（*）不能用作字段宽度或精度。
    每个 s 转换字符都需要字节计数或字段精度（不同于 fprintf(3) 默认值，如果精度未指定，则打印整个字符串）。
    不支持转换字符 h、l、n、p 和 q。
    支持 C 标准中描述的单字符转义序列。

字符	转义
NULL	\0
<alert character>	\a
<backspace>	\b
<form-feed>	\f
<newline>	\n
<carriage return>	\r
<tab>	\t
<vertical tab>	\v
4.2 转换字符串

hexdump 还支持以下额外的转换字符串用于格式字符串中。

_a[dox]
	标记下一个输出字节的偏移量，在输入文件中累积。d、o、x 分别以十进制、八进制和十六进制显示。
_A[dox]
	与 _a 转换字符串相同，只是在处理所有输入数据后只执行一次。
_c
	在默认字符集中输出字符。非打印字符以三个字符、零填充八进制显示，但可通过标准转义符号（见上文）表示的字符除外。
_p
	默认字符集中输出字符。非打印字符显示为单个点号 “.”。
_u
	输出美国 ASCII 字符，控制字符使用以下小写名称显示除外。大于 0xff 的字符显示为十六进制字符串。

控制字符如下：
码值	名称	全称
0x00	nul	null
0x01	soh	start of headline
0x02	stx	start of text
0x03	etx	end of text
0x04	eot	end of transmission
0x05	enq	enquiry
0x06	ack	acknowledge
0x07	bel	bell
0x08	bs	backspace
0x09	ht	horizontal
0x0A	lf	line feed
0x0B	vt	vertical tab
0x0C	ff	form feed
0x0D	cr	carriage return
0x0E	so	shift out
0x0F	si	shift in
0x10	dle	data link escape
0x11	dc1	device control 1
0x12	dc2	device control 2
0x13	dc3	device control 3
0x14	dc4	device control 3
0x15	nak	negative acknowledgement
0x16	syn	synchronous idle
0x17	etb	end of transmission block
0x18	can	cancel
0x19	em	end of medium
0x1A	sub	substitute
0x1b	esc	escape
0x1C	fs	file separator
0x1D	gs	group separator
0x1E	rs	record separator
0x1F	us	unit separator
0x7F	del	delete
5.常用示例

假设有一个名为 txt 内容为 lvlv 的文本内容。

（1）不指定选项缺省以十六进制显示指定文件的内容。

hexdump txt
0000000 766c 766c 000a                         
0000005

其中第一列为偏移量。

（2）单字节字符展示。

hexdump -c txt
0000000   l   v   l   v  \n                                            
0000005

（3）输出十六进制和对应字符。

hexdump -C txt
00000000  6c 76 6c 76 0a                                    |lvlv.|
00000005

（4）从指定偏移量开始输出。

比如偏移两个字节，跳过第一个 lv。

hexdump -s2 -C txt
00000002  6c 76 0a                                          |lv.|
00000005

（5）格式化输出并标记每个字节的偏移量。

hexdump -e'/1 "%_ad %02X\n"' txt
0 6C
1 76
2 6C
3 76
4 0A

●mkfs命令:
一、命令简介

  Linux mkfs（英文全拼：make file system）命令用于在特定的分区上建立 linux 文件系统。mkfs是跟fdisk、fsck、mount等命令都是util-linux包的一部分。当运行mkfs时，可以指定全局选项，也可以指定mkfs要创建的文件系统类型（如：ext3、ext4、msdos）的特定选项，全局选项必须位于特定类型选项的前面。实际上，mkfs只是Linux下可用的各种文件系统构建器（mkfs.fstype）的前端。
二、使用示例
1、获取命令帮助

    [root@s151 ~]# mkfs --help

2、查看命令版本

    [root@s151 ~]# mkfs -V
    mkfs，来自 util-linux 2.23.2

3、将指定分区格式化为ext4格式

    [root@s151 ~]# mkfs -t ext4 /dev/sdb1
    mke2fs 1.42.9 (28-Dec-2013)
    Discarding device blocks: 完成
    文件系统标签=
    OS type: Linux
    块大小=4096 (log=2)
    分块大小=4096 (log=2)
    Stride=0 blocks, Stripe width=0 blocks
    655360 inodes, 2621440 blocks
    131072 blocks (5.00%) reserved for the super user
    第一个数据块=0
    Maximum filesystem blocks=2151677952
    80 block groups
    32768 blocks per group, 32768 fragments per group
    8192 inodes per group
    Superblock backups stored on blocks:
    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632

    Allocating group tables: 完成
    正在写入inode表: 完成
    Creating journal (32768 blocks): 完成
    Writing superblocks and filesystem accounting information: 完成
    [root@s151 ~]# mount /dev/sdb1 /datatest/
    [root@s151 ~]# df -hT
    文件系统 类型 容量 已用 可用 已用% 挂载点
    /dev/mapper/centos-root xfs 39G 1.5G 37G 4% /
    devtmpfs devtmpfs 908M 0 908M 0% /dev
    tmpfs tmpfs 919M 0 919M 0% /dev/shm
    tmpfs tmpfs 919M 8.5M 911M 1% /run
    tmpfs tmpfs 919M 0 919M 0% /sys/fs/cgroup
    /dev/sda1 xfs 1014M 145M 870M 15% /boot
    /dev/mapper/centos-home xfs 19G 3.3G 16G 18% /home
    tmpfs tmpfs 184M 0 184M 0% /run/user/0
    /dev/sdb1 ext4 9.8G 37M 9.2G 1% /datatest

4、格式化指定磁盘2G空间

    [root@s151 ~]# mkfs /dev/sdb2 2G
    mke2fs 1.42.9 (28-Dec-2013)
    Discarding device blocks: 完成
    文件系统标签=
    OS type: Linux
    块大小=4096 (log=2)
    分块大小=4096 (log=2)
    Stride=0 blocks, Stripe width=0 blocks
    131072 inodes, 524288 blocks
    26214 blocks (5.00%) reserved for the super user
    第一个数据块=0
    Maximum filesystem blocks=536870912
    16 block groups
    32768 blocks per group, 32768 fragments per group
    8192 inodes per group
    Superblock backups stored on blocks:
    32768, 98304, 163840, 229376, 294912

    Allocating group tables: 完成
    正在写入inode表: 完成
    Writing superblocks and filesystem accounting information: 完成

    [root@s151 ~]# mount /dev/sdb2 /datatest/
    [root@s151 ~]# df -hT
    文件系统 类型 容量 已用 可用 已用% 挂载点
    /dev/mapper/centos-root xfs 39G 1.5G 37G 4% /
    devtmpfs devtmpfs 908M 0 908M 0% /dev
    tmpfs tmpfs 919M 0 919M 0% /dev/shm
    tmpfs tmpfs 919M 8.5M 911M 1% /run
    tmpfs tmpfs 919M 0 919M 0% /sys/fs/cgroup
    /dev/sda1 xfs 1014M 145M 870M 15% /boot
    /dev/mapper/centos-home xfs 19G 3.3G 16G 18% /home
    tmpfs tmpfs 184M 0 184M 0% /run/user/0
    /dev/sdb2 ext2 2.0G 3.0M 1.9G 1% /datatest

5、mkfs关联命令

    [root@s151 ~]# mkfs
    mkfs mkfs.btrfs mkfs.cramfs mkfs.ext2 mkfs.ext3 mkfs.ext4 mkfs.minix mkfs.xfs
    #mkfs只可以创建extX格式文件系统，如果需要格式化为xfs需要使用mkfs.xfs命令。已有文件系统格式化需要，使用-f参数。

三、使用语法及参数说明
1、使用语法

    #mkfs [选项] [-t <类型>] [文件系统选项] <设备> [<大小>]

2、参数说明
参数选项	参数说明
-t, --type=<类型>	文件系统类型；若不指定，将使用 ext2
fs-options	实际文件系统构建程序的参数
<设备>	要使用设备的路径
<大小>	要使用设备上的块数
-V, --verbose	解释正在进行的操作；多次指定 -V 将导致空运行(dry-run)
-V, --version	显示版本信息并退出,将 -V 作为 --version 选项时必须是惟一选项
-h, --help	显示此帮助并退出

●Linux磁盘格式化(mkfs、mkfs.xfs、mkfs.ext4)、Linux文件系统的校验(xfs_repair、fsck_ext4):
一、mkfs命令

    磁盘分区完毕后自然就是要进行文件系统的格式化
    格式化其实就是创建文件系统。命令就是===>mkfs（make fileststem），这个命令只是个综合命令。它会调用正确的文件系统格式化工具
    功能：mkfs是个综合命令
    使用
        mkfs [tab] [tab]：按下两下tab键查看系统支持哪些文件系统的格式化功能
        mkfs -t [文件系统格式名]===>等同于mkfs.文件系统格式名
        mkfs -t xfs 与 mkfs.xfs相同

二、格式化XFS文件系统（mkfs.xfs）

    XFS文件系统简介：https://dongshao.blog.csdn.net/article/details/86694903
    功能：创建xfs文件系统
    格式
        mkfs.xfs  [-b 参数]  [-d 参数]  [-i 参数]  [-l 参数]  [-L 参数]  [-f]  [-r 参数]  设备名称
        第一次执行mkfs.xfs可能需要安装：apt-get install xfsprogs

相关参数

    -b：后面接的是区块容量，范围是512B-64K。不过Linux最大为4K
    -d：后面接的是data section(数据区)的相关参数值

agcount=数值	设置需要几个存储群组的意思（AG），通常与CPU有关
agsize=数值	每个AG设置为多少容量的意思。通常agcount/agsize只选一个设置
file	指的是格式化的设备是个文件而不是个设备的意思（例如虚拟磁盘）
size=数值	data section的容量。你可以设置大小
su=数值	当有RAID(磁盘列阵)时，代表stripe的数值大小，与下面的sw搭配使用
sw=数值	当有RAID时，用于保存数据的磁盘数量(需扣除备份盘与备用盘)
sunit=数值	与su意思相同。不过单位使用的是几个sector(512B)的意思(一个stripe由多少个扇区组成)
swidth=数值	就是su*sw的数值，但是以几个sector(512B)来设置

    -f：如果设备内已经有了文件系统，则需要使用-f强制格式化
    -i的参数：与inode有较相关的设置

size=数值	最小的是256B，最大是2K。一般使用256B就足够了
internal=[0/1]	log设备是否为内置。默认1为内置，如果使用外部设备，使用下面设置
logdev=设备名	log设备为后面接的那个设备上面的意思，需设置internal=0才可以
size=数值	指定这块登录区的容量，通常最小得要512个区块，大约2M=以上才行

    -L参数：后面接这个文件系统的标头名称Label name
    -r参数：指定realtime section(实时运行区)的相关设置值

extsize=数值	就是那个重要的extent区块数值，一般不需设置。但有RAID时，最好设置与swidth的数值相同较佳。最小为4K，最大为1G
演示案例

    使用mkfs.xfs命令时，一般默认回车就可以了，使用系统默认的
    演示案例1：使用gdisk新建一个sda2新分区，并格式化成为xfs文件系统

    演示案例2：设置CPU的数量
        有时我们为了使用多个数据流来读写系统，以增加速度，需要设置多个agcount数量，agcount与CPU的内核数有关
        查看一下系统的CPU数量：grep 'processor' /proc/cpuinfo
        如果需要两个线程的CPU数量时：mkfs.xfs -f -d agcount=2 /dev/sda2

XFS文件系统for RAID性能优化

    磁盘列阵（RAID）：磁盘列阵是多块磁盘组成一块大磁盘的意思，利用同步写入到这块磁盘的技术，不但可以加快读写速度，还可以让某一块磁盘坏掉时，整个文件系统还是可以持续运行，这就是所谓的容错
    结构特点
        stripe：磁盘列阵通过将文件先细分成为数个小型的分区区块（stripe）之后，然后将众多的stripes分别放到磁盘列阵里面的所有磁盘，所以一个文件是被同时写入到多个磁盘中，性能会好一些。stripe与你的文件数据容量以及性能相关性较高
        stripe的大小：分区区块的数值介于4K-1M之间，这与你的磁盘列阵卡支持的选项有关。当你的系统多大是大型文件时，一般建议stripe大一些，如果小文件较多，建议设置64K左右
        安全性：在这些磁盘里面，会保留数个校验磁盘(parity disk)，以及可能会保留一个以上的备用磁盘(spare disk)。这些磁盘会占用总磁盘列阵的容量
    演示案例：使用mkfs.xfs格式化磁盘列阵。我们假设：
        我有两个线程的CPU数量，所以agcount最好指定为2
        RAID的stripe指定为256K，则su也指定为256K
        磁盘列阵总共有8块，因为RAID 5标准的设置，有1个校验盘，所以指定sw为7
        由上述可知，数据宽度(swidth)指定为256K*7=1792K，extsize=1792K

mkfs.xfs -f -d agcount=2,su=256k,sw=7 -r extsize=1792k  /dev/sda2

    承上，如果我们使用sunit与swidth来设置，则
        sunit=256K/512B*1024B=512个sector
        swidth=7个磁盘*sunit=7*512=3584个sector

mkfs.xfs -f -d agcount=2,sunit=512,swidth=3584 -r extsize=1792k  /dev/sda2

三、ext4文件系统格式化（mkfs.ext4）

    功能：创建ext4文件系统
    格式

mkfs.ext4 [-b 参数]  [-L 参数]  设备名称

    参数
        -b：后面设置区块的大小，有1K、2K、4K
        -L：后面接这个设备的标头名称Label name
    提示：
        ext4的默认值已经相当合适我们系统使用，大部分的默认值写入至/etc/mke2fs.conf这个文件中
        因此我们无需额外指定inode的容量，系统都帮我们做好了默认值，只需要知道uuid即可
    演示案例：

mkfs.ext4 /dev/sda2

四、其他文件系统格式化

    mkswap 设备文件名：用于内存交换分区的格式化
    mkfs.vfta 设备文件名：vfat文件系统格式的格式化

五、Linux文件系统的校验

    系统运行时，如果硬件或者电源等出问题，或者文件系统运行时，磁盘与内存数据异步的状态发生，系统会出错
    此时就需要文件系统的校验，不同的文件系统命令不一样，下面我们主要针对xfs于ext4文件系统进行讲解
    下面的命令只有当文件系统出错且为root身份时在使用，不要随意使用，可能会对系统造成危害
    重点：修复文件系统时，可能会造成文件系统的改变，所以执行命令时，被检测的硬盘分区不能被挂载，若挂载则不能顺利的修复文件系统，需要卸载后再处理。当然，没有挂载的文件系统可以处理

六、xfs_repair处理XFS文件系统

    功能：对XFS文件系统进行检测或者修复
    格式：

xfs_repair [选项] 设备名称

    选项：
        -f：后面的设备其实是个文件而不是设备时使用
        -n：单纯检查并不修改文件系统的任何数据
        -d：通常用在单人维护模式下，针对根目录（/）进行检查与修复（很危险，不要随便使用）
    注意事项：Linux的根目录无法被卸载，所以需要使用-d进入单人维护模式处理，但是跟某的检查与修复尽量避免
    例如：校验/dev/sda2分区

xfs_repair /dev/sda2

七、fsck_ext4处理ext4文件系统

    功能：对ext4文件系统进行检测或者修复
    格式：

fsck_ext4 [选项] [-b 参数] 设备名称

    选项与参数：
        -p：当文件系统在修复时，如果有需要回复y的操作，自动回复
        -f：强制详细检查。一般来说，fsck没有发现任何unclean的标识，不会主动进入详细检查的。如果加上这个参数，fsck就会详细检查
        -D:针对文件系统下的目录进行最佳化配置
        -b的参数：后面跟的是超级区块的位置，这个选项一般用不到。如果你的超级区块受损时，就可以使用这个参数利用文件系统的备份超级区块来尝试修复。一般来说，超级区块备份在：1K区块在8193、2K区块在16384、4K区块在32768

演示案例

    ①对32768区块进行校验：如果文件系统出问题，会提示你是否输入y进行修复。并且文件系统修复完，会有警告信息

fsck_ext4 -b 32768 /dev/sda2

    ②文件系统正确，进行强制校验

fsck_ext4 -f /dev/sda2


●apt命令：

    最常用的 Linux 包管理命令都被分散在了 apt-get、apt-cache 和 apt-config 这三条命令当中。

    apt 命令的引入就是为了解决命令过于分散的问题，它包括了 apt-get 命令出现以来使用最广泛的功能选项，以及 apt-cache 和 apt-config 命令中很少用到的功能。

    在使用 apt 命令时，用户不必再由 apt-get 转到 apt-cache 或 apt-config，而且 apt 更加结构化，并为用户提供了管理软件包所需的必要选项。

apt和apt-get命令之间的区别
apt 命令	          取代的命令	         命令的功能
apt install	          apt-get install	安装软件包
apt remove	          apt-get remove	移除软件包
apt purge	          apt-get purge	移除软件包及配置文件
apt update	          apt-get update	刷新存储库索引
apt upgrade	          apt-get upgrade	升级所有可升级的软件包
apt autoremove	apt-get autoremove	自动删除不需要的包
apt full-upgrade	apt-get dist-upgrade	在升级软件包时自动处理依赖关系
apt search	          apt-cache search	搜索应用程序
apt show	          apt-cache show	显示装细节

apt 还有一些自己的命令：

    apt list 列出包含条件的包（已安装，可升级等）
    apt edit-sources 编辑源列表

1 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数”
2 包管理工具 apt-get
3 支持tar包

apt-get：

参数

 -h 		帮助文件。  

 -q 		输出到日志 - 无进展指示  

 -qq 		不输出信息，错误除外  

 -d 		仅下载 - 不安装或解压归档文件  

 -s 		不实际安装。模拟执行命令  

 -y 		在需要确认的场景中回应 yes

 -f 		尝试修正系统依赖损坏处  

 -m 		如果归档无法定位，尝试继续  

 -u 		同时显示更新软件包的列表  

 -b 		获取源码包后编译  

 -V 		显示详细的版本号  

 -c=? 		阅读此配置文件  

 -o=? 		设置自定的配置选项，如 -o dir::cache=/tmp  


升级 & 安装

apt-get update						// 更新源文件，并不会做任何安装升级操作

apt-get upgrade						// 升级所有已安装的包

apt-get install packagename				// 安装指定的包

apt-get install packagename --only-upgrade		// 仅升级指定的包

apt-get install packagename --reinstall   		// 重新安装包

apt-get -f install   					// 修复安装

apt-get build-dep packagename				// 安装相关的编译环境

apt-get source packagename  				// 下载该包的源代码

apt-get dist-upgrade 					// 升级系统

apt-get dselect-upgrade 	

查询 & 显示

apt-cache search packagename 				// 查询指定的包  　　

apt-cache show packagename 				// 显示包的相关信息，如说明、大小、版本等 

apt-cache depends packagename 				// 了解使用该包依赖哪些包

apt-cache rdepends packagename 				// 查看该包被哪些包依赖

删除 & 清理

apt-get remove packagename				// 删除包  　　

apt-get remove packagename -- purge 			// 删除包，包括删除配置文件等 

apt-get autoremove packagename --purge 			// 删除包及其依赖的软件包+配置文件等（只对6.10有效，推荐使用）

apt-get clean 						// 清理无用的包 

apt-get autoclean 					// 清理无用的包 

apt-get check 						// 检查是否有损坏的依赖

●dpkg命令：
dpkg 是 Debian 软件包管理器的基础，它由 伊恩·默多克 于 1993 年创建。dpkg 与  RPM  十分相似，同样可用于安装、卸载和提供 deb 软件包相关信息。

       dpkg 本身是一个底层工具。上层工具，如： APT ，用于从 远程获取软件包 以及处理复杂的软件包关系。

详细用法

01、安装软件                                                              	命令行：dpkg -i <.deb file name>	示例：dpkg -i avg71flm_r28-1_i386.deb

02、安装一个目录下的所有软件包	命令行：dpkg -R	示例：dpkg -R /usr/local/src

03、释放软件包，但不进行配置	命令行：dpkg –-unpack package_file
如果和 -R 一起使用，参数可以是一个目录	示例：dpkg –-unpack avg71flm_r28-1_i386.deb

04、重新配置和释放软件包	命令行：dpkg --configure package_file
如果和 -a 一起使用，将配置所有没有配置的软件包	示例：dpkg –configure avg71flm_r28-1_i386.deb


05、重新配置环境	命令行：dpkg-reconfigure env	示例：dpkg-reconfigure locales(重新配置系统本地环境设置)

06、删除软件包（保留其配置信息）	命令行：dpkg -r package_file	示例：dpkg -r avg71flm

07、替换软件包信息	命令行：dpkg --update-avail	

08、合并软件包信息	命令行：dpkg --merge-avail	

09、从软件包里读取软件信息	命令行：dpkg -A package_file	

10、删除一个包（包括配置信息）	命令行：dpkg -P	

11、丢弃所有 Uninstall 软件包信息	命令行：dpkg --forget-old-unavail	

12、删除软件包的 Avaliable 信息	命令行：dpkg --clear-avail	

13、查找仅部分安装的软件包信息	命令行：dpkg -C	

14、比较同一个包的不同版本之间的差别	命令行：dpkg --compare-versions ver1 op ver2	

15、显示帮助信息	命令行：dpkg --help	

16、显示 dpkg 的 Licence	命令行：dpkg --licence (or) dpkg --License	

17、显示 dpkg 的版本号	命令行：dpkg --version	

18、建立一个 deb 文件	命令行：dpkg -b directory [filename]	

19、显示一个 Deb 文件的目录	命令行：dpkg -c filename	

20、显示一个 Deb 的说明	命令行：dpkg -I filename [control-file]	

21、搜索 Deb 包	命令行：dpkg -l package-name-pattern	示例：dpkg -l vim

22、显示所有已经安装的 Deb 包，同时显示版本号以及简短说明	命令行：dpkg -l	

23、报告指定包的状态信息	命令行：dpkg -s package-name	示例：dpkg -s ssh

24、显示一个包安装到系统里面的文件目录信息	命令行：dpkg -L package-Name	示例：dpkg -L apache2

25、显示包含该软件包的所有目录	命令行：dpkg -S filename-search-pattern	

26、显示包的具体信息	命令行：dpkg -p package-name	示例：dpkg -p cacti
